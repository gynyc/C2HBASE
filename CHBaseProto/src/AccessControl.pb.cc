// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AccessControl.proto

#include "AccessControl.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GlobalPermission_AccessControl_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NamespacePermission_AccessControl_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Permission_AccessControl_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_HBase_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TableName_HBase_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TablePermission_AccessControl_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UserPermission_AccessControl_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto;
namespace hbase {
namespace pb {
class PermissionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Permission> _instance;
} _Permission_default_instance_;
class TablePermissionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TablePermission> _instance;
} _TablePermission_default_instance_;
class NamespacePermissionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NamespacePermission> _instance;
} _NamespacePermission_default_instance_;
class GlobalPermissionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GlobalPermission> _instance;
} _GlobalPermission_default_instance_;
class UserPermissionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UserPermission> _instance;
} _UserPermission_default_instance_;
class UsersAndPermissions_UserPermissionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsersAndPermissions_UserPermissions> _instance;
} _UsersAndPermissions_UserPermissions_default_instance_;
class UsersAndPermissionsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<UsersAndPermissions> _instance;
} _UsersAndPermissions_default_instance_;
class GrantRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GrantRequest> _instance;
} _GrantRequest_default_instance_;
class GrantResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GrantResponse> _instance;
} _GrantResponse_default_instance_;
class RevokeRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RevokeRequest> _instance;
} _RevokeRequest_default_instance_;
class RevokeResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<RevokeResponse> _instance;
} _RevokeResponse_default_instance_;
class GetUserPermissionsRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetUserPermissionsRequest> _instance;
} _GetUserPermissionsRequest_default_instance_;
class GetUserPermissionsResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<GetUserPermissionsResponse> _instance;
} _GetUserPermissionsResponse_default_instance_;
class CheckPermissionsRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CheckPermissionsRequest> _instance;
} _CheckPermissionsRequest_default_instance_;
class CheckPermissionsResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<CheckPermissionsResponse> _instance;
} _CheckPermissionsResponse_default_instance_;
class HasPermissionRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HasPermissionRequest> _instance;
} _HasPermissionRequest_default_instance_;
class HasPermissionResponseDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<HasPermissionResponse> _instance;
} _HasPermissionResponse_default_instance_;
}  // namespace pb
}  // namespace hbase
static void InitDefaultsscc_info_CheckPermissionsRequest_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_CheckPermissionsRequest_default_instance_;
    new (ptr) ::hbase::pb::CheckPermissionsRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::CheckPermissionsRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_CheckPermissionsRequest_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_CheckPermissionsRequest_AccessControl_2eproto}, {
      &scc_info_Permission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_CheckPermissionsResponse_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_CheckPermissionsResponse_default_instance_;
    new (ptr) ::hbase::pb::CheckPermissionsResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::CheckPermissionsResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_CheckPermissionsResponse_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_CheckPermissionsResponse_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_GetUserPermissionsRequest_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_GetUserPermissionsRequest_default_instance_;
    new (ptr) ::hbase::pb::GetUserPermissionsRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::GetUserPermissionsRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_GetUserPermissionsRequest_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_GetUserPermissionsRequest_AccessControl_2eproto}, {
      &scc_info_TableName_HBase_2eproto.base,}};

static void InitDefaultsscc_info_GetUserPermissionsResponse_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_GetUserPermissionsResponse_default_instance_;
    new (ptr) ::hbase::pb::GetUserPermissionsResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::GetUserPermissionsResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_GetUserPermissionsResponse_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_GetUserPermissionsResponse_AccessControl_2eproto}, {
      &scc_info_UserPermission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_GlobalPermission_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_GlobalPermission_default_instance_;
    new (ptr) ::hbase::pb::GlobalPermission();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::GlobalPermission::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GlobalPermission_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_GlobalPermission_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_GrantRequest_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_GrantRequest_default_instance_;
    new (ptr) ::hbase::pb::GrantRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::GrantRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_GrantRequest_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_GrantRequest_AccessControl_2eproto}, {
      &scc_info_UserPermission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_GrantResponse_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_GrantResponse_default_instance_;
    new (ptr) ::hbase::pb::GrantResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::GrantResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_GrantResponse_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_GrantResponse_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_HasPermissionRequest_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_HasPermissionRequest_default_instance_;
    new (ptr) ::hbase::pb::HasPermissionRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::HasPermissionRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_HasPermissionRequest_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_HasPermissionRequest_AccessControl_2eproto}, {
      &scc_info_TablePermission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_HasPermissionResponse_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_HasPermissionResponse_default_instance_;
    new (ptr) ::hbase::pb::HasPermissionResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::HasPermissionResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_HasPermissionResponse_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_HasPermissionResponse_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_NamespacePermission_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_NamespacePermission_default_instance_;
    new (ptr) ::hbase::pb::NamespacePermission();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::NamespacePermission::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NamespacePermission_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_NamespacePermission_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_Permission_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_Permission_default_instance_;
    new (ptr) ::hbase::pb::Permission();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::Permission::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_Permission_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, InitDefaultsscc_info_Permission_AccessControl_2eproto}, {
      &scc_info_GlobalPermission_AccessControl_2eproto.base,
      &scc_info_NamespacePermission_AccessControl_2eproto.base,
      &scc_info_TablePermission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_RevokeRequest_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_RevokeRequest_default_instance_;
    new (ptr) ::hbase::pb::RevokeRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::RevokeRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_RevokeRequest_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_RevokeRequest_AccessControl_2eproto}, {
      &scc_info_UserPermission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_RevokeResponse_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_RevokeResponse_default_instance_;
    new (ptr) ::hbase::pb::RevokeResponse();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::RevokeResponse::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_RevokeResponse_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_RevokeResponse_AccessControl_2eproto}, {}};

static void InitDefaultsscc_info_TablePermission_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_TablePermission_default_instance_;
    new (ptr) ::hbase::pb::TablePermission();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::TablePermission::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_TablePermission_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_TablePermission_AccessControl_2eproto}, {
      &scc_info_TableName_HBase_2eproto.base,}};

static void InitDefaultsscc_info_UserPermission_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_UserPermission_default_instance_;
    new (ptr) ::hbase::pb::UserPermission();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::UserPermission::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UserPermission_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UserPermission_AccessControl_2eproto}, {
      &scc_info_Permission_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_UsersAndPermissions_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_UsersAndPermissions_default_instance_;
    new (ptr) ::hbase::pb::UsersAndPermissions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::UsersAndPermissions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsersAndPermissions_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsersAndPermissions_AccessControl_2eproto}, {
      &scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto.base,}};

static void InitDefaultsscc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_UsersAndPermissions_UserPermissions_default_instance_;
    new (ptr) ::hbase::pb::UsersAndPermissions_UserPermissions();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::UsersAndPermissions_UserPermissions::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto}, {
      &scc_info_Permission_AccessControl_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_AccessControl_2eproto[17];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_AccessControl_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_AccessControl_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_AccessControl_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, type_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, global_permission_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, namespace_permission_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Permission, table_permission_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, table_name_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, family_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, qualifier_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TablePermission, action_),
  2,
  0,
  1,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::NamespacePermission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::NamespacePermission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::NamespacePermission, namespace_name_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::NamespacePermission, action_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GlobalPermission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GlobalPermission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GlobalPermission, action_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UserPermission, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UserPermission, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UserPermission, user_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UserPermission, permission_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions_UserPermissions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions_UserPermissions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions_UserPermissions, user_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions_UserPermissions, permissions_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::UsersAndPermissions, user_permissions_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantRequest, user_permission_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantRequest, merge_existing_permissions_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GrantResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::RevokeRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::RevokeRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::RevokeRequest, user_permission_),
  0,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::RevokeResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::RevokeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, type_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, table_name_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, namespace_name_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, column_family_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, column_qualifier_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsRequest, user_name_),
  5,
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::GetUserPermissionsResponse, user_permission_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::CheckPermissionsRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::CheckPermissionsRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::CheckPermissionsRequest, permission_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::CheckPermissionsResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::CheckPermissionsResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionRequest, table_permission_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionRequest, user_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::HasPermissionResponse, has_permission_),
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::hbase::pb::Permission)},
  { 13, 22, sizeof(::hbase::pb::TablePermission)},
  { 26, 33, sizeof(::hbase::pb::NamespacePermission)},
  { 35, 41, sizeof(::hbase::pb::GlobalPermission)},
  { 42, 49, sizeof(::hbase::pb::UserPermission)},
  { 51, 58, sizeof(::hbase::pb::UsersAndPermissions_UserPermissions)},
  { 60, 66, sizeof(::hbase::pb::UsersAndPermissions)},
  { 67, 74, sizeof(::hbase::pb::GrantRequest)},
  { 76, 81, sizeof(::hbase::pb::GrantResponse)},
  { 81, 87, sizeof(::hbase::pb::RevokeRequest)},
  { 88, 93, sizeof(::hbase::pb::RevokeResponse)},
  { 93, 104, sizeof(::hbase::pb::GetUserPermissionsRequest)},
  { 110, 116, sizeof(::hbase::pb::GetUserPermissionsResponse)},
  { 117, 123, sizeof(::hbase::pb::CheckPermissionsRequest)},
  { 124, 129, sizeof(::hbase::pb::CheckPermissionsResponse)},
  { 129, 136, sizeof(::hbase::pb::HasPermissionRequest)},
  { 138, 144, sizeof(::hbase::pb::HasPermissionResponse)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_Permission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_TablePermission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_NamespacePermission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_GlobalPermission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_UserPermission_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_UsersAndPermissions_UserPermissions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_UsersAndPermissions_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_GrantRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_GrantResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_RevokeRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_RevokeResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_GetUserPermissionsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_GetUserPermissionsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_CheckPermissionsRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_CheckPermissionsResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_HasPermissionRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_HasPermissionResponse_default_instance_),
};

const char descriptor_table_protodef_AccessControl_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\023AccessControl.proto\022\010hbase.pb\032\013HBase.p"
  "roto\"\314\002\n\nPermission\022\'\n\004type\030\001 \002(\0162\031.hbas"
  "e.pb.Permission.Type\0225\n\021global_permissio"
  "n\030\002 \001(\0132\032.hbase.pb.GlobalPermission\022;\n\024n"
  "amespace_permission\030\003 \001(\0132\035.hbase.pb.Nam"
  "espacePermission\0223\n\020table_permission\030\004 \001"
  "(\0132\031.hbase.pb.TablePermission\">\n\006Action\022"
  "\010\n\004READ\020\000\022\t\n\005WRITE\020\001\022\010\n\004EXEC\020\002\022\n\n\006CREATE"
  "\020\003\022\t\n\005ADMIN\020\004\",\n\004Type\022\n\n\006Global\020\001\022\r\n\tNam"
  "espace\020\002\022\t\n\005Table\020\003\"\212\001\n\017TablePermission\022"
  "\'\n\ntable_name\030\001 \001(\0132\023.hbase.pb.TableName"
  "\022\016\n\006family\030\002 \001(\014\022\021\n\tqualifier\030\003 \001(\014\022+\n\006a"
  "ction\030\004 \003(\0162\033.hbase.pb.Permission.Action"
  "\"Z\n\023NamespacePermission\022\026\n\016namespace_nam"
  "e\030\001 \001(\014\022+\n\006action\030\002 \003(\0162\033.hbase.pb.Permi"
  "ssion.Action\"\?\n\020GlobalPermission\022+\n\006acti"
  "on\030\001 \003(\0162\033.hbase.pb.Permission.Action\"H\n"
  "\016UserPermission\022\014\n\004user\030\001 \002(\014\022(\n\npermiss"
  "ion\030\003 \002(\0132\024.hbase.pb.Permission\"\252\001\n\023User"
  "sAndPermissions\022G\n\020user_permissions\030\001 \003("
  "\0132-.hbase.pb.UsersAndPermissions.UserPer"
  "missions\032J\n\017UserPermissions\022\014\n\004user\030\001 \002("
  "\014\022)\n\013permissions\030\002 \003(\0132\024.hbase.pb.Permis"
  "sion\"l\n\014GrantRequest\0221\n\017user_permission\030"
  "\001 \002(\0132\030.hbase.pb.UserPermission\022)\n\032merge"
  "_existing_permissions\030\002 \001(\010:\005false\"\017\n\rGr"
  "antResponse\"B\n\rRevokeRequest\0221\n\017user_per"
  "mission\030\001 \002(\0132\030.hbase.pb.UserPermission\""
  "\020\n\016RevokeResponse\"\311\001\n\031GetUserPermissions"
  "Request\022\'\n\004type\030\001 \001(\0162\031.hbase.pb.Permiss"
  "ion.Type\022\'\n\ntable_name\030\002 \001(\0132\023.hbase.pb."
  "TableName\022\026\n\016namespace_name\030\003 \001(\014\022\025\n\rcol"
  "umn_family\030\004 \001(\014\022\030\n\020column_qualifier\030\005 \001"
  "(\014\022\021\n\tuser_name\030\006 \001(\014\"O\n\032GetUserPermissi"
  "onsResponse\0221\n\017user_permission\030\001 \003(\0132\030.h"
  "base.pb.UserPermission\"C\n\027CheckPermissio"
  "nsRequest\022(\n\npermission\030\001 \003(\0132\024.hbase.pb"
  ".Permission\"\032\n\030CheckPermissionsResponse\""
  "^\n\024HasPermissionRequest\0223\n\020table_permiss"
  "ion\030\001 \002(\0132\031.hbase.pb.TablePermission\022\021\n\t"
  "user_name\030\002 \002(\014\"/\n\025HasPermissionResponse"
  "\022\026\n\016has_permission\030\001 \001(\0102\233\003\n\024AccessContr"
  "olService\0228\n\005Grant\022\026.hbase.pb.GrantReque"
  "st\032\027.hbase.pb.GrantResponse\022;\n\006Revoke\022\027."
  "hbase.pb.RevokeRequest\032\030.hbase.pb.Revoke"
  "Response\022_\n\022GetUserPermissions\022#.hbase.p"
  "b.GetUserPermissionsRequest\032$.hbase.pb.G"
  "etUserPermissionsResponse\022Y\n\020CheckPermis"
  "sions\022!.hbase.pb.CheckPermissionsRequest"
  "\032\".hbase.pb.CheckPermissionsResponse\022P\n\r"
  "HasPermission\022\036.hbase.pb.HasPermissionRe"
  "quest\032\037.hbase.pb.HasPermissionResponseBI"
  "\n*org.apache.hadoop.hbase.protobuf.gener"
  "atedB\023AccessControlProtosH\001\210\001\001\240\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_AccessControl_2eproto_deps[1] = {
  &::descriptor_table_HBase_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_AccessControl_2eproto_sccs[17] = {
  &scc_info_CheckPermissionsRequest_AccessControl_2eproto.base,
  &scc_info_CheckPermissionsResponse_AccessControl_2eproto.base,
  &scc_info_GetUserPermissionsRequest_AccessControl_2eproto.base,
  &scc_info_GetUserPermissionsResponse_AccessControl_2eproto.base,
  &scc_info_GlobalPermission_AccessControl_2eproto.base,
  &scc_info_GrantRequest_AccessControl_2eproto.base,
  &scc_info_GrantResponse_AccessControl_2eproto.base,
  &scc_info_HasPermissionRequest_AccessControl_2eproto.base,
  &scc_info_HasPermissionResponse_AccessControl_2eproto.base,
  &scc_info_NamespacePermission_AccessControl_2eproto.base,
  &scc_info_Permission_AccessControl_2eproto.base,
  &scc_info_RevokeRequest_AccessControl_2eproto.base,
  &scc_info_RevokeResponse_AccessControl_2eproto.base,
  &scc_info_TablePermission_AccessControl_2eproto.base,
  &scc_info_UserPermission_AccessControl_2eproto.base,
  &scc_info_UsersAndPermissions_AccessControl_2eproto.base,
  &scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_AccessControl_2eproto_once;
static bool descriptor_table_AccessControl_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_AccessControl_2eproto = {
  &descriptor_table_AccessControl_2eproto_initialized, descriptor_table_protodef_AccessControl_2eproto, "AccessControl.proto", 2153,
  &descriptor_table_AccessControl_2eproto_once, descriptor_table_AccessControl_2eproto_sccs, descriptor_table_AccessControl_2eproto_deps, 17, 1,
  schemas, file_default_instances, TableStruct_AccessControl_2eproto::offsets,
  file_level_metadata_AccessControl_2eproto, 17, file_level_enum_descriptors_AccessControl_2eproto, file_level_service_descriptors_AccessControl_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_AccessControl_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_AccessControl_2eproto), true);
namespace hbase {
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_Action_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_AccessControl_2eproto);
  return file_level_enum_descriptors_AccessControl_2eproto[0];
}
bool Permission_Action_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Permission_Action Permission::READ;
constexpr Permission_Action Permission::WRITE;
constexpr Permission_Action Permission::EXEC;
constexpr Permission_Action Permission::CREATE;
constexpr Permission_Action Permission::ADMIN;
constexpr Permission_Action Permission::Action_MIN;
constexpr Permission_Action Permission::Action_MAX;
constexpr int Permission::Action_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_Type_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_AccessControl_2eproto);
  return file_level_enum_descriptors_AccessControl_2eproto[1];
}
bool Permission_Type_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Permission_Type Permission::Global;
constexpr Permission_Type Permission::Namespace;
constexpr Permission_Type Permission::Table;
constexpr Permission_Type Permission::Type_MIN;
constexpr Permission_Type Permission::Type_MAX;
constexpr int Permission::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Permission::InitAsDefaultInstance() {
  ::hbase::pb::_Permission_default_instance_._instance.get_mutable()->global_permission_ = const_cast< ::hbase::pb::GlobalPermission*>(
      ::hbase::pb::GlobalPermission::internal_default_instance());
  ::hbase::pb::_Permission_default_instance_._instance.get_mutable()->namespace_permission_ = const_cast< ::hbase::pb::NamespacePermission*>(
      ::hbase::pb::NamespacePermission::internal_default_instance());
  ::hbase::pb::_Permission_default_instance_._instance.get_mutable()->table_permission_ = const_cast< ::hbase::pb::TablePermission*>(
      ::hbase::pb::TablePermission::internal_default_instance());
}
class Permission::_Internal {
 public:
  using HasBits = decltype(std::declval<Permission>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::hbase::pb::GlobalPermission& global_permission(const Permission* msg);
  static void set_has_global_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::hbase::pb::NamespacePermission& namespace_permission(const Permission* msg);
  static void set_has_namespace_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hbase::pb::TablePermission& table_permission(const Permission* msg);
  static void set_has_table_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::hbase::pb::GlobalPermission&
Permission::_Internal::global_permission(const Permission* msg) {
  return *msg->global_permission_;
}
const ::hbase::pb::NamespacePermission&
Permission::_Internal::namespace_permission(const Permission* msg) {
  return *msg->namespace_permission_;
}
const ::hbase::pb::TablePermission&
Permission::_Internal::table_permission(const Permission* msg) {
  return *msg->table_permission_;
}
Permission::Permission()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.Permission)
}
Permission::Permission(const Permission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_global_permission()) {
    global_permission_ = new ::hbase::pb::GlobalPermission(*from.global_permission_);
  } else {
    global_permission_ = nullptr;
  }
  if (from.has_namespace_permission()) {
    namespace_permission_ = new ::hbase::pb::NamespacePermission(*from.namespace_permission_);
  } else {
    namespace_permission_ = nullptr;
  }
  if (from.has_table_permission()) {
    table_permission_ = new ::hbase::pb::TablePermission(*from.table_permission_);
  } else {
    table_permission_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.Permission)
}

void Permission::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Permission_AccessControl_2eproto.base);
  ::memset(&global_permission_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&table_permission_) -
      reinterpret_cast<char*>(&global_permission_)) + sizeof(table_permission_));
  type_ = 1;
}

Permission::~Permission() {
  // @@protoc_insertion_point(destructor:hbase.pb.Permission)
  SharedDtor();
}

void Permission::SharedDtor() {
  if (this != internal_default_instance()) delete global_permission_;
  if (this != internal_default_instance()) delete namespace_permission_;
  if (this != internal_default_instance()) delete table_permission_;
}

void Permission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Permission& Permission::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Permission_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void Permission::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.Permission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(global_permission_ != nullptr);
      global_permission_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(namespace_permission_ != nullptr);
      namespace_permission_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(table_permission_ != nullptr);
      table_permission_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Permission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .hbase.pb.Permission.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::Permission_Type_IsValid(val))) {
            set_type(static_cast<::hbase::pb::Permission_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.GlobalPermission global_permission = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_global_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.NamespacePermission namespace_permission = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_namespace_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TablePermission table_permission = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_table_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Permission::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.Permission)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.Permission.Type type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Type_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::Permission_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.GlobalPermission global_permission = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_global_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.NamespacePermission namespace_permission = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_namespace_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TablePermission table_permission = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_table_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.Permission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.Permission)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Permission::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.Permission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.Permission.Type type = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .hbase.pb.GlobalPermission global_permission = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::global_permission(this), output);
  }

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::namespace_permission(this), output);
  }

  // optional .hbase.pb.TablePermission table_permission = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, _Internal::table_permission(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.Permission)
}

::PROTOBUF_NAMESPACE_ID::uint8* Permission::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.Permission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.Permission.Type type = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .hbase.pb.GlobalPermission global_permission = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::global_permission(this), target);
  }

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::namespace_permission(this), target);
  }

  // optional .hbase.pb.TablePermission table_permission = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::table_permission(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.Permission)
  return target;
}

size_t Permission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.Permission)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hbase.pb.Permission.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .hbase.pb.GlobalPermission global_permission = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *global_permission_);
    }

    // optional .hbase.pb.NamespacePermission namespace_permission = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *namespace_permission_);
    }

    // optional .hbase.pb.TablePermission table_permission = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_permission_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Permission::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.Permission)
  GOOGLE_DCHECK_NE(&from, this);
  const Permission* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Permission>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.Permission)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.Permission)
    MergeFrom(*source);
  }
}

void Permission::MergeFrom(const Permission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.Permission)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_global_permission()->::hbase::pb::GlobalPermission::MergeFrom(from.global_permission());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_namespace_permission()->::hbase::pb::NamespacePermission::MergeFrom(from.namespace_permission());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_table_permission()->::hbase::pb::TablePermission::MergeFrom(from.table_permission());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Permission::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.Permission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Permission::CopyFrom(const Permission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.Permission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Permission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000008) != 0x00000008) return false;
  if (has_table_permission()) {
    if (!this->table_permission_->IsInitialized()) return false;
  }
  return true;
}

void Permission::InternalSwap(Permission* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(global_permission_, other->global_permission_);
  swap(namespace_permission_, other->namespace_permission_);
  swap(table_permission_, other->table_permission_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Permission::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void TablePermission::InitAsDefaultInstance() {
  ::hbase::pb::_TablePermission_default_instance_._instance.get_mutable()->table_name_ = const_cast< ::hbase::pb::TableName*>(
      ::hbase::pb::TableName::internal_default_instance());
}
class TablePermission::_Internal {
 public:
  using HasBits = decltype(std::declval<TablePermission>()._has_bits_);
  static const ::hbase::pb::TableName& table_name(const TablePermission* msg);
  static void set_has_table_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_family(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::hbase::pb::TableName&
TablePermission::_Internal::table_name(const TablePermission* msg) {
  return *msg->table_name_;
}
void TablePermission::clear_table_name() {
  if (table_name_ != nullptr) table_name_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
TablePermission::TablePermission()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.TablePermission)
}
TablePermission::TablePermission(const TablePermission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      action_(from.action_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  family_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_family()) {
    family_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.family_);
  }
  qualifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_qualifier()) {
    qualifier_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.qualifier_);
  }
  if (from.has_table_name()) {
    table_name_ = new ::hbase::pb::TableName(*from.table_name_);
  } else {
    table_name_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.TablePermission)
}

void TablePermission::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_TablePermission_AccessControl_2eproto.base);
  family_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  qualifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  table_name_ = nullptr;
}

TablePermission::~TablePermission() {
  // @@protoc_insertion_point(destructor:hbase.pb.TablePermission)
  SharedDtor();
}

void TablePermission::SharedDtor() {
  family_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  qualifier_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete table_name_;
}

void TablePermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TablePermission& TablePermission::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TablePermission_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void TablePermission::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.TablePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  action_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      family_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      qualifier_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(table_name_ != nullptr);
      table_name_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TablePermission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.TableName table_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_table_name(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes family = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_family(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes qualifier = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_qualifier(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .hbase.pb.Permission.Action action = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::hbase::pb::Permission_Action_IsValid(val))) {
              add_action(static_cast<::hbase::pb::Permission_Action>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 32);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_action(), ptr, ctx, ::hbase::pb::Permission_Action_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TablePermission::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.TablePermission)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.TableName table_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_table_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes family = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_family()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes qualifier = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_qualifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hbase.pb.Permission.Action action = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 4,
                 ::hbase::pb::Permission_Action_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_action())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.TablePermission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.TablePermission)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TablePermission::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.TablePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.TableName table_name = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::table_name(this), output);
  }

  // optional bytes family = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->family(), output);
  }

  // optional bytes qualifier = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->qualifier(), output);
  }

  // repeated .hbase.pb.Permission.Action action = 4;
  for (int i = 0, n = this->action_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->action(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.TablePermission)
}

::PROTOBUF_NAMESPACE_ID::uint8* TablePermission::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.TablePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.TableName table_name = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::table_name(this), target);
  }

  // optional bytes family = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->family(), target);
  }

  // optional bytes qualifier = 3;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->qualifier(), target);
  }

  // repeated .hbase.pb.Permission.Action action = 4;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    4, this->action_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.TablePermission)
  return target;
}

size_t TablePermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.TablePermission)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission.Action action = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->action_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->action(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes family = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->family());
    }

    // optional bytes qualifier = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->qualifier());
    }

    // optional .hbase.pb.TableName table_name = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_name_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TablePermission::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.TablePermission)
  GOOGLE_DCHECK_NE(&from, this);
  const TablePermission* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TablePermission>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.TablePermission)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.TablePermission)
    MergeFrom(*source);
  }
}

void TablePermission::MergeFrom(const TablePermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.TablePermission)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  action_.MergeFrom(from.action_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      family_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.family_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      qualifier_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.qualifier_);
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_table_name()->::hbase::pb::TableName::MergeFrom(from.table_name());
    }
  }
}

void TablePermission::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.TablePermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TablePermission::CopyFrom(const TablePermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.TablePermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TablePermission::IsInitialized() const {
  if (has_table_name()) {
    if (!this->table_name_->IsInitialized()) return false;
  }
  return true;
}

void TablePermission::InternalSwap(TablePermission* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  action_.InternalSwap(&other->action_);
  family_.Swap(&other->family_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  qualifier_.Swap(&other->qualifier_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(table_name_, other->table_name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TablePermission::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NamespacePermission::InitAsDefaultInstance() {
}
class NamespacePermission::_Internal {
 public:
  using HasBits = decltype(std::declval<NamespacePermission>()._has_bits_);
  static void set_has_namespace_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

NamespacePermission::NamespacePermission()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.NamespacePermission)
}
NamespacePermission::NamespacePermission(const NamespacePermission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      action_(from.action_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_name()) {
    namespace_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace_name_);
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.NamespacePermission)
}

void NamespacePermission::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NamespacePermission_AccessControl_2eproto.base);
  namespace_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

NamespacePermission::~NamespacePermission() {
  // @@protoc_insertion_point(destructor:hbase.pb.NamespacePermission)
  SharedDtor();
}

void NamespacePermission::SharedDtor() {
  namespace_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NamespacePermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NamespacePermission& NamespacePermission::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NamespacePermission_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void NamespacePermission::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.NamespacePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  action_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    namespace_name_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* NamespacePermission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bytes namespace_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_namespace_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .hbase.pb.Permission.Action action = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::hbase::pb::Permission_Action_IsValid(val))) {
              add_action(static_cast<::hbase::pb::Permission_Action>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 16);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_action(), ptr, ctx, ::hbase::pb::Permission_Action_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool NamespacePermission::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.NamespacePermission)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes namespace_name = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_namespace_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hbase.pb.Permission.Action action = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 2,
                 ::hbase::pb::Permission_Action_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_action())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.NamespacePermission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.NamespacePermission)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void NamespacePermission::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.NamespacePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes namespace_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->namespace_name(), output);
  }

  // repeated .hbase.pb.Permission.Action action = 2;
  for (int i = 0, n = this->action_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->action(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.NamespacePermission)
}

::PROTOBUF_NAMESPACE_ID::uint8* NamespacePermission::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.NamespacePermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes namespace_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->namespace_name(), target);
  }

  // repeated .hbase.pb.Permission.Action action = 2;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    2, this->action_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.NamespacePermission)
  return target;
}

size_t NamespacePermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.NamespacePermission)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission.Action action = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->action_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->action(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // optional bytes namespace_name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->namespace_name());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamespacePermission::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.NamespacePermission)
  GOOGLE_DCHECK_NE(&from, this);
  const NamespacePermission* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NamespacePermission>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.NamespacePermission)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.NamespacePermission)
    MergeFrom(*source);
  }
}

void NamespacePermission::MergeFrom(const NamespacePermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.NamespacePermission)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  action_.MergeFrom(from.action_);
  if (from.has_namespace_name()) {
    _has_bits_[0] |= 0x00000001u;
    namespace_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace_name_);
  }
}

void NamespacePermission::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.NamespacePermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NamespacePermission::CopyFrom(const NamespacePermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.NamespacePermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamespacePermission::IsInitialized() const {
  return true;
}

void NamespacePermission::InternalSwap(NamespacePermission* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  action_.InternalSwap(&other->action_);
  namespace_name_.Swap(&other->namespace_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata NamespacePermission::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GlobalPermission::InitAsDefaultInstance() {
}
class GlobalPermission::_Internal {
 public:
  using HasBits = decltype(std::declval<GlobalPermission>()._has_bits_);
};

GlobalPermission::GlobalPermission()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.GlobalPermission)
}
GlobalPermission::GlobalPermission(const GlobalPermission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      action_(from.action_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.GlobalPermission)
}

void GlobalPermission::SharedCtor() {
}

GlobalPermission::~GlobalPermission() {
  // @@protoc_insertion_point(destructor:hbase.pb.GlobalPermission)
  SharedDtor();
}

void GlobalPermission::SharedDtor() {
}

void GlobalPermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GlobalPermission& GlobalPermission::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GlobalPermission_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void GlobalPermission::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.GlobalPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  action_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GlobalPermission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .hbase.pb.Permission.Action action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::hbase::pb::Permission_Action_IsValid(val))) {
              add_action(static_cast<::hbase::pb::Permission_Action>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 8);
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser(mutable_action(), ptr, ctx, ::hbase::pb::Permission_Action_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GlobalPermission::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.GlobalPermission)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.Permission.Action action = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Action_IsValid(value)) {
            add_action(static_cast< ::hbase::pb::Permission_Action >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::hbase::pb::Permission_Action_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_action())));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.GlobalPermission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.GlobalPermission)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GlobalPermission::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.GlobalPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission.Action action = 1;
  for (int i = 0, n = this->action_size(); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->action(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.GlobalPermission)
}

::PROTOBUF_NAMESPACE_ID::uint8* GlobalPermission::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.GlobalPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission.Action action = 1;
  target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
    1, this->action_, target);

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.GlobalPermission)
  return target;
}

size_t GlobalPermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.GlobalPermission)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission.Action action = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->action_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->action(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GlobalPermission::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.GlobalPermission)
  GOOGLE_DCHECK_NE(&from, this);
  const GlobalPermission* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GlobalPermission>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.GlobalPermission)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.GlobalPermission)
    MergeFrom(*source);
  }
}

void GlobalPermission::MergeFrom(const GlobalPermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.GlobalPermission)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  action_.MergeFrom(from.action_);
}

void GlobalPermission::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.GlobalPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GlobalPermission::CopyFrom(const GlobalPermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.GlobalPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GlobalPermission::IsInitialized() const {
  return true;
}

void GlobalPermission::InternalSwap(GlobalPermission* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  action_.InternalSwap(&other->action_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GlobalPermission::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UserPermission::InitAsDefaultInstance() {
  ::hbase::pb::_UserPermission_default_instance_._instance.get_mutable()->permission_ = const_cast< ::hbase::pb::Permission*>(
      ::hbase::pb::Permission::internal_default_instance());
}
class UserPermission::_Internal {
 public:
  using HasBits = decltype(std::declval<UserPermission>()._has_bits_);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::hbase::pb::Permission& permission(const UserPermission* msg);
  static void set_has_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::hbase::pb::Permission&
UserPermission::_Internal::permission(const UserPermission* msg) {
  return *msg->permission_;
}
UserPermission::UserPermission()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.UserPermission)
}
UserPermission::UserPermission(const UserPermission& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user()) {
    user_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_);
  }
  if (from.has_permission()) {
    permission_ = new ::hbase::pb::Permission(*from.permission_);
  } else {
    permission_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.UserPermission)
}

void UserPermission::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UserPermission_AccessControl_2eproto.base);
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  permission_ = nullptr;
}

UserPermission::~UserPermission() {
  // @@protoc_insertion_point(destructor:hbase.pb.UserPermission)
  SharedDtor();
}

void UserPermission::SharedDtor() {
  user_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete permission_;
}

void UserPermission::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UserPermission& UserPermission::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UserPermission_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void UserPermission::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.UserPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(permission_ != nullptr);
      permission_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UserPermission::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_user(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .hbase.pb.Permission permission = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UserPermission::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.UserPermission)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes user = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .hbase.pb.Permission permission = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.UserPermission)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.UserPermission)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UserPermission::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.UserPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes user = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->user(), output);
  }

  // required .hbase.pb.Permission permission = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::permission(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.UserPermission)
}

::PROTOBUF_NAMESPACE_ID::uint8* UserPermission::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.UserPermission)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes user = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->user(), target);
  }

  // required .hbase.pb.Permission permission = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::permission(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.UserPermission)
  return target;
}

size_t UserPermission::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hbase.pb.UserPermission)
  size_t total_size = 0;

  if (has_user()) {
    // required bytes user = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->user());
  }

  if (has_permission()) {
    // required .hbase.pb.Permission permission = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *permission_);
  }

  return total_size;
}
size_t UserPermission::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.UserPermission)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes user = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->user());

    // required .hbase.pb.Permission permission = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *permission_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UserPermission::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.UserPermission)
  GOOGLE_DCHECK_NE(&from, this);
  const UserPermission* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UserPermission>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.UserPermission)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.UserPermission)
    MergeFrom(*source);
  }
}

void UserPermission::MergeFrom(const UserPermission& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.UserPermission)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      user_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_permission()->::hbase::pb::Permission::MergeFrom(from.permission());
    }
  }
}

void UserPermission::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.UserPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UserPermission::CopyFrom(const UserPermission& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.UserPermission)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserPermission::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_permission()) {
    if (!this->permission_->IsInitialized()) return false;
  }
  return true;
}

void UserPermission::InternalSwap(UserPermission* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_.Swap(&other->user_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(permission_, other->permission_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserPermission::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsersAndPermissions_UserPermissions::InitAsDefaultInstance() {
}
class UsersAndPermissions_UserPermissions::_Internal {
 public:
  using HasBits = decltype(std::declval<UsersAndPermissions_UserPermissions>()._has_bits_);
  static void set_has_user(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

UsersAndPermissions_UserPermissions::UsersAndPermissions_UserPermissions()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.UsersAndPermissions.UserPermissions)
}
UsersAndPermissions_UserPermissions::UsersAndPermissions_UserPermissions(const UsersAndPermissions_UserPermissions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permissions_(from.permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user()) {
    user_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_);
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.UsersAndPermissions.UserPermissions)
}

void UsersAndPermissions_UserPermissions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto.base);
  user_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

UsersAndPermissions_UserPermissions::~UsersAndPermissions_UserPermissions() {
  // @@protoc_insertion_point(destructor:hbase.pb.UsersAndPermissions.UserPermissions)
  SharedDtor();
}

void UsersAndPermissions_UserPermissions::SharedDtor() {
  user_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UsersAndPermissions_UserPermissions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsersAndPermissions_UserPermissions& UsersAndPermissions_UserPermissions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsersAndPermissions_UserPermissions_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void UsersAndPermissions_UserPermissions::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.UsersAndPermissions.UserPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permissions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    user_.ClearNonDefaultToEmptyNoArena();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsersAndPermissions_UserPermissions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required bytes user = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_user(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .hbase.pb.Permission permissions = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsersAndPermissions_UserPermissions::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.UsersAndPermissions.UserPermissions)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes user = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .hbase.pb.Permission permissions = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.UsersAndPermissions.UserPermissions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.UsersAndPermissions.UserPermissions)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsersAndPermissions_UserPermissions::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.UsersAndPermissions.UserPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes user = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->user(), output);
  }

  // repeated .hbase.pb.Permission permissions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->permissions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.UsersAndPermissions.UserPermissions)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsersAndPermissions_UserPermissions::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.UsersAndPermissions.UserPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes user = 1;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        1, this->user(), target);
  }

  // repeated .hbase.pb.Permission permissions = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->permissions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.UsersAndPermissions.UserPermissions)
  return target;
}

size_t UsersAndPermissions_UserPermissions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.UsersAndPermissions.UserPermissions)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required bytes user = 1;
  if (has_user()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->user());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission permissions = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permissions(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsersAndPermissions_UserPermissions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.UsersAndPermissions.UserPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  const UsersAndPermissions_UserPermissions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsersAndPermissions_UserPermissions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.UsersAndPermissions.UserPermissions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.UsersAndPermissions.UserPermissions)
    MergeFrom(*source);
  }
}

void UsersAndPermissions_UserPermissions::MergeFrom(const UsersAndPermissions_UserPermissions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.UsersAndPermissions.UserPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permissions_.MergeFrom(from.permissions_);
  if (from.has_user()) {
    _has_bits_[0] |= 0x00000001u;
    user_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_);
  }
}

void UsersAndPermissions_UserPermissions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.UsersAndPermissions.UserPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsersAndPermissions_UserPermissions::CopyFrom(const UsersAndPermissions_UserPermissions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.UsersAndPermissions.UserPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersAndPermissions_UserPermissions::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->permissions())) return false;
  return true;
}

void UsersAndPermissions_UserPermissions::InternalSwap(UsersAndPermissions_UserPermissions* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permissions_)->InternalSwap(CastToBase(&other->permissions_));
  user_.Swap(&other->user_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersAndPermissions_UserPermissions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void UsersAndPermissions::InitAsDefaultInstance() {
}
class UsersAndPermissions::_Internal {
 public:
  using HasBits = decltype(std::declval<UsersAndPermissions>()._has_bits_);
};

UsersAndPermissions::UsersAndPermissions()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.UsersAndPermissions)
}
UsersAndPermissions::UsersAndPermissions(const UsersAndPermissions& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_permissions_(from.user_permissions_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.UsersAndPermissions)
}

void UsersAndPermissions::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_UsersAndPermissions_AccessControl_2eproto.base);
}

UsersAndPermissions::~UsersAndPermissions() {
  // @@protoc_insertion_point(destructor:hbase.pb.UsersAndPermissions)
  SharedDtor();
}

void UsersAndPermissions::SharedDtor() {
}

void UsersAndPermissions::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const UsersAndPermissions& UsersAndPermissions::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_UsersAndPermissions_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void UsersAndPermissions::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.UsersAndPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_permissions_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* UsersAndPermissions::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_permissions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool UsersAndPermissions::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.UsersAndPermissions)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_permissions()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.UsersAndPermissions)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.UsersAndPermissions)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void UsersAndPermissions::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.UsersAndPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permissions_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->user_permissions(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.UsersAndPermissions)
}

::PROTOBUF_NAMESPACE_ID::uint8* UsersAndPermissions::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.UsersAndPermissions)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permissions_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->user_permissions(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.UsersAndPermissions)
  return target;
}

size_t UsersAndPermissions::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.UsersAndPermissions)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_permissions_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_permissions(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void UsersAndPermissions::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.UsersAndPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  const UsersAndPermissions* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<UsersAndPermissions>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.UsersAndPermissions)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.UsersAndPermissions)
    MergeFrom(*source);
  }
}

void UsersAndPermissions::MergeFrom(const UsersAndPermissions& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.UsersAndPermissions)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_permissions_.MergeFrom(from.user_permissions_);
}

void UsersAndPermissions::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.UsersAndPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UsersAndPermissions::CopyFrom(const UsersAndPermissions& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.UsersAndPermissions)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UsersAndPermissions::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->user_permissions())) return false;
  return true;
}

void UsersAndPermissions::InternalSwap(UsersAndPermissions* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_permissions_)->InternalSwap(CastToBase(&other->user_permissions_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UsersAndPermissions::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GrantRequest::InitAsDefaultInstance() {
  ::hbase::pb::_GrantRequest_default_instance_._instance.get_mutable()->user_permission_ = const_cast< ::hbase::pb::UserPermission*>(
      ::hbase::pb::UserPermission::internal_default_instance());
}
class GrantRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GrantRequest>()._has_bits_);
  static const ::hbase::pb::UserPermission& user_permission(const GrantRequest* msg);
  static void set_has_user_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_merge_existing_permissions(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::hbase::pb::UserPermission&
GrantRequest::_Internal::user_permission(const GrantRequest* msg) {
  return *msg->user_permission_;
}
GrantRequest::GrantRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.GrantRequest)
}
GrantRequest::GrantRequest(const GrantRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_user_permission()) {
    user_permission_ = new ::hbase::pb::UserPermission(*from.user_permission_);
  } else {
    user_permission_ = nullptr;
  }
  merge_existing_permissions_ = from.merge_existing_permissions_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.GrantRequest)
}

void GrantRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GrantRequest_AccessControl_2eproto.base);
  ::memset(&user_permission_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&merge_existing_permissions_) -
      reinterpret_cast<char*>(&user_permission_)) + sizeof(merge_existing_permissions_));
}

GrantRequest::~GrantRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.GrantRequest)
  SharedDtor();
}

void GrantRequest::SharedDtor() {
  if (this != internal_default_instance()) delete user_permission_;
}

void GrantRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GrantRequest& GrantRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GrantRequest_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void GrantRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.GrantRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(user_permission_ != nullptr);
    user_permission_->Clear();
  }
  merge_existing_permissions_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GrantRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_user_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bool merge_existing_permissions = 2 [default = false];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_merge_existing_permissions(&has_bits);
          merge_existing_permissions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GrantRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.GrantRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool merge_existing_permissions = 2 [default = false];
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_merge_existing_permissions(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &merge_existing_permissions_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.GrantRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.GrantRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GrantRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.GrantRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.UserPermission user_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::user_permission(this), output);
  }

  // optional bool merge_existing_permissions = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->merge_existing_permissions(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.GrantRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* GrantRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.GrantRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.UserPermission user_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::user_permission(this), target);
  }

  // optional bool merge_existing_permissions = 2 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->merge_existing_permissions(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.GrantRequest)
  return target;
}

size_t GrantRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.GrantRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_permission_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool merge_existing_permissions = 2 [default = false];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GrantRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.GrantRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const GrantRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GrantRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.GrantRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.GrantRequest)
    MergeFrom(*source);
  }
}

void GrantRequest::MergeFrom(const GrantRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.GrantRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_user_permission()->::hbase::pb::UserPermission::MergeFrom(from.user_permission());
    }
    if (cached_has_bits & 0x00000002u) {
      merge_existing_permissions_ = from.merge_existing_permissions_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GrantRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.GrantRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GrantRequest::CopyFrom(const GrantRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.GrantRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GrantRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_user_permission()) {
    if (!this->user_permission_->IsInitialized()) return false;
  }
  return true;
}

void GrantRequest::InternalSwap(GrantRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_permission_, other->user_permission_);
  swap(merge_existing_permissions_, other->merge_existing_permissions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GrantRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GrantResponse::InitAsDefaultInstance() {
}
class GrantResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GrantResponse>()._has_bits_);
};

GrantResponse::GrantResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.GrantResponse)
}
GrantResponse::GrantResponse(const GrantResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.GrantResponse)
}

void GrantResponse::SharedCtor() {
}

GrantResponse::~GrantResponse() {
  // @@protoc_insertion_point(destructor:hbase.pb.GrantResponse)
  SharedDtor();
}

void GrantResponse::SharedDtor() {
}

void GrantResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GrantResponse& GrantResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GrantResponse_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void GrantResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.GrantResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GrantResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GrantResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.GrantResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.GrantResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.GrantResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GrantResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.GrantResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.GrantResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* GrantResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.GrantResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.GrantResponse)
  return target;
}

size_t GrantResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.GrantResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GrantResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.GrantResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const GrantResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GrantResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.GrantResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.GrantResponse)
    MergeFrom(*source);
  }
}

void GrantResponse::MergeFrom(const GrantResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.GrantResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void GrantResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.GrantResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GrantResponse::CopyFrom(const GrantResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.GrantResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GrantResponse::IsInitialized() const {
  return true;
}

void GrantResponse::InternalSwap(GrantResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata GrantResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RevokeRequest::InitAsDefaultInstance() {
  ::hbase::pb::_RevokeRequest_default_instance_._instance.get_mutable()->user_permission_ = const_cast< ::hbase::pb::UserPermission*>(
      ::hbase::pb::UserPermission::internal_default_instance());
}
class RevokeRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<RevokeRequest>()._has_bits_);
  static const ::hbase::pb::UserPermission& user_permission(const RevokeRequest* msg);
  static void set_has_user_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hbase::pb::UserPermission&
RevokeRequest::_Internal::user_permission(const RevokeRequest* msg) {
  return *msg->user_permission_;
}
RevokeRequest::RevokeRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.RevokeRequest)
}
RevokeRequest::RevokeRequest(const RevokeRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_user_permission()) {
    user_permission_ = new ::hbase::pb::UserPermission(*from.user_permission_);
  } else {
    user_permission_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.RevokeRequest)
}

void RevokeRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_RevokeRequest_AccessControl_2eproto.base);
  user_permission_ = nullptr;
}

RevokeRequest::~RevokeRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.RevokeRequest)
  SharedDtor();
}

void RevokeRequest::SharedDtor() {
  if (this != internal_default_instance()) delete user_permission_;
}

void RevokeRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RevokeRequest& RevokeRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RevokeRequest_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void RevokeRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.RevokeRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(user_permission_ != nullptr);
    user_permission_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RevokeRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_user_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RevokeRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.RevokeRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_user_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.RevokeRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.RevokeRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RevokeRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.RevokeRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.UserPermission user_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::user_permission(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.RevokeRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* RevokeRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.RevokeRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.UserPermission user_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::user_permission(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.RevokeRequest)
  return target;
}

size_t RevokeRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.RevokeRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hbase.pb.UserPermission user_permission = 1;
  if (has_user_permission()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *user_permission_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RevokeRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.RevokeRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const RevokeRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RevokeRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.RevokeRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.RevokeRequest)
    MergeFrom(*source);
  }
}

void RevokeRequest::MergeFrom(const RevokeRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.RevokeRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_user_permission()) {
    mutable_user_permission()->::hbase::pb::UserPermission::MergeFrom(from.user_permission());
  }
}

void RevokeRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.RevokeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevokeRequest::CopyFrom(const RevokeRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.RevokeRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevokeRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (has_user_permission()) {
    if (!this->user_permission_->IsInitialized()) return false;
  }
  return true;
}

void RevokeRequest::InternalSwap(RevokeRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(user_permission_, other->user_permission_);
}

::PROTOBUF_NAMESPACE_ID::Metadata RevokeRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void RevokeResponse::InitAsDefaultInstance() {
}
class RevokeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<RevokeResponse>()._has_bits_);
};

RevokeResponse::RevokeResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.RevokeResponse)
}
RevokeResponse::RevokeResponse(const RevokeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.RevokeResponse)
}

void RevokeResponse::SharedCtor() {
}

RevokeResponse::~RevokeResponse() {
  // @@protoc_insertion_point(destructor:hbase.pb.RevokeResponse)
  SharedDtor();
}

void RevokeResponse::SharedDtor() {
}

void RevokeResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const RevokeResponse& RevokeResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_RevokeResponse_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void RevokeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.RevokeResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* RevokeResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool RevokeResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.RevokeResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.RevokeResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.RevokeResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void RevokeResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.RevokeResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.RevokeResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* RevokeResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.RevokeResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.RevokeResponse)
  return target;
}

size_t RevokeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.RevokeResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RevokeResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.RevokeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const RevokeResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<RevokeResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.RevokeResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.RevokeResponse)
    MergeFrom(*source);
  }
}

void RevokeResponse::MergeFrom(const RevokeResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.RevokeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void RevokeResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.RevokeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RevokeResponse::CopyFrom(const RevokeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.RevokeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RevokeResponse::IsInitialized() const {
  return true;
}

void RevokeResponse::InternalSwap(RevokeResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata RevokeResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetUserPermissionsRequest::InitAsDefaultInstance() {
  ::hbase::pb::_GetUserPermissionsRequest_default_instance_._instance.get_mutable()->table_name_ = const_cast< ::hbase::pb::TableName*>(
      ::hbase::pb::TableName::internal_default_instance());
}
class GetUserPermissionsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserPermissionsRequest>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::hbase::pb::TableName& table_name(const GetUserPermissionsRequest* msg);
  static void set_has_table_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_namespace_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_column_family(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_column_qualifier(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::hbase::pb::TableName&
GetUserPermissionsRequest::_Internal::table_name(const GetUserPermissionsRequest* msg) {
  return *msg->table_name_;
}
void GetUserPermissionsRequest::clear_table_name() {
  if (table_name_ != nullptr) table_name_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
GetUserPermissionsRequest::GetUserPermissionsRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.GetUserPermissionsRequest)
}
GetUserPermissionsRequest::GetUserPermissionsRequest(const GetUserPermissionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  namespace_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_namespace_name()) {
    namespace_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace_name_);
  }
  column_family_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_column_family()) {
    column_family_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.column_family_);
  }
  column_qualifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_column_qualifier()) {
    column_qualifier_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.column_qualifier_);
  }
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_name()) {
    user_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_name_);
  }
  if (from.has_table_name()) {
    table_name_ = new ::hbase::pb::TableName(*from.table_name_);
  } else {
    table_name_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.GetUserPermissionsRequest)
}

void GetUserPermissionsRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetUserPermissionsRequest_AccessControl_2eproto.base);
  namespace_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  column_family_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  column_qualifier_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  table_name_ = nullptr;
  type_ = 1;
}

GetUserPermissionsRequest::~GetUserPermissionsRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.GetUserPermissionsRequest)
  SharedDtor();
}

void GetUserPermissionsRequest::SharedDtor() {
  namespace_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  column_family_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  column_qualifier_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete table_name_;
}

void GetUserPermissionsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetUserPermissionsRequest& GetUserPermissionsRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetUserPermissionsRequest_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void GetUserPermissionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.GetUserPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      namespace_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      column_family_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000004u) {
      column_qualifier_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000008u) {
      user_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(table_name_ != nullptr);
      table_name_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GetUserPermissionsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.Permission.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::Permission_Type_IsValid(val))) {
            set_type(static_cast<::hbase::pb::Permission_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TableName table_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_table_name(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes namespace_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_namespace_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes column_family = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_column_family(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes column_qualifier = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_column_qualifier(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional bytes user_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_user_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GetUserPermissionsRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.GetUserPermissionsRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.Permission.Type type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::Permission_Type_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::Permission_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TableName table_name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_table_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes namespace_name = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_namespace_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes column_family = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_family()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes column_qualifier = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_column_qualifier()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bytes user_name = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.GetUserPermissionsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.GetUserPermissionsRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GetUserPermissionsRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.GetUserPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.Permission.Type type = 1;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .hbase.pb.TableName table_name = 2;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::table_name(this), output);
  }

  // optional bytes namespace_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->namespace_name(), output);
  }

  // optional bytes column_family = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->column_family(), output);
  }

  // optional bytes column_qualifier = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      5, this->column_qualifier(), output);
  }

  // optional bytes user_name = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->user_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.GetUserPermissionsRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* GetUserPermissionsRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.GetUserPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.Permission.Type type = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .hbase.pb.TableName table_name = 2;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::table_name(this), target);
  }

  // optional bytes namespace_name = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->namespace_name(), target);
  }

  // optional bytes column_family = 4;
  if (cached_has_bits & 0x00000002u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        4, this->column_family(), target);
  }

  // optional bytes column_qualifier = 5;
  if (cached_has_bits & 0x00000004u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        5, this->column_qualifier(), target);
  }

  // optional bytes user_name = 6;
  if (cached_has_bits & 0x00000008u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        6, this->user_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.GetUserPermissionsRequest)
  return target;
}

size_t GetUserPermissionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.GetUserPermissionsRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes namespace_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->namespace_name());
    }

    // optional bytes column_family = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->column_family());
    }

    // optional bytes column_qualifier = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->column_qualifier());
    }

    // optional bytes user_name = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->user_name());
    }

    // optional .hbase.pb.TableName table_name = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *table_name_);
    }

    // optional .hbase.pb.Permission.Type type = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserPermissionsRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.GetUserPermissionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const GetUserPermissionsRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetUserPermissionsRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.GetUserPermissionsRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.GetUserPermissionsRequest)
    MergeFrom(*source);
  }
}

void GetUserPermissionsRequest::MergeFrom(const GetUserPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.GetUserPermissionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      namespace_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.namespace_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      _has_bits_[0] |= 0x00000002u;
      column_family_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.column_family_);
    }
    if (cached_has_bits & 0x00000004u) {
      _has_bits_[0] |= 0x00000004u;
      column_qualifier_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.column_qualifier_);
    }
    if (cached_has_bits & 0x00000008u) {
      _has_bits_[0] |= 0x00000008u;
      user_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_table_name()->::hbase::pb::TableName::MergeFrom(from.table_name());
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void GetUserPermissionsRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.GetUserPermissionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUserPermissionsRequest::CopyFrom(const GetUserPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.GetUserPermissionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserPermissionsRequest::IsInitialized() const {
  if (has_table_name()) {
    if (!this->table_name_->IsInitialized()) return false;
  }
  return true;
}

void GetUserPermissionsRequest::InternalSwap(GetUserPermissionsRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  namespace_name_.Swap(&other->namespace_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  column_family_.Swap(&other->column_family_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  column_qualifier_.Swap(&other->column_qualifier_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  user_name_.Swap(&other->user_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(table_name_, other->table_name_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUserPermissionsRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void GetUserPermissionsResponse::InitAsDefaultInstance() {
}
class GetUserPermissionsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUserPermissionsResponse>()._has_bits_);
};

GetUserPermissionsResponse::GetUserPermissionsResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.GetUserPermissionsResponse)
}
GetUserPermissionsResponse::GetUserPermissionsResponse(const GetUserPermissionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      user_permission_(from.user_permission_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.GetUserPermissionsResponse)
}

void GetUserPermissionsResponse::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_GetUserPermissionsResponse_AccessControl_2eproto.base);
}

GetUserPermissionsResponse::~GetUserPermissionsResponse() {
  // @@protoc_insertion_point(destructor:hbase.pb.GetUserPermissionsResponse)
  SharedDtor();
}

void GetUserPermissionsResponse::SharedDtor() {
}

void GetUserPermissionsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const GetUserPermissionsResponse& GetUserPermissionsResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_GetUserPermissionsResponse_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void GetUserPermissionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.GetUserPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_permission_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* GetUserPermissionsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .hbase.pb.UserPermission user_permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_user_permission(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool GetUserPermissionsResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.GetUserPermissionsResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.UserPermission user_permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_user_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.GetUserPermissionsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.GetUserPermissionsResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void GetUserPermissionsResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.GetUserPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.UserPermission user_permission = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permission_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->user_permission(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.GetUserPermissionsResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* GetUserPermissionsResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.GetUserPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.UserPermission user_permission = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->user_permission_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->user_permission(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.GetUserPermissionsResponse)
  return target;
}

size_t GetUserPermissionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.GetUserPermissionsResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.UserPermission user_permission = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->user_permission_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->user_permission(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUserPermissionsResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.GetUserPermissionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const GetUserPermissionsResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<GetUserPermissionsResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.GetUserPermissionsResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.GetUserPermissionsResponse)
    MergeFrom(*source);
  }
}

void GetUserPermissionsResponse::MergeFrom(const GetUserPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.GetUserPermissionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  user_permission_.MergeFrom(from.user_permission_);
}

void GetUserPermissionsResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.GetUserPermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GetUserPermissionsResponse::CopyFrom(const GetUserPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.GetUserPermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUserPermissionsResponse::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->user_permission())) return false;
  return true;
}

void GetUserPermissionsResponse::InternalSwap(GetUserPermissionsResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&user_permission_)->InternalSwap(CastToBase(&other->user_permission_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GetUserPermissionsResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CheckPermissionsRequest::InitAsDefaultInstance() {
}
class CheckPermissionsRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckPermissionsRequest>()._has_bits_);
};

CheckPermissionsRequest::CheckPermissionsRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.CheckPermissionsRequest)
}
CheckPermissionsRequest::CheckPermissionsRequest(const CheckPermissionsRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      permission_(from.permission_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.CheckPermissionsRequest)
}

void CheckPermissionsRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_CheckPermissionsRequest_AccessControl_2eproto.base);
}

CheckPermissionsRequest::~CheckPermissionsRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.CheckPermissionsRequest)
  SharedDtor();
}

void CheckPermissionsRequest::SharedDtor() {
}

void CheckPermissionsRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckPermissionsRequest& CheckPermissionsRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CheckPermissionsRequest_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void CheckPermissionsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.CheckPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  permission_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CheckPermissionsRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .hbase.pb.Permission permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_permission(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CheckPermissionsRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.CheckPermissionsRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .hbase.pb.Permission permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.CheckPermissionsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.CheckPermissionsRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CheckPermissionsRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.CheckPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission permission = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->permission(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.CheckPermissionsRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckPermissionsRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.CheckPermissionsRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission permission = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->permission_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->permission(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.CheckPermissionsRequest)
  return target;
}

size_t CheckPermissionsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.CheckPermissionsRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .hbase.pb.Permission permission = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->permission_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->permission(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckPermissionsRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.CheckPermissionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckPermissionsRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckPermissionsRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.CheckPermissionsRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.CheckPermissionsRequest)
    MergeFrom(*source);
  }
}

void CheckPermissionsRequest::MergeFrom(const CheckPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.CheckPermissionsRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  permission_.MergeFrom(from.permission_);
}

void CheckPermissionsRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.CheckPermissionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckPermissionsRequest::CopyFrom(const CheckPermissionsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.CheckPermissionsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPermissionsRequest::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->permission())) return false;
  return true;
}

void CheckPermissionsRequest::InternalSwap(CheckPermissionsRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&permission_)->InternalSwap(CastToBase(&other->permission_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckPermissionsRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void CheckPermissionsResponse::InitAsDefaultInstance() {
}
class CheckPermissionsResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CheckPermissionsResponse>()._has_bits_);
};

CheckPermissionsResponse::CheckPermissionsResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.CheckPermissionsResponse)
}
CheckPermissionsResponse::CheckPermissionsResponse(const CheckPermissionsResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.CheckPermissionsResponse)
}

void CheckPermissionsResponse::SharedCtor() {
}

CheckPermissionsResponse::~CheckPermissionsResponse() {
  // @@protoc_insertion_point(destructor:hbase.pb.CheckPermissionsResponse)
  SharedDtor();
}

void CheckPermissionsResponse::SharedDtor() {
}

void CheckPermissionsResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const CheckPermissionsResponse& CheckPermissionsResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_CheckPermissionsResponse_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void CheckPermissionsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.CheckPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* CheckPermissionsResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool CheckPermissionsResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.CheckPermissionsResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.CheckPermissionsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.CheckPermissionsResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void CheckPermissionsResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.CheckPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.CheckPermissionsResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* CheckPermissionsResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.CheckPermissionsResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.CheckPermissionsResponse)
  return target;
}

size_t CheckPermissionsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.CheckPermissionsResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CheckPermissionsResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.CheckPermissionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const CheckPermissionsResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<CheckPermissionsResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.CheckPermissionsResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.CheckPermissionsResponse)
    MergeFrom(*source);
  }
}

void CheckPermissionsResponse::MergeFrom(const CheckPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.CheckPermissionsResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void CheckPermissionsResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.CheckPermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckPermissionsResponse::CopyFrom(const CheckPermissionsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.CheckPermissionsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckPermissionsResponse::IsInitialized() const {
  return true;
}

void CheckPermissionsResponse::InternalSwap(CheckPermissionsResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckPermissionsResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void HasPermissionRequest::InitAsDefaultInstance() {
  ::hbase::pb::_HasPermissionRequest_default_instance_._instance.get_mutable()->table_permission_ = const_cast< ::hbase::pb::TablePermission*>(
      ::hbase::pb::TablePermission::internal_default_instance());
}
class HasPermissionRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<HasPermissionRequest>()._has_bits_);
  static const ::hbase::pb::TablePermission& table_permission(const HasPermissionRequest* msg);
  static void set_has_table_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hbase::pb::TablePermission&
HasPermissionRequest::_Internal::table_permission(const HasPermissionRequest* msg) {
  return *msg->table_permission_;
}
HasPermissionRequest::HasPermissionRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.HasPermissionRequest)
}
HasPermissionRequest::HasPermissionRequest(const HasPermissionRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_user_name()) {
    user_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_name_);
  }
  if (from.has_table_permission()) {
    table_permission_ = new ::hbase::pb::TablePermission(*from.table_permission_);
  } else {
    table_permission_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.HasPermissionRequest)
}

void HasPermissionRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_HasPermissionRequest_AccessControl_2eproto.base);
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  table_permission_ = nullptr;
}

HasPermissionRequest::~HasPermissionRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.HasPermissionRequest)
  SharedDtor();
}

void HasPermissionRequest::SharedDtor() {
  user_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete table_permission_;
}

void HasPermissionRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HasPermissionRequest& HasPermissionRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HasPermissionRequest_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void HasPermissionRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.HasPermissionRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      user_name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(table_permission_ != nullptr);
      table_permission_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* HasPermissionRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .hbase.pb.TablePermission table_permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_table_permission(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes user_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_user_name(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool HasPermissionRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.HasPermissionRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.TablePermission table_permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_table_permission()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes user_name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_user_name()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.HasPermissionRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.HasPermissionRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void HasPermissionRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.HasPermissionRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.TablePermission table_permission = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::table_permission(this), output);
  }

  // required bytes user_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->user_name(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.HasPermissionRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* HasPermissionRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.HasPermissionRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.TablePermission table_permission = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::table_permission(this), target);
  }

  // required bytes user_name = 2;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        2, this->user_name(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.HasPermissionRequest)
  return target;
}

size_t HasPermissionRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:hbase.pb.HasPermissionRequest)
  size_t total_size = 0;

  if (has_user_name()) {
    // required bytes user_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->user_name());
  }

  if (has_table_permission()) {
    // required .hbase.pb.TablePermission table_permission = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_permission_);
  }

  return total_size;
}
size_t HasPermissionRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.HasPermissionRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required bytes user_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->user_name());

    // required .hbase.pb.TablePermission table_permission = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *table_permission_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HasPermissionRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.HasPermissionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const HasPermissionRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HasPermissionRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.HasPermissionRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.HasPermissionRequest)
    MergeFrom(*source);
  }
}

void HasPermissionRequest::MergeFrom(const HasPermissionRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.HasPermissionRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      user_name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.user_name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_table_permission()->::hbase::pb::TablePermission::MergeFrom(from.table_permission());
    }
  }
}

void HasPermissionRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.HasPermissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HasPermissionRequest::CopyFrom(const HasPermissionRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.HasPermissionRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HasPermissionRequest::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_table_permission()) {
    if (!this->table_permission_->IsInitialized()) return false;
  }
  return true;
}

void HasPermissionRequest::InternalSwap(HasPermissionRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_name_.Swap(&other->user_name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(table_permission_, other->table_permission_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HasPermissionRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void HasPermissionResponse::InitAsDefaultInstance() {
}
class HasPermissionResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<HasPermissionResponse>()._has_bits_);
  static void set_has_has_permission(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

HasPermissionResponse::HasPermissionResponse()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.HasPermissionResponse)
}
HasPermissionResponse::HasPermissionResponse(const HasPermissionResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  has_permission_ = from.has_permission_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.HasPermissionResponse)
}

void HasPermissionResponse::SharedCtor() {
  has_permission_ = false;
}

HasPermissionResponse::~HasPermissionResponse() {
  // @@protoc_insertion_point(destructor:hbase.pb.HasPermissionResponse)
  SharedDtor();
}

void HasPermissionResponse::SharedDtor() {
}

void HasPermissionResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const HasPermissionResponse& HasPermissionResponse::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_HasPermissionResponse_AccessControl_2eproto.base);
  return *internal_default_instance();
}


void HasPermissionResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.HasPermissionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  has_permission_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* HasPermissionResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool has_permission = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_has_permission(&has_bits);
          has_permission_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool HasPermissionResponse::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.HasPermissionResponse)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool has_permission = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_has_permission(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_permission_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.HasPermissionResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.HasPermissionResponse)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void HasPermissionResponse::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.HasPermissionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool has_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->has_permission(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.HasPermissionResponse)
}

::PROTOBUF_NAMESPACE_ID::uint8* HasPermissionResponse::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.HasPermissionResponse)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool has_permission = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->has_permission(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.HasPermissionResponse)
  return target;
}

size_t HasPermissionResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.HasPermissionResponse)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool has_permission = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HasPermissionResponse::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.HasPermissionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  const HasPermissionResponse* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<HasPermissionResponse>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.HasPermissionResponse)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.HasPermissionResponse)
    MergeFrom(*source);
  }
}

void HasPermissionResponse::MergeFrom(const HasPermissionResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.HasPermissionResponse)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_has_permission()) {
    set_has_permission(from.has_permission());
  }
}

void HasPermissionResponse::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.HasPermissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HasPermissionResponse::CopyFrom(const HasPermissionResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.HasPermissionResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HasPermissionResponse::IsInitialized() const {
  return true;
}

void HasPermissionResponse::InternalSwap(HasPermissionResponse* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(has_permission_, other->has_permission_);
}

::PROTOBUF_NAMESPACE_ID::Metadata HasPermissionResponse::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::hbase::pb::Permission* Arena::CreateMaybeMessage< ::hbase::pb::Permission >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::Permission >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::TablePermission* Arena::CreateMaybeMessage< ::hbase::pb::TablePermission >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::TablePermission >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::NamespacePermission* Arena::CreateMaybeMessage< ::hbase::pb::NamespacePermission >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::NamespacePermission >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::GlobalPermission* Arena::CreateMaybeMessage< ::hbase::pb::GlobalPermission >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::GlobalPermission >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::UserPermission* Arena::CreateMaybeMessage< ::hbase::pb::UserPermission >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::UserPermission >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::UsersAndPermissions_UserPermissions* Arena::CreateMaybeMessage< ::hbase::pb::UsersAndPermissions_UserPermissions >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::UsersAndPermissions_UserPermissions >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::UsersAndPermissions* Arena::CreateMaybeMessage< ::hbase::pb::UsersAndPermissions >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::UsersAndPermissions >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::GrantRequest* Arena::CreateMaybeMessage< ::hbase::pb::GrantRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::GrantRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::GrantResponse* Arena::CreateMaybeMessage< ::hbase::pb::GrantResponse >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::GrantResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::RevokeRequest* Arena::CreateMaybeMessage< ::hbase::pb::RevokeRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::RevokeRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::RevokeResponse* Arena::CreateMaybeMessage< ::hbase::pb::RevokeResponse >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::RevokeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::GetUserPermissionsRequest* Arena::CreateMaybeMessage< ::hbase::pb::GetUserPermissionsRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::GetUserPermissionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::GetUserPermissionsResponse* Arena::CreateMaybeMessage< ::hbase::pb::GetUserPermissionsResponse >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::GetUserPermissionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::CheckPermissionsRequest* Arena::CreateMaybeMessage< ::hbase::pb::CheckPermissionsRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::CheckPermissionsRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::CheckPermissionsResponse* Arena::CreateMaybeMessage< ::hbase::pb::CheckPermissionsResponse >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::CheckPermissionsResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::HasPermissionRequest* Arena::CreateMaybeMessage< ::hbase::pb::HasPermissionRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::HasPermissionRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::HasPermissionResponse* Arena::CreateMaybeMessage< ::hbase::pb::HasPermissionResponse >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::HasPermissionResponse >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
