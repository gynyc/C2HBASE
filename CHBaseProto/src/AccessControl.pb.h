// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AccessControl.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_AccessControl_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_AccessControl_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_AccessControl_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_AccessControl_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_AccessControl_2eproto;
namespace hbase {
namespace pb {
class CheckPermissionsRequest;
class CheckPermissionsRequestDefaultTypeInternal;
extern CheckPermissionsRequestDefaultTypeInternal _CheckPermissionsRequest_default_instance_;
class CheckPermissionsResponse;
class CheckPermissionsResponseDefaultTypeInternal;
extern CheckPermissionsResponseDefaultTypeInternal _CheckPermissionsResponse_default_instance_;
class GetUserPermissionsRequest;
class GetUserPermissionsRequestDefaultTypeInternal;
extern GetUserPermissionsRequestDefaultTypeInternal _GetUserPermissionsRequest_default_instance_;
class GetUserPermissionsResponse;
class GetUserPermissionsResponseDefaultTypeInternal;
extern GetUserPermissionsResponseDefaultTypeInternal _GetUserPermissionsResponse_default_instance_;
class GlobalPermission;
class GlobalPermissionDefaultTypeInternal;
extern GlobalPermissionDefaultTypeInternal _GlobalPermission_default_instance_;
class GrantRequest;
class GrantRequestDefaultTypeInternal;
extern GrantRequestDefaultTypeInternal _GrantRequest_default_instance_;
class GrantResponse;
class GrantResponseDefaultTypeInternal;
extern GrantResponseDefaultTypeInternal _GrantResponse_default_instance_;
class HasPermissionRequest;
class HasPermissionRequestDefaultTypeInternal;
extern HasPermissionRequestDefaultTypeInternal _HasPermissionRequest_default_instance_;
class HasPermissionResponse;
class HasPermissionResponseDefaultTypeInternal;
extern HasPermissionResponseDefaultTypeInternal _HasPermissionResponse_default_instance_;
class NamespacePermission;
class NamespacePermissionDefaultTypeInternal;
extern NamespacePermissionDefaultTypeInternal _NamespacePermission_default_instance_;
class Permission;
class PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class RevokeRequest;
class RevokeRequestDefaultTypeInternal;
extern RevokeRequestDefaultTypeInternal _RevokeRequest_default_instance_;
class RevokeResponse;
class RevokeResponseDefaultTypeInternal;
extern RevokeResponseDefaultTypeInternal _RevokeResponse_default_instance_;
class TablePermission;
class TablePermissionDefaultTypeInternal;
extern TablePermissionDefaultTypeInternal _TablePermission_default_instance_;
class UserPermission;
class UserPermissionDefaultTypeInternal;
extern UserPermissionDefaultTypeInternal _UserPermission_default_instance_;
class UsersAndPermissions;
class UsersAndPermissionsDefaultTypeInternal;
extern UsersAndPermissionsDefaultTypeInternal _UsersAndPermissions_default_instance_;
class UsersAndPermissions_UserPermissions;
class UsersAndPermissions_UserPermissionsDefaultTypeInternal;
extern UsersAndPermissions_UserPermissionsDefaultTypeInternal _UsersAndPermissions_UserPermissions_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::CheckPermissionsRequest* Arena::CreateMaybeMessage<::hbase::pb::CheckPermissionsRequest>(Arena*);
template<> ::hbase::pb::CheckPermissionsResponse* Arena::CreateMaybeMessage<::hbase::pb::CheckPermissionsResponse>(Arena*);
template<> ::hbase::pb::GetUserPermissionsRequest* Arena::CreateMaybeMessage<::hbase::pb::GetUserPermissionsRequest>(Arena*);
template<> ::hbase::pb::GetUserPermissionsResponse* Arena::CreateMaybeMessage<::hbase::pb::GetUserPermissionsResponse>(Arena*);
template<> ::hbase::pb::GlobalPermission* Arena::CreateMaybeMessage<::hbase::pb::GlobalPermission>(Arena*);
template<> ::hbase::pb::GrantRequest* Arena::CreateMaybeMessage<::hbase::pb::GrantRequest>(Arena*);
template<> ::hbase::pb::GrantResponse* Arena::CreateMaybeMessage<::hbase::pb::GrantResponse>(Arena*);
template<> ::hbase::pb::HasPermissionRequest* Arena::CreateMaybeMessage<::hbase::pb::HasPermissionRequest>(Arena*);
template<> ::hbase::pb::HasPermissionResponse* Arena::CreateMaybeMessage<::hbase::pb::HasPermissionResponse>(Arena*);
template<> ::hbase::pb::NamespacePermission* Arena::CreateMaybeMessage<::hbase::pb::NamespacePermission>(Arena*);
template<> ::hbase::pb::Permission* Arena::CreateMaybeMessage<::hbase::pb::Permission>(Arena*);
template<> ::hbase::pb::RevokeRequest* Arena::CreateMaybeMessage<::hbase::pb::RevokeRequest>(Arena*);
template<> ::hbase::pb::RevokeResponse* Arena::CreateMaybeMessage<::hbase::pb::RevokeResponse>(Arena*);
template<> ::hbase::pb::TablePermission* Arena::CreateMaybeMessage<::hbase::pb::TablePermission>(Arena*);
template<> ::hbase::pb::UserPermission* Arena::CreateMaybeMessage<::hbase::pb::UserPermission>(Arena*);
template<> ::hbase::pb::UsersAndPermissions* Arena::CreateMaybeMessage<::hbase::pb::UsersAndPermissions>(Arena*);
template<> ::hbase::pb::UsersAndPermissions_UserPermissions* Arena::CreateMaybeMessage<::hbase::pb::UsersAndPermissions_UserPermissions>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum Permission_Action : int {
  Permission_Action_READ = 0,
  Permission_Action_WRITE = 1,
  Permission_Action_EXEC = 2,
  Permission_Action_CREATE = 3,
  Permission_Action_ADMIN = 4
};
bool Permission_Action_IsValid(int value);
constexpr Permission_Action Permission_Action_Action_MIN = Permission_Action_READ;
constexpr Permission_Action Permission_Action_Action_MAX = Permission_Action_ADMIN;
constexpr int Permission_Action_Action_ARRAYSIZE = Permission_Action_Action_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_Action_descriptor();
template<typename T>
inline const std::string& Permission_Action_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_Action>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_Action_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_Action_descriptor(), enum_t_value);
}
inline bool Permission_Action_Parse(
    const std::string& name, Permission_Action* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_Action>(
    Permission_Action_descriptor(), name, value);
}
enum Permission_Type : int {
  Permission_Type_Global = 1,
  Permission_Type_Namespace = 2,
  Permission_Type_Table = 3
};
bool Permission_Type_IsValid(int value);
constexpr Permission_Type Permission_Type_Type_MIN = Permission_Type_Global;
constexpr Permission_Type Permission_Type_Type_MAX = Permission_Type_Table;
constexpr int Permission_Type_Type_ARRAYSIZE = Permission_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Permission_Type_descriptor();
template<typename T>
inline const std::string& Permission_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Permission_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Permission_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Permission_Type_descriptor(), enum_t_value);
}
inline bool Permission_Type_Parse(
    const std::string& name, Permission_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Permission_Type>(
    Permission_Type_descriptor(), name, value);
}
// ===================================================================

class Permission :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Permission) */ {
 public:
  Permission();
  virtual ~Permission();

  Permission(const Permission& from);
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  inline Permission& operator=(Permission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Permission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }
  inline void Swap(Permission* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Permission* New() const final {
    return CreateMaybeMessage<Permission>(nullptr);
  }

  Permission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Permission& from);
  void MergeFrom(const Permission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Permission";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Permission_Action Action;
  static constexpr Action READ =
    Permission_Action_READ;
  static constexpr Action WRITE =
    Permission_Action_WRITE;
  static constexpr Action EXEC =
    Permission_Action_EXEC;
  static constexpr Action CREATE =
    Permission_Action_CREATE;
  static constexpr Action ADMIN =
    Permission_Action_ADMIN;
  static inline bool Action_IsValid(int value) {
    return Permission_Action_IsValid(value);
  }
  static constexpr Action Action_MIN =
    Permission_Action_Action_MIN;
  static constexpr Action Action_MAX =
    Permission_Action_Action_MAX;
  static constexpr int Action_ARRAYSIZE =
    Permission_Action_Action_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Action_descriptor() {
    return Permission_Action_descriptor();
  }
  template<typename T>
  static inline const std::string& Action_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Action>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Action_Name.");
    return Permission_Action_Name(enum_t_value);
  }
  static inline bool Action_Parse(const std::string& name,
      Action* value) {
    return Permission_Action_Parse(name, value);
  }

  typedef Permission_Type Type;
  static constexpr Type Global =
    Permission_Type_Global;
  static constexpr Type Namespace =
    Permission_Type_Namespace;
  static constexpr Type Table =
    Permission_Type_Table;
  static inline bool Type_IsValid(int value) {
    return Permission_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Permission_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Permission_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Permission_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Permission_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Permission_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Permission_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kGlobalPermissionFieldNumber = 2,
    kNamespacePermissionFieldNumber = 3,
    kTablePermissionFieldNumber = 4,
    kTypeFieldNumber = 1,
  };
  // optional .hbase.pb.GlobalPermission global_permission = 2;
  bool has_global_permission() const;
  void clear_global_permission();
  const ::hbase::pb::GlobalPermission& global_permission() const;
  ::hbase::pb::GlobalPermission* release_global_permission();
  ::hbase::pb::GlobalPermission* mutable_global_permission();
  void set_allocated_global_permission(::hbase::pb::GlobalPermission* global_permission);

  // optional .hbase.pb.NamespacePermission namespace_permission = 3;
  bool has_namespace_permission() const;
  void clear_namespace_permission();
  const ::hbase::pb::NamespacePermission& namespace_permission() const;
  ::hbase::pb::NamespacePermission* release_namespace_permission();
  ::hbase::pb::NamespacePermission* mutable_namespace_permission();
  void set_allocated_namespace_permission(::hbase::pb::NamespacePermission* namespace_permission);

  // optional .hbase.pb.TablePermission table_permission = 4;
  bool has_table_permission() const;
  void clear_table_permission();
  const ::hbase::pb::TablePermission& table_permission() const;
  ::hbase::pb::TablePermission* release_table_permission();
  ::hbase::pb::TablePermission* mutable_table_permission();
  void set_allocated_table_permission(::hbase::pb::TablePermission* table_permission);

  // required .hbase.pb.Permission.Type type = 1;
  bool has_type() const;
  void clear_type();
  ::hbase::pb::Permission_Type type() const;
  void set_type(::hbase::pb::Permission_Type value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Permission)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::GlobalPermission* global_permission_;
  ::hbase::pb::NamespacePermission* namespace_permission_;
  ::hbase::pb::TablePermission* table_permission_;
  int type_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class TablePermission :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TablePermission) */ {
 public:
  TablePermission();
  virtual ~TablePermission();

  TablePermission(const TablePermission& from);
  TablePermission(TablePermission&& from) noexcept
    : TablePermission() {
    *this = ::std::move(from);
  }

  inline TablePermission& operator=(const TablePermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline TablePermission& operator=(TablePermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TablePermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TablePermission* internal_default_instance() {
    return reinterpret_cast<const TablePermission*>(
               &_TablePermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TablePermission& a, TablePermission& b) {
    a.Swap(&b);
  }
  inline void Swap(TablePermission* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TablePermission* New() const final {
    return CreateMaybeMessage<TablePermission>(nullptr);
  }

  TablePermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TablePermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TablePermission& from);
  void MergeFrom(const TablePermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TablePermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TablePermission";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 4,
    kFamilyFieldNumber = 2,
    kQualifierFieldNumber = 3,
    kTableNameFieldNumber = 1,
  };
  // repeated .hbase.pb.Permission.Action action = 4;
  int action_size() const;
  void clear_action();
  ::hbase::pb::Permission_Action action(int index) const;
  void set_action(int index, ::hbase::pb::Permission_Action value);
  void add_action(::hbase::pb::Permission_Action value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_action();

  // optional bytes family = 2;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // optional bytes qualifier = 3;
  bool has_qualifier() const;
  void clear_qualifier();
  const std::string& qualifier() const;
  void set_qualifier(const std::string& value);
  void set_qualifier(std::string&& value);
  void set_qualifier(const char* value);
  void set_qualifier(const void* value, size_t size);
  std::string* mutable_qualifier();
  std::string* release_qualifier();
  void set_allocated_qualifier(std::string* qualifier);

  // optional .hbase.pb.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.TablePermission)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualifier_;
  ::hbase::pb::TableName* table_name_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class NamespacePermission :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.NamespacePermission) */ {
 public:
  NamespacePermission();
  virtual ~NamespacePermission();

  NamespacePermission(const NamespacePermission& from);
  NamespacePermission(NamespacePermission&& from) noexcept
    : NamespacePermission() {
    *this = ::std::move(from);
  }

  inline NamespacePermission& operator=(const NamespacePermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespacePermission& operator=(NamespacePermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamespacePermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamespacePermission* internal_default_instance() {
    return reinterpret_cast<const NamespacePermission*>(
               &_NamespacePermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NamespacePermission& a, NamespacePermission& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespacePermission* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamespacePermission* New() const final {
    return CreateMaybeMessage<NamespacePermission>(nullptr);
  }

  NamespacePermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamespacePermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamespacePermission& from);
  void MergeFrom(const NamespacePermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamespacePermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.NamespacePermission";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 2,
    kNamespaceNameFieldNumber = 1,
  };
  // repeated .hbase.pb.Permission.Action action = 2;
  int action_size() const;
  void clear_action();
  ::hbase::pb::Permission_Action action(int index) const;
  void set_action(int index, ::hbase::pb::Permission_Action value);
  void add_action(::hbase::pb::Permission_Action value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_action();

  // optional bytes namespace_name = 1;
  bool has_namespace_name() const;
  void clear_namespace_name();
  const std::string& namespace_name() const;
  void set_namespace_name(const std::string& value);
  void set_namespace_name(std::string&& value);
  void set_namespace_name(const char* value);
  void set_namespace_name(const void* value, size_t size);
  std::string* mutable_namespace_name();
  std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.NamespacePermission)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> action_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class GlobalPermission :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GlobalPermission) */ {
 public:
  GlobalPermission();
  virtual ~GlobalPermission();

  GlobalPermission(const GlobalPermission& from);
  GlobalPermission(GlobalPermission&& from) noexcept
    : GlobalPermission() {
    *this = ::std::move(from);
  }

  inline GlobalPermission& operator=(const GlobalPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalPermission& operator=(GlobalPermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlobalPermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalPermission* internal_default_instance() {
    return reinterpret_cast<const GlobalPermission*>(
               &_GlobalPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GlobalPermission& a, GlobalPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalPermission* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlobalPermission* New() const final {
    return CreateMaybeMessage<GlobalPermission>(nullptr);
  }

  GlobalPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlobalPermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlobalPermission& from);
  void MergeFrom(const GlobalPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GlobalPermission";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 1,
  };
  // repeated .hbase.pb.Permission.Action action = 1;
  int action_size() const;
  void clear_action();
  ::hbase::pb::Permission_Action action(int index) const;
  void set_action(int index, ::hbase::pb::Permission_Action value);
  void add_action(::hbase::pb::Permission_Action value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& action() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_action();

  // @@protoc_insertion_point(class_scope:hbase.pb.GlobalPermission)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> action_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class UserPermission :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.UserPermission) */ {
 public:
  UserPermission();
  virtual ~UserPermission();

  UserPermission(const UserPermission& from);
  UserPermission(UserPermission&& from) noexcept
    : UserPermission() {
    *this = ::std::move(from);
  }

  inline UserPermission& operator=(const UserPermission& from) {
    CopyFrom(from);
    return *this;
  }
  inline UserPermission& operator=(UserPermission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UserPermission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserPermission* internal_default_instance() {
    return reinterpret_cast<const UserPermission*>(
               &_UserPermission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UserPermission& a, UserPermission& b) {
    a.Swap(&b);
  }
  inline void Swap(UserPermission* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UserPermission* New() const final {
    return CreateMaybeMessage<UserPermission>(nullptr);
  }

  UserPermission* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UserPermission>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UserPermission& from);
  void MergeFrom(const UserPermission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserPermission* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.UserPermission";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 1,
    kPermissionFieldNumber = 3,
  };
  // required bytes user = 1;
  bool has_user() const;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const void* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);

  // required .hbase.pb.Permission permission = 3;
  bool has_permission() const;
  void clear_permission();
  const ::hbase::pb::Permission& permission() const;
  ::hbase::pb::Permission* release_permission();
  ::hbase::pb::Permission* mutable_permission();
  void set_allocated_permission(::hbase::pb::Permission* permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.UserPermission)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::hbase::pb::Permission* permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class UsersAndPermissions_UserPermissions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.UsersAndPermissions.UserPermissions) */ {
 public:
  UsersAndPermissions_UserPermissions();
  virtual ~UsersAndPermissions_UserPermissions();

  UsersAndPermissions_UserPermissions(const UsersAndPermissions_UserPermissions& from);
  UsersAndPermissions_UserPermissions(UsersAndPermissions_UserPermissions&& from) noexcept
    : UsersAndPermissions_UserPermissions() {
    *this = ::std::move(from);
  }

  inline UsersAndPermissions_UserPermissions& operator=(const UsersAndPermissions_UserPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersAndPermissions_UserPermissions& operator=(UsersAndPermissions_UserPermissions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsersAndPermissions_UserPermissions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsersAndPermissions_UserPermissions* internal_default_instance() {
    return reinterpret_cast<const UsersAndPermissions_UserPermissions*>(
               &_UsersAndPermissions_UserPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(UsersAndPermissions_UserPermissions& a, UsersAndPermissions_UserPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersAndPermissions_UserPermissions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsersAndPermissions_UserPermissions* New() const final {
    return CreateMaybeMessage<UsersAndPermissions_UserPermissions>(nullptr);
  }

  UsersAndPermissions_UserPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsersAndPermissions_UserPermissions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsersAndPermissions_UserPermissions& from);
  void MergeFrom(const UsersAndPermissions_UserPermissions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersAndPermissions_UserPermissions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.UsersAndPermissions.UserPermissions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionsFieldNumber = 2,
    kUserFieldNumber = 1,
  };
  // repeated .hbase.pb.Permission permissions = 2;
  int permissions_size() const;
  void clear_permissions();
  ::hbase::pb::Permission* mutable_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >*
      mutable_permissions();
  const ::hbase::pb::Permission& permissions(int index) const;
  ::hbase::pb::Permission* add_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >&
      permissions() const;

  // required bytes user = 1;
  bool has_user() const;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const void* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);

  // @@protoc_insertion_point(class_scope:hbase.pb.UsersAndPermissions.UserPermissions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission > permissions_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class UsersAndPermissions :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.UsersAndPermissions) */ {
 public:
  UsersAndPermissions();
  virtual ~UsersAndPermissions();

  UsersAndPermissions(const UsersAndPermissions& from);
  UsersAndPermissions(UsersAndPermissions&& from) noexcept
    : UsersAndPermissions() {
    *this = ::std::move(from);
  }

  inline UsersAndPermissions& operator=(const UsersAndPermissions& from) {
    CopyFrom(from);
    return *this;
  }
  inline UsersAndPermissions& operator=(UsersAndPermissions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UsersAndPermissions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UsersAndPermissions* internal_default_instance() {
    return reinterpret_cast<const UsersAndPermissions*>(
               &_UsersAndPermissions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(UsersAndPermissions& a, UsersAndPermissions& b) {
    a.Swap(&b);
  }
  inline void Swap(UsersAndPermissions* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UsersAndPermissions* New() const final {
    return CreateMaybeMessage<UsersAndPermissions>(nullptr);
  }

  UsersAndPermissions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UsersAndPermissions>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UsersAndPermissions& from);
  void MergeFrom(const UsersAndPermissions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UsersAndPermissions* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.UsersAndPermissions";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef UsersAndPermissions_UserPermissions UserPermissions;

  // accessors -------------------------------------------------------

  enum : int {
    kUserPermissionsFieldNumber = 1,
  };
  // repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
  int user_permissions_size() const;
  void clear_user_permissions();
  ::hbase::pb::UsersAndPermissions_UserPermissions* mutable_user_permissions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >*
      mutable_user_permissions();
  const ::hbase::pb::UsersAndPermissions_UserPermissions& user_permissions(int index) const;
  ::hbase::pb::UsersAndPermissions_UserPermissions* add_user_permissions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >&
      user_permissions() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.UsersAndPermissions)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions > user_permissions_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class GrantRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GrantRequest) */ {
 public:
  GrantRequest();
  virtual ~GrantRequest();

  GrantRequest(const GrantRequest& from);
  GrantRequest(GrantRequest&& from) noexcept
    : GrantRequest() {
    *this = ::std::move(from);
  }

  inline GrantRequest& operator=(const GrantRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantRequest& operator=(GrantRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GrantRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GrantRequest* internal_default_instance() {
    return reinterpret_cast<const GrantRequest*>(
               &_GrantRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GrantRequest& a, GrantRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GrantRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GrantRequest* New() const final {
    return CreateMaybeMessage<GrantRequest>(nullptr);
  }

  GrantRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GrantRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GrantRequest& from);
  void MergeFrom(const GrantRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrantRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GrantRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPermissionFieldNumber = 1,
    kMergeExistingPermissionsFieldNumber = 2,
  };
  // required .hbase.pb.UserPermission user_permission = 1;
  bool has_user_permission() const;
  void clear_user_permission();
  const ::hbase::pb::UserPermission& user_permission() const;
  ::hbase::pb::UserPermission* release_user_permission();
  ::hbase::pb::UserPermission* mutable_user_permission();
  void set_allocated_user_permission(::hbase::pb::UserPermission* user_permission);

  // optional bool merge_existing_permissions = 2 [default = false];
  bool has_merge_existing_permissions() const;
  void clear_merge_existing_permissions();
  bool merge_existing_permissions() const;
  void set_merge_existing_permissions(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.GrantRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::UserPermission* user_permission_;
  bool merge_existing_permissions_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class GrantResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GrantResponse) */ {
 public:
  GrantResponse();
  virtual ~GrantResponse();

  GrantResponse(const GrantResponse& from);
  GrantResponse(GrantResponse&& from) noexcept
    : GrantResponse() {
    *this = ::std::move(from);
  }

  inline GrantResponse& operator=(const GrantResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GrantResponse& operator=(GrantResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GrantResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GrantResponse* internal_default_instance() {
    return reinterpret_cast<const GrantResponse*>(
               &_GrantResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GrantResponse& a, GrantResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GrantResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GrantResponse* New() const final {
    return CreateMaybeMessage<GrantResponse>(nullptr);
  }

  GrantResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GrantResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GrantResponse& from);
  void MergeFrom(const GrantResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GrantResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GrantResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.GrantResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class RevokeRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RevokeRequest) */ {
 public:
  RevokeRequest();
  virtual ~RevokeRequest();

  RevokeRequest(const RevokeRequest& from);
  RevokeRequest(RevokeRequest&& from) noexcept
    : RevokeRequest() {
    *this = ::std::move(from);
  }

  inline RevokeRequest& operator=(const RevokeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeRequest& operator=(RevokeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RevokeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevokeRequest* internal_default_instance() {
    return reinterpret_cast<const RevokeRequest*>(
               &_RevokeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RevokeRequest& a, RevokeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RevokeRequest* New() const final {
    return CreateMaybeMessage<RevokeRequest>(nullptr);
  }

  RevokeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RevokeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RevokeRequest& from);
  void MergeFrom(const RevokeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RevokeRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPermissionFieldNumber = 1,
  };
  // required .hbase.pb.UserPermission user_permission = 1;
  bool has_user_permission() const;
  void clear_user_permission();
  const ::hbase::pb::UserPermission& user_permission() const;
  ::hbase::pb::UserPermission* release_user_permission();
  ::hbase::pb::UserPermission* mutable_user_permission();
  void set_allocated_user_permission(::hbase::pb::UserPermission* user_permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.RevokeRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::UserPermission* user_permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class RevokeResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RevokeResponse) */ {
 public:
  RevokeResponse();
  virtual ~RevokeResponse();

  RevokeResponse(const RevokeResponse& from);
  RevokeResponse(RevokeResponse&& from) noexcept
    : RevokeResponse() {
    *this = ::std::move(from);
  }

  inline RevokeResponse& operator=(const RevokeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RevokeResponse& operator=(RevokeResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RevokeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RevokeResponse* internal_default_instance() {
    return reinterpret_cast<const RevokeResponse*>(
               &_RevokeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RevokeResponse& a, RevokeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RevokeResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RevokeResponse* New() const final {
    return CreateMaybeMessage<RevokeResponse>(nullptr);
  }

  RevokeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RevokeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RevokeResponse& from);
  void MergeFrom(const RevokeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RevokeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RevokeResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.RevokeResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class GetUserPermissionsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GetUserPermissionsRequest) */ {
 public:
  GetUserPermissionsRequest();
  virtual ~GetUserPermissionsRequest();

  GetUserPermissionsRequest(const GetUserPermissionsRequest& from);
  GetUserPermissionsRequest(GetUserPermissionsRequest&& from) noexcept
    : GetUserPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline GetUserPermissionsRequest& operator=(const GetUserPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserPermissionsRequest& operator=(GetUserPermissionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserPermissionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserPermissionsRequest*>(
               &_GetUserPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetUserPermissionsRequest& a, GetUserPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserPermissionsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserPermissionsRequest* New() const final {
    return CreateMaybeMessage<GetUserPermissionsRequest>(nullptr);
  }

  GetUserPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserPermissionsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserPermissionsRequest& from);
  void MergeFrom(const GetUserPermissionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserPermissionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GetUserPermissionsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceNameFieldNumber = 3,
    kColumnFamilyFieldNumber = 4,
    kColumnQualifierFieldNumber = 5,
    kUserNameFieldNumber = 6,
    kTableNameFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional bytes namespace_name = 3;
  bool has_namespace_name() const;
  void clear_namespace_name();
  const std::string& namespace_name() const;
  void set_namespace_name(const std::string& value);
  void set_namespace_name(std::string&& value);
  void set_namespace_name(const char* value);
  void set_namespace_name(const void* value, size_t size);
  std::string* mutable_namespace_name();
  std::string* release_namespace_name();
  void set_allocated_namespace_name(std::string* namespace_name);

  // optional bytes column_family = 4;
  bool has_column_family() const;
  void clear_column_family();
  const std::string& column_family() const;
  void set_column_family(const std::string& value);
  void set_column_family(std::string&& value);
  void set_column_family(const char* value);
  void set_column_family(const void* value, size_t size);
  std::string* mutable_column_family();
  std::string* release_column_family();
  void set_allocated_column_family(std::string* column_family);

  // optional bytes column_qualifier = 5;
  bool has_column_qualifier() const;
  void clear_column_qualifier();
  const std::string& column_qualifier() const;
  void set_column_qualifier(const std::string& value);
  void set_column_qualifier(std::string&& value);
  void set_column_qualifier(const char* value);
  void set_column_qualifier(const void* value, size_t size);
  std::string* mutable_column_qualifier();
  std::string* release_column_qualifier();
  void set_allocated_column_qualifier(std::string* column_qualifier);

  // optional bytes user_name = 6;
  bool has_user_name() const;
  void clear_user_name();
  const std::string& user_name() const;
  void set_user_name(const std::string& value);
  void set_user_name(std::string&& value);
  void set_user_name(const char* value);
  void set_user_name(const void* value, size_t size);
  std::string* mutable_user_name();
  std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);

  // optional .hbase.pb.TableName table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional .hbase.pb.Permission.Type type = 1;
  bool has_type() const;
  void clear_type();
  ::hbase::pb::Permission_Type type() const;
  void set_type(::hbase::pb::Permission_Type value);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetUserPermissionsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_qualifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::hbase::pb::TableName* table_name_;
  int type_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class GetUserPermissionsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GetUserPermissionsResponse) */ {
 public:
  GetUserPermissionsResponse();
  virtual ~GetUserPermissionsResponse();

  GetUserPermissionsResponse(const GetUserPermissionsResponse& from);
  GetUserPermissionsResponse(GetUserPermissionsResponse&& from) noexcept
    : GetUserPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline GetUserPermissionsResponse& operator=(const GetUserPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserPermissionsResponse& operator=(GetUserPermissionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetUserPermissionsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserPermissionsResponse*>(
               &_GetUserPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetUserPermissionsResponse& a, GetUserPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserPermissionsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetUserPermissionsResponse* New() const final {
    return CreateMaybeMessage<GetUserPermissionsResponse>(nullptr);
  }

  GetUserPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetUserPermissionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetUserPermissionsResponse& from);
  void MergeFrom(const GetUserPermissionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserPermissionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GetUserPermissionsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPermissionFieldNumber = 1,
  };
  // repeated .hbase.pb.UserPermission user_permission = 1;
  int user_permission_size() const;
  void clear_user_permission();
  ::hbase::pb::UserPermission* mutable_user_permission(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UserPermission >*
      mutable_user_permission();
  const ::hbase::pb::UserPermission& user_permission(int index) const;
  ::hbase::pb::UserPermission* add_user_permission();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UserPermission >&
      user_permission() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.GetUserPermissionsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UserPermission > user_permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CheckPermissionsRequest) */ {
 public:
  CheckPermissionsRequest();
  virtual ~CheckPermissionsRequest();

  CheckPermissionsRequest(const CheckPermissionsRequest& from);
  CheckPermissionsRequest(CheckPermissionsRequest&& from) noexcept
    : CheckPermissionsRequest() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsRequest& operator=(const CheckPermissionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsRequest& operator=(CheckPermissionsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckPermissionsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckPermissionsRequest* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsRequest*>(
               &_CheckPermissionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CheckPermissionsRequest& a, CheckPermissionsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckPermissionsRequest* New() const final {
    return CreateMaybeMessage<CheckPermissionsRequest>(nullptr);
  }

  CheckPermissionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckPermissionsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckPermissionsRequest& from);
  void MergeFrom(const CheckPermissionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CheckPermissionsRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPermissionFieldNumber = 1,
  };
  // repeated .hbase.pb.Permission permission = 1;
  int permission_size() const;
  void clear_permission();
  ::hbase::pb::Permission* mutable_permission(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >*
      mutable_permission();
  const ::hbase::pb::Permission& permission(int index) const;
  ::hbase::pb::Permission* add_permission();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >&
      permission() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.CheckPermissionsRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission > permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class CheckPermissionsResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CheckPermissionsResponse) */ {
 public:
  CheckPermissionsResponse();
  virtual ~CheckPermissionsResponse();

  CheckPermissionsResponse(const CheckPermissionsResponse& from);
  CheckPermissionsResponse(CheckPermissionsResponse&& from) noexcept
    : CheckPermissionsResponse() {
    *this = ::std::move(from);
  }

  inline CheckPermissionsResponse& operator=(const CheckPermissionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CheckPermissionsResponse& operator=(CheckPermissionsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CheckPermissionsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CheckPermissionsResponse* internal_default_instance() {
    return reinterpret_cast<const CheckPermissionsResponse*>(
               &_CheckPermissionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CheckPermissionsResponse& a, CheckPermissionsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CheckPermissionsResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CheckPermissionsResponse* New() const final {
    return CreateMaybeMessage<CheckPermissionsResponse>(nullptr);
  }

  CheckPermissionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CheckPermissionsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CheckPermissionsResponse& from);
  void MergeFrom(const CheckPermissionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CheckPermissionsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CheckPermissionsResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.CheckPermissionsResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class HasPermissionRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.HasPermissionRequest) */ {
 public:
  HasPermissionRequest();
  virtual ~HasPermissionRequest();

  HasPermissionRequest(const HasPermissionRequest& from);
  HasPermissionRequest(HasPermissionRequest&& from) noexcept
    : HasPermissionRequest() {
    *this = ::std::move(from);
  }

  inline HasPermissionRequest& operator=(const HasPermissionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasPermissionRequest& operator=(HasPermissionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HasPermissionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HasPermissionRequest* internal_default_instance() {
    return reinterpret_cast<const HasPermissionRequest*>(
               &_HasPermissionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(HasPermissionRequest& a, HasPermissionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HasPermissionRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HasPermissionRequest* New() const final {
    return CreateMaybeMessage<HasPermissionRequest>(nullptr);
  }

  HasPermissionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HasPermissionRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HasPermissionRequest& from);
  void MergeFrom(const HasPermissionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HasPermissionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.HasPermissionRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kTablePermissionFieldNumber = 1,
  };
  // required bytes user_name = 2;
  bool has_user_name() const;
  void clear_user_name();
  const std::string& user_name() const;
  void set_user_name(const std::string& value);
  void set_user_name(std::string&& value);
  void set_user_name(const char* value);
  void set_user_name(const void* value, size_t size);
  std::string* mutable_user_name();
  std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);

  // required .hbase.pb.TablePermission table_permission = 1;
  bool has_table_permission() const;
  void clear_table_permission();
  const ::hbase::pb::TablePermission& table_permission() const;
  ::hbase::pb::TablePermission* release_table_permission();
  ::hbase::pb::TablePermission* mutable_table_permission();
  void set_allocated_table_permission(::hbase::pb::TablePermission* table_permission);

  // @@protoc_insertion_point(class_scope:hbase.pb.HasPermissionRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  ::hbase::pb::TablePermission* table_permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// -------------------------------------------------------------------

class HasPermissionResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.HasPermissionResponse) */ {
 public:
  HasPermissionResponse();
  virtual ~HasPermissionResponse();

  HasPermissionResponse(const HasPermissionResponse& from);
  HasPermissionResponse(HasPermissionResponse&& from) noexcept
    : HasPermissionResponse() {
    *this = ::std::move(from);
  }

  inline HasPermissionResponse& operator=(const HasPermissionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HasPermissionResponse& operator=(HasPermissionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HasPermissionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HasPermissionResponse* internal_default_instance() {
    return reinterpret_cast<const HasPermissionResponse*>(
               &_HasPermissionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(HasPermissionResponse& a, HasPermissionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HasPermissionResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HasPermissionResponse* New() const final {
    return CreateMaybeMessage<HasPermissionResponse>(nullptr);
  }

  HasPermissionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HasPermissionResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HasPermissionResponse& from);
  void MergeFrom(const HasPermissionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HasPermissionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.HasPermissionResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_AccessControl_2eproto);
    return ::descriptor_table_AccessControl_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHasPermissionFieldNumber = 1,
  };
  // optional bool has_permission = 1;
  bool has_has_permission() const;
  void clear_has_permission();
  bool has_permission() const;
  void set_has_permission(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.HasPermissionResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool has_permission_;
  friend struct ::TableStruct_AccessControl_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Permission

// required .hbase.pb.Permission.Type type = 1;
inline bool Permission::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Permission::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hbase::pb::Permission_Type Permission::type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Permission.type)
  return static_cast< ::hbase::pb::Permission_Type >(type_);
}
inline void Permission::set_type(::hbase::pb::Permission_Type value) {
  assert(::hbase::pb::Permission_Type_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Permission.type)
}

// optional .hbase.pb.GlobalPermission global_permission = 2;
inline bool Permission::has_global_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Permission::clear_global_permission() {
  if (global_permission_ != nullptr) global_permission_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::GlobalPermission& Permission::global_permission() const {
  const ::hbase::pb::GlobalPermission* p = global_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.Permission.global_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::GlobalPermission*>(
      &::hbase::pb::_GlobalPermission_default_instance_);
}
inline ::hbase::pb::GlobalPermission* Permission::release_global_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.Permission.global_permission)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::GlobalPermission* temp = global_permission_;
  global_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::GlobalPermission* Permission::mutable_global_permission() {
  _has_bits_[0] |= 0x00000001u;
  if (global_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::GlobalPermission>(GetArenaNoVirtual());
    global_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Permission.global_permission)
  return global_permission_;
}
inline void Permission::set_allocated_global_permission(::hbase::pb::GlobalPermission* global_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete global_permission_;
  }
  if (global_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      global_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, global_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  global_permission_ = global_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Permission.global_permission)
}

// optional .hbase.pb.NamespacePermission namespace_permission = 3;
inline bool Permission::has_namespace_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Permission::clear_namespace_permission() {
  if (namespace_permission_ != nullptr) namespace_permission_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::NamespacePermission& Permission::namespace_permission() const {
  const ::hbase::pb::NamespacePermission* p = namespace_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.Permission.namespace_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::NamespacePermission*>(
      &::hbase::pb::_NamespacePermission_default_instance_);
}
inline ::hbase::pb::NamespacePermission* Permission::release_namespace_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.Permission.namespace_permission)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::NamespacePermission* temp = namespace_permission_;
  namespace_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::NamespacePermission* Permission::mutable_namespace_permission() {
  _has_bits_[0] |= 0x00000002u;
  if (namespace_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::NamespacePermission>(GetArenaNoVirtual());
    namespace_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Permission.namespace_permission)
  return namespace_permission_;
}
inline void Permission::set_allocated_namespace_permission(::hbase::pb::NamespacePermission* namespace_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete namespace_permission_;
  }
  if (namespace_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      namespace_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  namespace_permission_ = namespace_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Permission.namespace_permission)
}

// optional .hbase.pb.TablePermission table_permission = 4;
inline bool Permission::has_table_permission() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Permission::clear_table_permission() {
  if (table_permission_ != nullptr) table_permission_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::TablePermission& Permission::table_permission() const {
  const ::hbase::pb::TablePermission* p = table_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.Permission.table_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TablePermission*>(
      &::hbase::pb::_TablePermission_default_instance_);
}
inline ::hbase::pb::TablePermission* Permission::release_table_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.Permission.table_permission)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::TablePermission* temp = table_permission_;
  table_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::TablePermission* Permission::mutable_table_permission() {
  _has_bits_[0] |= 0x00000004u;
  if (table_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TablePermission>(GetArenaNoVirtual());
    table_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Permission.table_permission)
  return table_permission_;
}
inline void Permission::set_allocated_table_permission(::hbase::pb::TablePermission* table_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_permission_;
  }
  if (table_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_permission_ = table_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Permission.table_permission)
}

// -------------------------------------------------------------------

// TablePermission

// optional .hbase.pb.TableName table_name = 1;
inline bool TablePermission::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::TableName& TablePermission::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.TablePermission.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* TablePermission::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.TablePermission.table_name)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* TablePermission::mutable_table_name() {
  _has_bits_[0] |= 0x00000004u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.TablePermission.table_name)
  return table_name_;
}
inline void TablePermission::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TablePermission.table_name)
}

// optional bytes family = 2;
inline bool TablePermission::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TablePermission::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TablePermission::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TablePermission.family)
  return family_.GetNoArena();
}
inline void TablePermission::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.TablePermission.family)
}
inline void TablePermission::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.TablePermission.family)
}
inline void TablePermission::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.TablePermission.family)
}
inline void TablePermission::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.TablePermission.family)
}
inline std::string* TablePermission::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.TablePermission.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TablePermission::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.TablePermission.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TablePermission::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TablePermission.family)
}

// optional bytes qualifier = 3;
inline bool TablePermission::has_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TablePermission::clear_qualifier() {
  qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TablePermission::qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TablePermission.qualifier)
  return qualifier_.GetNoArena();
}
inline void TablePermission::set_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.TablePermission.qualifier)
}
inline void TablePermission::set_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.TablePermission.qualifier)
}
inline void TablePermission::set_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.TablePermission.qualifier)
}
inline void TablePermission::set_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.TablePermission.qualifier)
}
inline std::string* TablePermission::mutable_qualifier() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.TablePermission.qualifier)
  return qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TablePermission::release_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.TablePermission.qualifier)
  if (!has_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TablePermission::set_allocated_qualifier(std::string* qualifier) {
  if (qualifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TablePermission.qualifier)
}

// repeated .hbase.pb.Permission.Action action = 4;
inline int TablePermission::action_size() const {
  return action_.size();
}
inline void TablePermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action TablePermission::action(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TablePermission.action)
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void TablePermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.TablePermission.action)
}
inline void TablePermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.TablePermission.action)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
TablePermission::action() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TablePermission.action)
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
TablePermission::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TablePermission.action)
  return &action_;
}

// -------------------------------------------------------------------

// NamespacePermission

// optional bytes namespace_name = 1;
inline bool NamespacePermission::has_namespace_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamespacePermission::clear_namespace_name() {
  namespace_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespacePermission::namespace_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NamespacePermission.namespace_name)
  return namespace_name_.GetNoArena();
}
inline void NamespacePermission::set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NamespacePermission.namespace_name)
}
inline void NamespacePermission::set_namespace_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NamespacePermission.namespace_name)
}
inline void NamespacePermission::set_namespace_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NamespacePermission.namespace_name)
}
inline void NamespacePermission::set_namespace_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NamespacePermission.namespace_name)
}
inline std::string* NamespacePermission::mutable_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NamespacePermission.namespace_name)
  return namespace_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespacePermission::release_namespace_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.NamespacePermission.namespace_name)
  if (!has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespacePermission::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NamespacePermission.namespace_name)
}

// repeated .hbase.pb.Permission.Action action = 2;
inline int NamespacePermission::action_size() const {
  return action_.size();
}
inline void NamespacePermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action NamespacePermission::action(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.NamespacePermission.action)
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void NamespacePermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.NamespacePermission.action)
}
inline void NamespacePermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.NamespacePermission.action)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
NamespacePermission::action() const {
  // @@protoc_insertion_point(field_list:hbase.pb.NamespacePermission.action)
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
NamespacePermission::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.NamespacePermission.action)
  return &action_;
}

// -------------------------------------------------------------------

// GlobalPermission

// repeated .hbase.pb.Permission.Action action = 1;
inline int GlobalPermission::action_size() const {
  return action_.size();
}
inline void GlobalPermission::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Permission_Action GlobalPermission::action(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.GlobalPermission.action)
  return static_cast< ::hbase::pb::Permission_Action >(action_.Get(index));
}
inline void GlobalPermission::set_action(int index, ::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.GlobalPermission.action)
}
inline void GlobalPermission::add_action(::hbase::pb::Permission_Action value) {
  assert(::hbase::pb::Permission_Action_IsValid(value));
  action_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.GlobalPermission.action)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
GlobalPermission::action() const {
  // @@protoc_insertion_point(field_list:hbase.pb.GlobalPermission.action)
  return action_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
GlobalPermission::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.GlobalPermission.action)
  return &action_;
}

// -------------------------------------------------------------------

// UserPermission

// required bytes user = 1;
inline bool UserPermission::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPermission::clear_user() {
  user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UserPermission::user() const {
  // @@protoc_insertion_point(field_get:hbase.pb.UserPermission.user)
  return user_.GetNoArena();
}
inline void UserPermission::set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.UserPermission.user)
}
inline void UserPermission::set_user(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.UserPermission.user)
}
inline void UserPermission::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.UserPermission.user)
}
inline void UserPermission::set_user(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.UserPermission.user)
}
inline std::string* UserPermission::mutable_user() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.UserPermission.user)
  return user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UserPermission::release_user() {
  // @@protoc_insertion_point(field_release:hbase.pb.UserPermission.user)
  if (!has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UserPermission::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.UserPermission.user)
}

// required .hbase.pb.Permission permission = 3;
inline bool UserPermission::has_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPermission::clear_permission() {
  if (permission_ != nullptr) permission_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::Permission& UserPermission::permission() const {
  const ::hbase::pb::Permission* p = permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.UserPermission.permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Permission*>(
      &::hbase::pb::_Permission_default_instance_);
}
inline ::hbase::pb::Permission* UserPermission::release_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.UserPermission.permission)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Permission* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::Permission* UserPermission::mutable_permission() {
  _has_bits_[0] |= 0x00000002u;
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Permission>(GetArenaNoVirtual());
    permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.UserPermission.permission)
  return permission_;
}
inline void UserPermission::set_allocated_permission(::hbase::pb::Permission* permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete permission_;
  }
  if (permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.UserPermission.permission)
}

// -------------------------------------------------------------------

// UsersAndPermissions_UserPermissions

// required bytes user = 1;
inline bool UsersAndPermissions_UserPermissions::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UsersAndPermissions_UserPermissions::clear_user() {
  user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& UsersAndPermissions_UserPermissions::user() const {
  // @@protoc_insertion_point(field_get:hbase.pb.UsersAndPermissions.UserPermissions.user)
  return user_.GetNoArena();
}
inline void UsersAndPermissions_UserPermissions::set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.UsersAndPermissions.UserPermissions.user)
}
inline void UsersAndPermissions_UserPermissions::set_user(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.UsersAndPermissions.UserPermissions.user)
}
inline void UsersAndPermissions_UserPermissions::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.UsersAndPermissions.UserPermissions.user)
}
inline void UsersAndPermissions_UserPermissions::set_user(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.UsersAndPermissions.UserPermissions.user)
}
inline std::string* UsersAndPermissions_UserPermissions::mutable_user() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.UsersAndPermissions.UserPermissions.user)
  return user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* UsersAndPermissions_UserPermissions::release_user() {
  // @@protoc_insertion_point(field_release:hbase.pb.UsersAndPermissions.UserPermissions.user)
  if (!has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void UsersAndPermissions_UserPermissions::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.UsersAndPermissions.UserPermissions.user)
}

// repeated .hbase.pb.Permission permissions = 2;
inline int UsersAndPermissions_UserPermissions::permissions_size() const {
  return permissions_.size();
}
inline void UsersAndPermissions_UserPermissions::clear_permissions() {
  permissions_.Clear();
}
inline ::hbase::pb::Permission* UsersAndPermissions_UserPermissions::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.UsersAndPermissions.UserPermissions.permissions)
  return permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >*
UsersAndPermissions_UserPermissions::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.UsersAndPermissions.UserPermissions.permissions)
  return &permissions_;
}
inline const ::hbase::pb::Permission& UsersAndPermissions_UserPermissions::permissions(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.UsersAndPermissions.UserPermissions.permissions)
  return permissions_.Get(index);
}
inline ::hbase::pb::Permission* UsersAndPermissions_UserPermissions::add_permissions() {
  // @@protoc_insertion_point(field_add:hbase.pb.UsersAndPermissions.UserPermissions.permissions)
  return permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >&
UsersAndPermissions_UserPermissions::permissions() const {
  // @@protoc_insertion_point(field_list:hbase.pb.UsersAndPermissions.UserPermissions.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// UsersAndPermissions

// repeated .hbase.pb.UsersAndPermissions.UserPermissions user_permissions = 1;
inline int UsersAndPermissions::user_permissions_size() const {
  return user_permissions_.size();
}
inline void UsersAndPermissions::clear_user_permissions() {
  user_permissions_.Clear();
}
inline ::hbase::pb::UsersAndPermissions_UserPermissions* UsersAndPermissions::mutable_user_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.UsersAndPermissions.user_permissions)
  return user_permissions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >*
UsersAndPermissions::mutable_user_permissions() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.UsersAndPermissions.user_permissions)
  return &user_permissions_;
}
inline const ::hbase::pb::UsersAndPermissions_UserPermissions& UsersAndPermissions::user_permissions(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.UsersAndPermissions.user_permissions)
  return user_permissions_.Get(index);
}
inline ::hbase::pb::UsersAndPermissions_UserPermissions* UsersAndPermissions::add_user_permissions() {
  // @@protoc_insertion_point(field_add:hbase.pb.UsersAndPermissions.user_permissions)
  return user_permissions_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UsersAndPermissions_UserPermissions >&
UsersAndPermissions::user_permissions() const {
  // @@protoc_insertion_point(field_list:hbase.pb.UsersAndPermissions.user_permissions)
  return user_permissions_;
}

// -------------------------------------------------------------------

// GrantRequest

// required .hbase.pb.UserPermission user_permission = 1;
inline bool GrantRequest::has_user_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GrantRequest::clear_user_permission() {
  if (user_permission_ != nullptr) user_permission_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::UserPermission& GrantRequest::user_permission() const {
  const ::hbase::pb::UserPermission* p = user_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.GrantRequest.user_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::UserPermission*>(
      &::hbase::pb::_UserPermission_default_instance_);
}
inline ::hbase::pb::UserPermission* GrantRequest::release_user_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.GrantRequest.user_permission)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::UserPermission* temp = user_permission_;
  user_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::UserPermission* GrantRequest::mutable_user_permission() {
  _has_bits_[0] |= 0x00000001u;
  if (user_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::UserPermission>(GetArenaNoVirtual());
    user_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.GrantRequest.user_permission)
  return user_permission_;
}
inline void GrantRequest::set_allocated_user_permission(::hbase::pb::UserPermission* user_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_permission_;
  }
  if (user_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_permission_ = user_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GrantRequest.user_permission)
}

// optional bool merge_existing_permissions = 2 [default = false];
inline bool GrantRequest::has_merge_existing_permissions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GrantRequest::clear_merge_existing_permissions() {
  merge_existing_permissions_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool GrantRequest::merge_existing_permissions() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GrantRequest.merge_existing_permissions)
  return merge_existing_permissions_;
}
inline void GrantRequest::set_merge_existing_permissions(bool value) {
  _has_bits_[0] |= 0x00000002u;
  merge_existing_permissions_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.GrantRequest.merge_existing_permissions)
}

// -------------------------------------------------------------------

// GrantResponse

// -------------------------------------------------------------------

// RevokeRequest

// required .hbase.pb.UserPermission user_permission = 1;
inline bool RevokeRequest::has_user_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RevokeRequest::clear_user_permission() {
  if (user_permission_ != nullptr) user_permission_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::UserPermission& RevokeRequest::user_permission() const {
  const ::hbase::pb::UserPermission* p = user_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.RevokeRequest.user_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::UserPermission*>(
      &::hbase::pb::_UserPermission_default_instance_);
}
inline ::hbase::pb::UserPermission* RevokeRequest::release_user_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.RevokeRequest.user_permission)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::UserPermission* temp = user_permission_;
  user_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::UserPermission* RevokeRequest::mutable_user_permission() {
  _has_bits_[0] |= 0x00000001u;
  if (user_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::UserPermission>(GetArenaNoVirtual());
    user_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RevokeRequest.user_permission)
  return user_permission_;
}
inline void RevokeRequest::set_allocated_user_permission(::hbase::pb::UserPermission* user_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete user_permission_;
  }
  if (user_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_permission_ = user_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RevokeRequest.user_permission)
}

// -------------------------------------------------------------------

// RevokeResponse

// -------------------------------------------------------------------

// GetUserPermissionsRequest

// optional .hbase.pb.Permission.Type type = 1;
inline bool GetUserPermissionsRequest::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetUserPermissionsRequest::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hbase::pb::Permission_Type GetUserPermissionsRequest::type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.type)
  return static_cast< ::hbase::pb::Permission_Type >(type_);
}
inline void GetUserPermissionsRequest::set_type(::hbase::pb::Permission_Type value) {
  assert(::hbase::pb::Permission_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.GetUserPermissionsRequest.type)
}

// optional .hbase.pb.TableName table_name = 2;
inline bool GetUserPermissionsRequest::has_table_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline const ::hbase::pb::TableName& GetUserPermissionsRequest::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* GetUserPermissionsRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetUserPermissionsRequest.table_name)
  _has_bits_[0] &= ~0x00000010u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* GetUserPermissionsRequest::mutable_table_name() {
  _has_bits_[0] |= 0x00000010u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsRequest.table_name)
  return table_name_;
}
inline void GetUserPermissionsRequest::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetUserPermissionsRequest.table_name)
}

// optional bytes namespace_name = 3;
inline bool GetUserPermissionsRequest::has_namespace_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUserPermissionsRequest::clear_namespace_name() {
  namespace_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetUserPermissionsRequest::namespace_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.namespace_name)
  return namespace_name_.GetNoArena();
}
inline void GetUserPermissionsRequest::set_namespace_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.GetUserPermissionsRequest.namespace_name)
}
inline void GetUserPermissionsRequest::set_namespace_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.GetUserPermissionsRequest.namespace_name)
}
inline void GetUserPermissionsRequest::set_namespace_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.GetUserPermissionsRequest.namespace_name)
}
inline void GetUserPermissionsRequest::set_namespace_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  namespace_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.GetUserPermissionsRequest.namespace_name)
}
inline std::string* GetUserPermissionsRequest::mutable_namespace_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsRequest.namespace_name)
  return namespace_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetUserPermissionsRequest::release_namespace_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetUserPermissionsRequest.namespace_name)
  if (!has_namespace_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserPermissionsRequest::set_allocated_namespace_name(std::string* namespace_name) {
  if (namespace_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetUserPermissionsRequest.namespace_name)
}

// optional bytes column_family = 4;
inline bool GetUserPermissionsRequest::has_column_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUserPermissionsRequest::clear_column_family() {
  column_family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetUserPermissionsRequest::column_family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.column_family)
  return column_family_.GetNoArena();
}
inline void GetUserPermissionsRequest::set_column_family(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.GetUserPermissionsRequest.column_family)
}
inline void GetUserPermissionsRequest::set_column_family(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  column_family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.GetUserPermissionsRequest.column_family)
}
inline void GetUserPermissionsRequest::set_column_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.GetUserPermissionsRequest.column_family)
}
inline void GetUserPermissionsRequest::set_column_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.GetUserPermissionsRequest.column_family)
}
inline std::string* GetUserPermissionsRequest::mutable_column_family() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsRequest.column_family)
  return column_family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetUserPermissionsRequest::release_column_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetUserPermissionsRequest.column_family)
  if (!has_column_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return column_family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserPermissionsRequest::set_allocated_column_family(std::string* column_family) {
  if (column_family != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  column_family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetUserPermissionsRequest.column_family)
}

// optional bytes column_qualifier = 5;
inline bool GetUserPermissionsRequest::has_column_qualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUserPermissionsRequest::clear_column_qualifier() {
  column_qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetUserPermissionsRequest::column_qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.column_qualifier)
  return column_qualifier_.GetNoArena();
}
inline void GetUserPermissionsRequest::set_column_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.GetUserPermissionsRequest.column_qualifier)
}
inline void GetUserPermissionsRequest::set_column_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  column_qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.GetUserPermissionsRequest.column_qualifier)
}
inline void GetUserPermissionsRequest::set_column_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.GetUserPermissionsRequest.column_qualifier)
}
inline void GetUserPermissionsRequest::set_column_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.GetUserPermissionsRequest.column_qualifier)
}
inline std::string* GetUserPermissionsRequest::mutable_column_qualifier() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsRequest.column_qualifier)
  return column_qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetUserPermissionsRequest::release_column_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetUserPermissionsRequest.column_qualifier)
  if (!has_column_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return column_qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserPermissionsRequest::set_allocated_column_qualifier(std::string* column_qualifier) {
  if (column_qualifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  column_qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetUserPermissionsRequest.column_qualifier)
}

// optional bytes user_name = 6;
inline bool GetUserPermissionsRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUserPermissionsRequest::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GetUserPermissionsRequest::user_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsRequest.user_name)
  return user_name_.GetNoArena();
}
inline void GetUserPermissionsRequest::set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.GetUserPermissionsRequest.user_name)
}
inline void GetUserPermissionsRequest::set_user_name(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.GetUserPermissionsRequest.user_name)
}
inline void GetUserPermissionsRequest::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.GetUserPermissionsRequest.user_name)
}
inline void GetUserPermissionsRequest::set_user_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.GetUserPermissionsRequest.user_name)
}
inline std::string* GetUserPermissionsRequest::mutable_user_name() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsRequest.user_name)
  return user_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* GetUserPermissionsRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetUserPermissionsRequest.user_name)
  if (!has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserPermissionsRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetUserPermissionsRequest.user_name)
}

// -------------------------------------------------------------------

// GetUserPermissionsResponse

// repeated .hbase.pb.UserPermission user_permission = 1;
inline int GetUserPermissionsResponse::user_permission_size() const {
  return user_permission_.size();
}
inline void GetUserPermissionsResponse::clear_user_permission() {
  user_permission_.Clear();
}
inline ::hbase::pb::UserPermission* GetUserPermissionsResponse::mutable_user_permission(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetUserPermissionsResponse.user_permission)
  return user_permission_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UserPermission >*
GetUserPermissionsResponse::mutable_user_permission() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.GetUserPermissionsResponse.user_permission)
  return &user_permission_;
}
inline const ::hbase::pb::UserPermission& GetUserPermissionsResponse::user_permission(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.GetUserPermissionsResponse.user_permission)
  return user_permission_.Get(index);
}
inline ::hbase::pb::UserPermission* GetUserPermissionsResponse::add_user_permission() {
  // @@protoc_insertion_point(field_add:hbase.pb.GetUserPermissionsResponse.user_permission)
  return user_permission_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UserPermission >&
GetUserPermissionsResponse::user_permission() const {
  // @@protoc_insertion_point(field_list:hbase.pb.GetUserPermissionsResponse.user_permission)
  return user_permission_;
}

// -------------------------------------------------------------------

// CheckPermissionsRequest

// repeated .hbase.pb.Permission permission = 1;
inline int CheckPermissionsRequest::permission_size() const {
  return permission_.size();
}
inline void CheckPermissionsRequest::clear_permission() {
  permission_.Clear();
}
inline ::hbase::pb::Permission* CheckPermissionsRequest::mutable_permission(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.CheckPermissionsRequest.permission)
  return permission_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >*
CheckPermissionsRequest::mutable_permission() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.CheckPermissionsRequest.permission)
  return &permission_;
}
inline const ::hbase::pb::Permission& CheckPermissionsRequest::permission(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.CheckPermissionsRequest.permission)
  return permission_.Get(index);
}
inline ::hbase::pb::Permission* CheckPermissionsRequest::add_permission() {
  // @@protoc_insertion_point(field_add:hbase.pb.CheckPermissionsRequest.permission)
  return permission_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Permission >&
CheckPermissionsRequest::permission() const {
  // @@protoc_insertion_point(field_list:hbase.pb.CheckPermissionsRequest.permission)
  return permission_;
}

// -------------------------------------------------------------------

// CheckPermissionsResponse

// -------------------------------------------------------------------

// HasPermissionRequest

// required .hbase.pb.TablePermission table_permission = 1;
inline bool HasPermissionRequest::has_table_permission() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HasPermissionRequest::clear_table_permission() {
  if (table_permission_ != nullptr) table_permission_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::TablePermission& HasPermissionRequest::table_permission() const {
  const ::hbase::pb::TablePermission* p = table_permission_;
  // @@protoc_insertion_point(field_get:hbase.pb.HasPermissionRequest.table_permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TablePermission*>(
      &::hbase::pb::_TablePermission_default_instance_);
}
inline ::hbase::pb::TablePermission* HasPermissionRequest::release_table_permission() {
  // @@protoc_insertion_point(field_release:hbase.pb.HasPermissionRequest.table_permission)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::TablePermission* temp = table_permission_;
  table_permission_ = nullptr;
  return temp;
}
inline ::hbase::pb::TablePermission* HasPermissionRequest::mutable_table_permission() {
  _has_bits_[0] |= 0x00000002u;
  if (table_permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TablePermission>(GetArenaNoVirtual());
    table_permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.HasPermissionRequest.table_permission)
  return table_permission_;
}
inline void HasPermissionRequest::set_allocated_table_permission(::hbase::pb::TablePermission* table_permission) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_permission_;
  }
  if (table_permission) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_permission = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_permission, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_permission_ = table_permission;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.HasPermissionRequest.table_permission)
}

// required bytes user_name = 2;
inline bool HasPermissionRequest::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HasPermissionRequest::clear_user_name() {
  user_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HasPermissionRequest::user_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.HasPermissionRequest.user_name)
  return user_name_.GetNoArena();
}
inline void HasPermissionRequest::set_user_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.HasPermissionRequest.user_name)
}
inline void HasPermissionRequest::set_user_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  user_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.HasPermissionRequest.user_name)
}
inline void HasPermissionRequest::set_user_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.HasPermissionRequest.user_name)
}
inline void HasPermissionRequest::set_user_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  user_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.HasPermissionRequest.user_name)
}
inline std::string* HasPermissionRequest::mutable_user_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.HasPermissionRequest.user_name)
  return user_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* HasPermissionRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.HasPermissionRequest.user_name)
  if (!has_user_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return user_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void HasPermissionRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.HasPermissionRequest.user_name)
}

// -------------------------------------------------------------------

// HasPermissionResponse

// optional bool has_permission = 1;
inline bool HasPermissionResponse::has_has_permission() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HasPermissionResponse::clear_has_permission() {
  has_permission_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool HasPermissionResponse::has_permission() const {
  // @@protoc_insertion_point(field_get:hbase.pb.HasPermissionResponse.has_permission)
  return has_permission_;
}
inline void HasPermissionResponse::set_has_permission(bool value) {
  _has_bits_[0] |= 0x00000001u;
  has_permission_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.HasPermissionResponse.has_permission)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::Permission_Action> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Permission_Action>() {
  return ::hbase::pb::Permission_Action_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::Permission_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Permission_Type>() {
  return ::hbase::pb::Permission_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_AccessControl_2eproto
