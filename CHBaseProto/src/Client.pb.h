// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Client.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Client_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Client_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Filter.pb.h"
#include "Cell.pb.h"
#include "Comparator.pb.h"
#include "MapReduce.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Client_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Client_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Client_2eproto;
namespace hbase {
namespace pb {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Authorizations;
class AuthorizationsDefaultTypeInternal;
extern AuthorizationsDefaultTypeInternal _Authorizations_default_instance_;
class BulkLoadHFileRequest;
class BulkLoadHFileRequestDefaultTypeInternal;
extern BulkLoadHFileRequestDefaultTypeInternal _BulkLoadHFileRequest_default_instance_;
class BulkLoadHFileRequest_FamilyPath;
class BulkLoadHFileRequest_FamilyPathDefaultTypeInternal;
extern BulkLoadHFileRequest_FamilyPathDefaultTypeInternal _BulkLoadHFileRequest_FamilyPath_default_instance_;
class BulkLoadHFileResponse;
class BulkLoadHFileResponseDefaultTypeInternal;
extern BulkLoadHFileResponseDefaultTypeInternal _BulkLoadHFileResponse_default_instance_;
class CellVisibility;
class CellVisibilityDefaultTypeInternal;
extern CellVisibilityDefaultTypeInternal _CellVisibility_default_instance_;
class CleanupBulkLoadRequest;
class CleanupBulkLoadRequestDefaultTypeInternal;
extern CleanupBulkLoadRequestDefaultTypeInternal _CleanupBulkLoadRequest_default_instance_;
class CleanupBulkLoadResponse;
class CleanupBulkLoadResponseDefaultTypeInternal;
extern CleanupBulkLoadResponseDefaultTypeInternal _CleanupBulkLoadResponse_default_instance_;
class Column;
class ColumnDefaultTypeInternal;
extern ColumnDefaultTypeInternal _Column_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class CoprocessorServiceCall;
class CoprocessorServiceCallDefaultTypeInternal;
extern CoprocessorServiceCallDefaultTypeInternal _CoprocessorServiceCall_default_instance_;
class CoprocessorServiceRequest;
class CoprocessorServiceRequestDefaultTypeInternal;
extern CoprocessorServiceRequestDefaultTypeInternal _CoprocessorServiceRequest_default_instance_;
class CoprocessorServiceResponse;
class CoprocessorServiceResponseDefaultTypeInternal;
extern CoprocessorServiceResponseDefaultTypeInternal _CoprocessorServiceResponse_default_instance_;
class CoprocessorServiceResult;
class CoprocessorServiceResultDefaultTypeInternal;
extern CoprocessorServiceResultDefaultTypeInternal _CoprocessorServiceResult_default_instance_;
class Cursor;
class CursorDefaultTypeInternal;
extern CursorDefaultTypeInternal _Cursor_default_instance_;
class DelegationToken;
class DelegationTokenDefaultTypeInternal;
extern DelegationTokenDefaultTypeInternal _DelegationToken_default_instance_;
class Get;
class GetDefaultTypeInternal;
extern GetDefaultTypeInternal _Get_default_instance_;
class GetRequest;
class GetRequestDefaultTypeInternal;
extern GetRequestDefaultTypeInternal _GetRequest_default_instance_;
class GetResponse;
class GetResponseDefaultTypeInternal;
extern GetResponseDefaultTypeInternal _GetResponse_default_instance_;
class MultiRegionLoadStats;
class MultiRegionLoadStatsDefaultTypeInternal;
extern MultiRegionLoadStatsDefaultTypeInternal _MultiRegionLoadStats_default_instance_;
class MultiRequest;
class MultiRequestDefaultTypeInternal;
extern MultiRequestDefaultTypeInternal _MultiRequest_default_instance_;
class MultiResponse;
class MultiResponseDefaultTypeInternal;
extern MultiResponseDefaultTypeInternal _MultiResponse_default_instance_;
class MutateRequest;
class MutateRequestDefaultTypeInternal;
extern MutateRequestDefaultTypeInternal _MutateRequest_default_instance_;
class MutateResponse;
class MutateResponseDefaultTypeInternal;
extern MutateResponseDefaultTypeInternal _MutateResponse_default_instance_;
class MutationProto;
class MutationProtoDefaultTypeInternal;
extern MutationProtoDefaultTypeInternal _MutationProto_default_instance_;
class MutationProto_ColumnValue;
class MutationProto_ColumnValueDefaultTypeInternal;
extern MutationProto_ColumnValueDefaultTypeInternal _MutationProto_ColumnValue_default_instance_;
class MutationProto_ColumnValue_QualifierValue;
class MutationProto_ColumnValue_QualifierValueDefaultTypeInternal;
extern MutationProto_ColumnValue_QualifierValueDefaultTypeInternal _MutationProto_ColumnValue_QualifierValue_default_instance_;
class PrepareBulkLoadRequest;
class PrepareBulkLoadRequestDefaultTypeInternal;
extern PrepareBulkLoadRequestDefaultTypeInternal _PrepareBulkLoadRequest_default_instance_;
class PrepareBulkLoadResponse;
class PrepareBulkLoadResponseDefaultTypeInternal;
extern PrepareBulkLoadResponseDefaultTypeInternal _PrepareBulkLoadResponse_default_instance_;
class RegionAction;
class RegionActionDefaultTypeInternal;
extern RegionActionDefaultTypeInternal _RegionAction_default_instance_;
class RegionActionResult;
class RegionActionResultDefaultTypeInternal;
extern RegionActionResultDefaultTypeInternal _RegionActionResult_default_instance_;
class RegionLoadStats;
class RegionLoadStatsDefaultTypeInternal;
extern RegionLoadStatsDefaultTypeInternal _RegionLoadStats_default_instance_;
class Result;
class ResultDefaultTypeInternal;
extern ResultDefaultTypeInternal _Result_default_instance_;
class ResultOrException;
class ResultOrExceptionDefaultTypeInternal;
extern ResultOrExceptionDefaultTypeInternal _ResultOrException_default_instance_;
class Scan;
class ScanDefaultTypeInternal;
extern ScanDefaultTypeInternal _Scan_default_instance_;
class ScanRequest;
class ScanRequestDefaultTypeInternal;
extern ScanRequestDefaultTypeInternal _ScanRequest_default_instance_;
class ScanResponse;
class ScanResponseDefaultTypeInternal;
extern ScanResponseDefaultTypeInternal _ScanResponse_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::Action* Arena::CreateMaybeMessage<::hbase::pb::Action>(Arena*);
template<> ::hbase::pb::Authorizations* Arena::CreateMaybeMessage<::hbase::pb::Authorizations>(Arena*);
template<> ::hbase::pb::BulkLoadHFileRequest* Arena::CreateMaybeMessage<::hbase::pb::BulkLoadHFileRequest>(Arena*);
template<> ::hbase::pb::BulkLoadHFileRequest_FamilyPath* Arena::CreateMaybeMessage<::hbase::pb::BulkLoadHFileRequest_FamilyPath>(Arena*);
template<> ::hbase::pb::BulkLoadHFileResponse* Arena::CreateMaybeMessage<::hbase::pb::BulkLoadHFileResponse>(Arena*);
template<> ::hbase::pb::CellVisibility* Arena::CreateMaybeMessage<::hbase::pb::CellVisibility>(Arena*);
template<> ::hbase::pb::CleanupBulkLoadRequest* Arena::CreateMaybeMessage<::hbase::pb::CleanupBulkLoadRequest>(Arena*);
template<> ::hbase::pb::CleanupBulkLoadResponse* Arena::CreateMaybeMessage<::hbase::pb::CleanupBulkLoadResponse>(Arena*);
template<> ::hbase::pb::Column* Arena::CreateMaybeMessage<::hbase::pb::Column>(Arena*);
template<> ::hbase::pb::Condition* Arena::CreateMaybeMessage<::hbase::pb::Condition>(Arena*);
template<> ::hbase::pb::CoprocessorServiceCall* Arena::CreateMaybeMessage<::hbase::pb::CoprocessorServiceCall>(Arena*);
template<> ::hbase::pb::CoprocessorServiceRequest* Arena::CreateMaybeMessage<::hbase::pb::CoprocessorServiceRequest>(Arena*);
template<> ::hbase::pb::CoprocessorServiceResponse* Arena::CreateMaybeMessage<::hbase::pb::CoprocessorServiceResponse>(Arena*);
template<> ::hbase::pb::CoprocessorServiceResult* Arena::CreateMaybeMessage<::hbase::pb::CoprocessorServiceResult>(Arena*);
template<> ::hbase::pb::Cursor* Arena::CreateMaybeMessage<::hbase::pb::Cursor>(Arena*);
template<> ::hbase::pb::DelegationToken* Arena::CreateMaybeMessage<::hbase::pb::DelegationToken>(Arena*);
template<> ::hbase::pb::Get* Arena::CreateMaybeMessage<::hbase::pb::Get>(Arena*);
template<> ::hbase::pb::GetRequest* Arena::CreateMaybeMessage<::hbase::pb::GetRequest>(Arena*);
template<> ::hbase::pb::GetResponse* Arena::CreateMaybeMessage<::hbase::pb::GetResponse>(Arena*);
template<> ::hbase::pb::MultiRegionLoadStats* Arena::CreateMaybeMessage<::hbase::pb::MultiRegionLoadStats>(Arena*);
template<> ::hbase::pb::MultiRequest* Arena::CreateMaybeMessage<::hbase::pb::MultiRequest>(Arena*);
template<> ::hbase::pb::MultiResponse* Arena::CreateMaybeMessage<::hbase::pb::MultiResponse>(Arena*);
template<> ::hbase::pb::MutateRequest* Arena::CreateMaybeMessage<::hbase::pb::MutateRequest>(Arena*);
template<> ::hbase::pb::MutateResponse* Arena::CreateMaybeMessage<::hbase::pb::MutateResponse>(Arena*);
template<> ::hbase::pb::MutationProto* Arena::CreateMaybeMessage<::hbase::pb::MutationProto>(Arena*);
template<> ::hbase::pb::MutationProto_ColumnValue* Arena::CreateMaybeMessage<::hbase::pb::MutationProto_ColumnValue>(Arena*);
template<> ::hbase::pb::MutationProto_ColumnValue_QualifierValue* Arena::CreateMaybeMessage<::hbase::pb::MutationProto_ColumnValue_QualifierValue>(Arena*);
template<> ::hbase::pb::PrepareBulkLoadRequest* Arena::CreateMaybeMessage<::hbase::pb::PrepareBulkLoadRequest>(Arena*);
template<> ::hbase::pb::PrepareBulkLoadResponse* Arena::CreateMaybeMessage<::hbase::pb::PrepareBulkLoadResponse>(Arena*);
template<> ::hbase::pb::RegionAction* Arena::CreateMaybeMessage<::hbase::pb::RegionAction>(Arena*);
template<> ::hbase::pb::RegionActionResult* Arena::CreateMaybeMessage<::hbase::pb::RegionActionResult>(Arena*);
template<> ::hbase::pb::RegionLoadStats* Arena::CreateMaybeMessage<::hbase::pb::RegionLoadStats>(Arena*);
template<> ::hbase::pb::Result* Arena::CreateMaybeMessage<::hbase::pb::Result>(Arena*);
template<> ::hbase::pb::ResultOrException* Arena::CreateMaybeMessage<::hbase::pb::ResultOrException>(Arena*);
template<> ::hbase::pb::Scan* Arena::CreateMaybeMessage<::hbase::pb::Scan>(Arena*);
template<> ::hbase::pb::ScanRequest* Arena::CreateMaybeMessage<::hbase::pb::ScanRequest>(Arena*);
template<> ::hbase::pb::ScanResponse* Arena::CreateMaybeMessage<::hbase::pb::ScanResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum MutationProto_Durability : int {
  MutationProto_Durability_USE_DEFAULT = 0,
  MutationProto_Durability_SKIP_WAL = 1,
  MutationProto_Durability_ASYNC_WAL = 2,
  MutationProto_Durability_SYNC_WAL = 3,
  MutationProto_Durability_FSYNC_WAL = 4
};
bool MutationProto_Durability_IsValid(int value);
constexpr MutationProto_Durability MutationProto_Durability_Durability_MIN = MutationProto_Durability_USE_DEFAULT;
constexpr MutationProto_Durability MutationProto_Durability_Durability_MAX = MutationProto_Durability_FSYNC_WAL;
constexpr int MutationProto_Durability_Durability_ARRAYSIZE = MutationProto_Durability_Durability_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MutationProto_Durability_descriptor();
template<typename T>
inline const std::string& MutationProto_Durability_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MutationProto_Durability>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MutationProto_Durability_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MutationProto_Durability_descriptor(), enum_t_value);
}
inline bool MutationProto_Durability_Parse(
    const std::string& name, MutationProto_Durability* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MutationProto_Durability>(
    MutationProto_Durability_descriptor(), name, value);
}
enum MutationProto_MutationType : int {
  MutationProto_MutationType_APPEND = 0,
  MutationProto_MutationType_INCREMENT = 1,
  MutationProto_MutationType_PUT = 2,
  MutationProto_MutationType_DELETE = 3
};
bool MutationProto_MutationType_IsValid(int value);
constexpr MutationProto_MutationType MutationProto_MutationType_MutationType_MIN = MutationProto_MutationType_APPEND;
constexpr MutationProto_MutationType MutationProto_MutationType_MutationType_MAX = MutationProto_MutationType_DELETE;
constexpr int MutationProto_MutationType_MutationType_ARRAYSIZE = MutationProto_MutationType_MutationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MutationProto_MutationType_descriptor();
template<typename T>
inline const std::string& MutationProto_MutationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MutationProto_MutationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MutationProto_MutationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MutationProto_MutationType_descriptor(), enum_t_value);
}
inline bool MutationProto_MutationType_Parse(
    const std::string& name, MutationProto_MutationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MutationProto_MutationType>(
    MutationProto_MutationType_descriptor(), name, value);
}
enum MutationProto_DeleteType : int {
  MutationProto_DeleteType_DELETE_ONE_VERSION = 0,
  MutationProto_DeleteType_DELETE_MULTIPLE_VERSIONS = 1,
  MutationProto_DeleteType_DELETE_FAMILY = 2,
  MutationProto_DeleteType_DELETE_FAMILY_VERSION = 3
};
bool MutationProto_DeleteType_IsValid(int value);
constexpr MutationProto_DeleteType MutationProto_DeleteType_DeleteType_MIN = MutationProto_DeleteType_DELETE_ONE_VERSION;
constexpr MutationProto_DeleteType MutationProto_DeleteType_DeleteType_MAX = MutationProto_DeleteType_DELETE_FAMILY_VERSION;
constexpr int MutationProto_DeleteType_DeleteType_ARRAYSIZE = MutationProto_DeleteType_DeleteType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MutationProto_DeleteType_descriptor();
template<typename T>
inline const std::string& MutationProto_DeleteType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MutationProto_DeleteType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MutationProto_DeleteType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MutationProto_DeleteType_descriptor(), enum_t_value);
}
inline bool MutationProto_DeleteType_Parse(
    const std::string& name, MutationProto_DeleteType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MutationProto_DeleteType>(
    MutationProto_DeleteType_descriptor(), name, value);
}
enum Scan_ReadType : int {
  Scan_ReadType_DEFAULT = 0,
  Scan_ReadType_STREAM = 1,
  Scan_ReadType_PREAD = 2
};
bool Scan_ReadType_IsValid(int value);
constexpr Scan_ReadType Scan_ReadType_ReadType_MIN = Scan_ReadType_DEFAULT;
constexpr Scan_ReadType Scan_ReadType_ReadType_MAX = Scan_ReadType_PREAD;
constexpr int Scan_ReadType_ReadType_ARRAYSIZE = Scan_ReadType_ReadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Scan_ReadType_descriptor();
template<typename T>
inline const std::string& Scan_ReadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Scan_ReadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Scan_ReadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Scan_ReadType_descriptor(), enum_t_value);
}
inline bool Scan_ReadType_Parse(
    const std::string& name, Scan_ReadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Scan_ReadType>(
    Scan_ReadType_descriptor(), name, value);
}
enum Consistency : int {
  STRONG = 0,
  TIMELINE = 1
};
bool Consistency_IsValid(int value);
constexpr Consistency Consistency_MIN = STRONG;
constexpr Consistency Consistency_MAX = TIMELINE;
constexpr int Consistency_ARRAYSIZE = Consistency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Consistency_descriptor();
template<typename T>
inline const std::string& Consistency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Consistency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Consistency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Consistency_descriptor(), enum_t_value);
}
inline bool Consistency_Parse(
    const std::string& name, Consistency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Consistency>(
    Consistency_descriptor(), name, value);
}
// ===================================================================

class Authorizations :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Authorizations) */ {
 public:
  Authorizations();
  virtual ~Authorizations();

  Authorizations(const Authorizations& from);
  Authorizations(Authorizations&& from) noexcept
    : Authorizations() {
    *this = ::std::move(from);
  }

  inline Authorizations& operator=(const Authorizations& from) {
    CopyFrom(from);
    return *this;
  }
  inline Authorizations& operator=(Authorizations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Authorizations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Authorizations* internal_default_instance() {
    return reinterpret_cast<const Authorizations*>(
               &_Authorizations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Authorizations& a, Authorizations& b) {
    a.Swap(&b);
  }
  inline void Swap(Authorizations* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Authorizations* New() const final {
    return CreateMaybeMessage<Authorizations>(nullptr);
  }

  Authorizations* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Authorizations>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Authorizations& from);
  void MergeFrom(const Authorizations& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Authorizations* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Authorizations";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLabelFieldNumber = 1,
  };
  // repeated string label = 1;
  int label_size() const;
  void clear_label();
  const std::string& label(int index) const;
  std::string* mutable_label(int index);
  void set_label(int index, const std::string& value);
  void set_label(int index, std::string&& value);
  void set_label(int index, const char* value);
  void set_label(int index, const char* value, size_t size);
  std::string* add_label();
  void add_label(const std::string& value);
  void add_label(std::string&& value);
  void add_label(const char* value);
  void add_label(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& label() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_label();

  // @@protoc_insertion_point(class_scope:hbase.pb.Authorizations)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> label_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CellVisibility :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CellVisibility) */ {
 public:
  CellVisibility();
  virtual ~CellVisibility();

  CellVisibility(const CellVisibility& from);
  CellVisibility(CellVisibility&& from) noexcept
    : CellVisibility() {
    *this = ::std::move(from);
  }

  inline CellVisibility& operator=(const CellVisibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline CellVisibility& operator=(CellVisibility&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CellVisibility& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CellVisibility* internal_default_instance() {
    return reinterpret_cast<const CellVisibility*>(
               &_CellVisibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CellVisibility& a, CellVisibility& b) {
    a.Swap(&b);
  }
  inline void Swap(CellVisibility* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CellVisibility* New() const final {
    return CreateMaybeMessage<CellVisibility>(nullptr);
  }

  CellVisibility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CellVisibility>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CellVisibility& from);
  void MergeFrom(const CellVisibility& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CellVisibility* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CellVisibility";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExpressionFieldNumber = 1,
  };
  // required string expression = 1;
  bool has_expression() const;
  void clear_expression();
  const std::string& expression() const;
  void set_expression(const std::string& value);
  void set_expression(std::string&& value);
  void set_expression(const char* value);
  void set_expression(const char* value, size_t size);
  std::string* mutable_expression();
  std::string* release_expression();
  void set_allocated_expression(std::string* expression);

  // @@protoc_insertion_point(class_scope:hbase.pb.CellVisibility)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expression_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Column :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Column) */ {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);
  Column(Column&& from) noexcept
    : Column() {
    *this = ::std::move(from);
  }

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }
  inline Column& operator=(Column&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Column& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Column* internal_default_instance() {
    return reinterpret_cast<const Column*>(
               &_Column_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Column& a, Column& b) {
    a.Swap(&b);
  }
  inline void Swap(Column* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Column* New() const final {
    return CreateMaybeMessage<Column>(nullptr);
  }

  Column* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Column>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Column* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Column";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualifierFieldNumber = 2,
    kFamilyFieldNumber = 1,
  };
  // repeated bytes qualifier = 2;
  int qualifier_size() const;
  void clear_qualifier();
  const std::string& qualifier(int index) const;
  std::string* mutable_qualifier(int index);
  void set_qualifier(int index, const std::string& value);
  void set_qualifier(int index, std::string&& value);
  void set_qualifier(int index, const char* value);
  void set_qualifier(int index, const void* value, size_t size);
  std::string* add_qualifier();
  void add_qualifier(const std::string& value);
  void add_qualifier(std::string&& value);
  void add_qualifier(const char* value);
  void add_qualifier(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& qualifier() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_qualifier();

  // required bytes family = 1;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // @@protoc_insertion_point(class_scope:hbase.pb.Column)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> qualifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Get :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Get) */ {
 public:
  Get();
  virtual ~Get();

  Get(const Get& from);
  Get(Get&& from) noexcept
    : Get() {
    *this = ::std::move(from);
  }

  inline Get& operator=(const Get& from) {
    CopyFrom(from);
    return *this;
  }
  inline Get& operator=(Get&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Get& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Get* internal_default_instance() {
    return reinterpret_cast<const Get*>(
               &_Get_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Get& a, Get& b) {
    a.Swap(&b);
  }
  inline void Swap(Get* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Get* New() const final {
    return CreateMaybeMessage<Get>(nullptr);
  }

  Get* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Get>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Get& from);
  void MergeFrom(const Get& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Get* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Get";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 2,
    kAttributeFieldNumber = 3,
    kCfTimeRangeFieldNumber = 13,
    kRowFieldNumber = 1,
    kFilterFieldNumber = 4,
    kTimeRangeFieldNumber = 5,
    kStoreLimitFieldNumber = 8,
    kStoreOffsetFieldNumber = 9,
    kExistenceOnlyFieldNumber = 10,
    kClosestRowBeforeFieldNumber = 11,
    kLoadColumnFamiliesOnDemandFieldNumber = 14,
    kConsistencyFieldNumber = 12,
    kMaxVersionsFieldNumber = 6,
    kCacheBlocksFieldNumber = 7,
  };
  // repeated .hbase.pb.Column column = 2;
  int column_size() const;
  void clear_column();
  ::hbase::pb::Column* mutable_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >*
      mutable_column();
  const ::hbase::pb::Column& column(int index) const;
  ::hbase::pb::Column* add_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >&
      column() const;

  // repeated .hbase.pb.NameBytesPair attribute = 3;
  int attribute_size() const;
  void clear_attribute();
  ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();
  const ::hbase::pb::NameBytesPair& attribute(int index) const;
  ::hbase::pb::NameBytesPair* add_attribute();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;

  // repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 13;
  int cf_time_range_size() const;
  void clear_cf_time_range();
  ::hbase::pb::ColumnFamilyTimeRange* mutable_cf_time_range(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
      mutable_cf_time_range();
  const ::hbase::pb::ColumnFamilyTimeRange& cf_time_range(int index) const;
  ::hbase::pb::ColumnFamilyTimeRange* add_cf_time_range();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
      cf_time_range() const;

  // required bytes row = 1;
  bool has_row() const;
  void clear_row();
  const std::string& row() const;
  void set_row(const std::string& value);
  void set_row(std::string&& value);
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  std::string* mutable_row();
  std::string* release_row();
  void set_allocated_row(std::string* row);

  // optional .hbase.pb.Filter filter = 4;
  bool has_filter() const;
  void clear_filter();
  const ::hbase::pb::Filter& filter() const;
  ::hbase::pb::Filter* release_filter();
  ::hbase::pb::Filter* mutable_filter();
  void set_allocated_filter(::hbase::pb::Filter* filter);

  // optional .hbase.pb.TimeRange time_range = 5;
  bool has_time_range() const;
  void clear_time_range();
  const ::hbase::pb::TimeRange& time_range() const;
  ::hbase::pb::TimeRange* release_time_range();
  ::hbase::pb::TimeRange* mutable_time_range();
  void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional uint32 store_limit = 8;
  bool has_store_limit() const;
  void clear_store_limit();
  ::PROTOBUF_NAMESPACE_ID::uint32 store_limit() const;
  void set_store_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 store_offset = 9;
  bool has_store_offset() const;
  void clear_store_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 store_offset() const;
  void set_store_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool existence_only = 10 [default = false];
  bool has_existence_only() const;
  void clear_existence_only();
  bool existence_only() const;
  void set_existence_only(bool value);

  // optional bool closest_row_before = 11 [default = false];
  bool has_closest_row_before() const;
  void clear_closest_row_before();
  bool closest_row_before() const;
  void set_closest_row_before(bool value);

  // optional bool load_column_families_on_demand = 14;
  bool has_load_column_families_on_demand() const;
  void clear_load_column_families_on_demand();
  bool load_column_families_on_demand() const;
  void set_load_column_families_on_demand(bool value);

  // optional .hbase.pb.Consistency consistency = 12 [default = STRONG];
  bool has_consistency() const;
  void clear_consistency();
  ::hbase::pb::Consistency consistency() const;
  void set_consistency(::hbase::pb::Consistency value);

  // optional uint32 max_versions = 6 [default = 1];
  bool has_max_versions() const;
  void clear_max_versions();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_versions() const;
  void set_max_versions(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool cache_blocks = 7 [default = true];
  bool has_cache_blocks() const;
  void clear_cache_blocks();
  bool cache_blocks() const;
  void set_cache_blocks(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Get)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column > column_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange > cf_time_range_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
  ::hbase::pb::Filter* filter_;
  ::hbase::pb::TimeRange* time_range_;
  ::PROTOBUF_NAMESPACE_ID::uint32 store_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 store_offset_;
  bool existence_only_;
  bool closest_row_before_;
  bool load_column_families_on_demand_;
  int consistency_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_versions_;
  bool cache_blocks_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Result :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Result) */ {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);
  Result(Result&& from) noexcept
    : Result() {
    *this = ::std::move(from);
  }

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline Result& operator=(Result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Result* internal_default_instance() {
    return reinterpret_cast<const Result*>(
               &_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Result& a, Result& b) {
    a.Swap(&b);
  }
  inline void Swap(Result* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Result* New() const final {
    return CreateMaybeMessage<Result>(nullptr);
  }

  Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Result>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Result";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellFieldNumber = 1,
    kAssociatedCellCountFieldNumber = 2,
    kExistsFieldNumber = 3,
    kStaleFieldNumber = 4,
    kPartialFieldNumber = 5,
  };
  // repeated .hbase.pb.Cell cell = 1;
  int cell_size() const;
  void clear_cell();
  ::hbase::pb::Cell* mutable_cell(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Cell >*
      mutable_cell();
  const ::hbase::pb::Cell& cell(int index) const;
  ::hbase::pb::Cell* add_cell();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Cell >&
      cell() const;

  // optional int32 associated_cell_count = 2;
  bool has_associated_cell_count() const;
  void clear_associated_cell_count();
  ::PROTOBUF_NAMESPACE_ID::int32 associated_cell_count() const;
  void set_associated_cell_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional bool exists = 3;
  bool has_exists() const;
  void clear_exists();
  bool exists() const;
  void set_exists(bool value);

  // optional bool stale = 4 [default = false];
  bool has_stale() const;
  void clear_stale();
  bool stale() const;
  void set_stale(bool value);

  // optional bool partial = 5 [default = false];
  bool has_partial() const;
  void clear_partial();
  bool partial() const;
  void set_partial(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Result)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Cell > cell_;
  ::PROTOBUF_NAMESPACE_ID::int32 associated_cell_count_;
  bool exists_;
  bool stale_;
  bool partial_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class GetRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GetRequest) */ {
 public:
  GetRequest();
  virtual ~GetRequest();

  GetRequest(const GetRequest& from);
  GetRequest(GetRequest&& from) noexcept
    : GetRequest() {
    *this = ::std::move(from);
  }

  inline GetRequest& operator=(const GetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetRequest& operator=(GetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRequest* internal_default_instance() {
    return reinterpret_cast<const GetRequest*>(
               &_GetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetRequest& a, GetRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetRequest* New() const final {
    return CreateMaybeMessage<GetRequest>(nullptr);
  }

  GetRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetRequest& from);
  void MergeFrom(const GetRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GetRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kGetFieldNumber = 2,
  };
  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.Get get = 2;
  bool has_get() const;
  void clear_get();
  const ::hbase::pb::Get& get() const;
  ::hbase::pb::Get* release_get();
  ::hbase::pb::Get* mutable_get();
  void set_allocated_get(::hbase::pb::Get* get);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::Get* get_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class GetResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.GetResponse) */ {
 public:
  GetResponse();
  virtual ~GetResponse();

  GetResponse(const GetResponse& from);
  GetResponse(GetResponse&& from) noexcept
    : GetResponse() {
    *this = ::std::move(from);
  }

  inline GetResponse& operator=(const GetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetResponse& operator=(GetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetResponse* internal_default_instance() {
    return reinterpret_cast<const GetResponse*>(
               &_GetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetResponse& a, GetResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetResponse* New() const final {
    return CreateMaybeMessage<GetResponse>(nullptr);
  }

  GetResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetResponse& from);
  void MergeFrom(const GetResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.GetResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // optional .hbase.pb.Result result = 1;
  bool has_result() const;
  void clear_result();
  const ::hbase::pb::Result& result() const;
  ::hbase::pb::Result* release_result();
  ::hbase::pb::Result* mutable_result();
  void set_allocated_result(::hbase::pb::Result* result);

  // @@protoc_insertion_point(class_scope:hbase.pb.GetResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Result* result_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Condition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }
  inline void Swap(Condition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Condition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kFamilyFieldNumber = 2,
    kQualifierFieldNumber = 3,
    kComparatorFieldNumber = 5,
    kTimeRangeFieldNumber = 6,
    kCompareTypeFieldNumber = 4,
  };
  // required bytes row = 1;
  bool has_row() const;
  void clear_row();
  const std::string& row() const;
  void set_row(const std::string& value);
  void set_row(std::string&& value);
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  std::string* mutable_row();
  std::string* release_row();
  void set_allocated_row(std::string* row);

  // required bytes family = 2;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // required bytes qualifier = 3;
  bool has_qualifier() const;
  void clear_qualifier();
  const std::string& qualifier() const;
  void set_qualifier(const std::string& value);
  void set_qualifier(std::string&& value);
  void set_qualifier(const char* value);
  void set_qualifier(const void* value, size_t size);
  std::string* mutable_qualifier();
  std::string* release_qualifier();
  void set_allocated_qualifier(std::string* qualifier);

  // required .hbase.pb.Comparator comparator = 5;
  bool has_comparator() const;
  void clear_comparator();
  const ::hbase::pb::Comparator& comparator() const;
  ::hbase::pb::Comparator* release_comparator();
  ::hbase::pb::Comparator* mutable_comparator();
  void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // optional .hbase.pb.TimeRange time_range = 6;
  bool has_time_range() const;
  void clear_time_range();
  const ::hbase::pb::TimeRange& time_range() const;
  ::hbase::pb::TimeRange* release_time_range();
  ::hbase::pb::TimeRange* mutable_time_range();
  void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // required .hbase.pb.CompareType compare_type = 4;
  bool has_compare_type() const;
  void clear_compare_type();
  ::hbase::pb::CompareType compare_type() const;
  void set_compare_type(::hbase::pb::CompareType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Condition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualifier_;
  ::hbase::pb::Comparator* comparator_;
  ::hbase::pb::TimeRange* time_range_;
  int compare_type_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MutationProto_ColumnValue_QualifierValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MutationProto.ColumnValue.QualifierValue) */ {
 public:
  MutationProto_ColumnValue_QualifierValue();
  virtual ~MutationProto_ColumnValue_QualifierValue();

  MutationProto_ColumnValue_QualifierValue(const MutationProto_ColumnValue_QualifierValue& from);
  MutationProto_ColumnValue_QualifierValue(MutationProto_ColumnValue_QualifierValue&& from) noexcept
    : MutationProto_ColumnValue_QualifierValue() {
    *this = ::std::move(from);
  }

  inline MutationProto_ColumnValue_QualifierValue& operator=(const MutationProto_ColumnValue_QualifierValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationProto_ColumnValue_QualifierValue& operator=(MutationProto_ColumnValue_QualifierValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutationProto_ColumnValue_QualifierValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MutationProto_ColumnValue_QualifierValue* internal_default_instance() {
    return reinterpret_cast<const MutationProto_ColumnValue_QualifierValue*>(
               &_MutationProto_ColumnValue_QualifierValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MutationProto_ColumnValue_QualifierValue& a, MutationProto_ColumnValue_QualifierValue& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationProto_ColumnValue_QualifierValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutationProto_ColumnValue_QualifierValue* New() const final {
    return CreateMaybeMessage<MutationProto_ColumnValue_QualifierValue>(nullptr);
  }

  MutationProto_ColumnValue_QualifierValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutationProto_ColumnValue_QualifierValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutationProto_ColumnValue_QualifierValue& from);
  void MergeFrom(const MutationProto_ColumnValue_QualifierValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationProto_ColumnValue_QualifierValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MutationProto.ColumnValue.QualifierValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualifierFieldNumber = 1,
    kValueFieldNumber = 2,
    kTagsFieldNumber = 5,
    kTimestampFieldNumber = 3,
    kDeleteTypeFieldNumber = 4,
  };
  // optional bytes qualifier = 1;
  bool has_qualifier() const;
  void clear_qualifier();
  const std::string& qualifier() const;
  void set_qualifier(const std::string& value);
  void set_qualifier(std::string&& value);
  void set_qualifier(const char* value);
  void set_qualifier(const void* value, size_t size);
  std::string* mutable_qualifier();
  std::string* release_qualifier();
  void set_allocated_qualifier(std::string* qualifier);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // optional bytes tags = 5;
  bool has_tags() const;
  void clear_tags();
  const std::string& tags() const;
  void set_tags(const std::string& value);
  void set_tags(std::string&& value);
  void set_tags(const char* value);
  void set_tags(const void* value, size_t size);
  std::string* mutable_tags();
  std::string* release_tags();
  void set_allocated_tags(std::string* tags);

  // optional uint64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .hbase.pb.MutationProto.DeleteType delete_type = 4;
  bool has_delete_type() const;
  void clear_delete_type();
  ::hbase::pb::MutationProto_DeleteType delete_type() const;
  void set_delete_type(::hbase::pb::MutationProto_DeleteType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto.ColumnValue.QualifierValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  int delete_type_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MutationProto_ColumnValue :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MutationProto.ColumnValue) */ {
 public:
  MutationProto_ColumnValue();
  virtual ~MutationProto_ColumnValue();

  MutationProto_ColumnValue(const MutationProto_ColumnValue& from);
  MutationProto_ColumnValue(MutationProto_ColumnValue&& from) noexcept
    : MutationProto_ColumnValue() {
    *this = ::std::move(from);
  }

  inline MutationProto_ColumnValue& operator=(const MutationProto_ColumnValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationProto_ColumnValue& operator=(MutationProto_ColumnValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutationProto_ColumnValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MutationProto_ColumnValue* internal_default_instance() {
    return reinterpret_cast<const MutationProto_ColumnValue*>(
               &_MutationProto_ColumnValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MutationProto_ColumnValue& a, MutationProto_ColumnValue& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationProto_ColumnValue* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutationProto_ColumnValue* New() const final {
    return CreateMaybeMessage<MutationProto_ColumnValue>(nullptr);
  }

  MutationProto_ColumnValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutationProto_ColumnValue>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutationProto_ColumnValue& from);
  void MergeFrom(const MutationProto_ColumnValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationProto_ColumnValue* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MutationProto.ColumnValue";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MutationProto_ColumnValue_QualifierValue QualifierValue;

  // accessors -------------------------------------------------------

  enum : int {
    kQualifierValueFieldNumber = 2,
    kFamilyFieldNumber = 1,
  };
  // repeated .hbase.pb.MutationProto.ColumnValue.QualifierValue qualifier_value = 2;
  int qualifier_value_size() const;
  void clear_qualifier_value();
  ::hbase::pb::MutationProto_ColumnValue_QualifierValue* mutable_qualifier_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >*
      mutable_qualifier_value();
  const ::hbase::pb::MutationProto_ColumnValue_QualifierValue& qualifier_value(int index) const;
  ::hbase::pb::MutationProto_ColumnValue_QualifierValue* add_qualifier_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >&
      qualifier_value() const;

  // required bytes family = 1;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto.ColumnValue)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue > qualifier_value_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MutationProto :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MutationProto) */ {
 public:
  MutationProto();
  virtual ~MutationProto();

  MutationProto(const MutationProto& from);
  MutationProto(MutationProto&& from) noexcept
    : MutationProto() {
    *this = ::std::move(from);
  }

  inline MutationProto& operator=(const MutationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutationProto& operator=(MutationProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutationProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MutationProto* internal_default_instance() {
    return reinterpret_cast<const MutationProto*>(
               &_MutationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(MutationProto& a, MutationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(MutationProto* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutationProto* New() const final {
    return CreateMaybeMessage<MutationProto>(nullptr);
  }

  MutationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutationProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutationProto& from);
  void MergeFrom(const MutationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutationProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MutationProto";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef MutationProto_ColumnValue ColumnValue;

  typedef MutationProto_Durability Durability;
  static constexpr Durability USE_DEFAULT =
    MutationProto_Durability_USE_DEFAULT;
  static constexpr Durability SKIP_WAL =
    MutationProto_Durability_SKIP_WAL;
  static constexpr Durability ASYNC_WAL =
    MutationProto_Durability_ASYNC_WAL;
  static constexpr Durability SYNC_WAL =
    MutationProto_Durability_SYNC_WAL;
  static constexpr Durability FSYNC_WAL =
    MutationProto_Durability_FSYNC_WAL;
  static inline bool Durability_IsValid(int value) {
    return MutationProto_Durability_IsValid(value);
  }
  static constexpr Durability Durability_MIN =
    MutationProto_Durability_Durability_MIN;
  static constexpr Durability Durability_MAX =
    MutationProto_Durability_Durability_MAX;
  static constexpr int Durability_ARRAYSIZE =
    MutationProto_Durability_Durability_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Durability_descriptor() {
    return MutationProto_Durability_descriptor();
  }
  template<typename T>
  static inline const std::string& Durability_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Durability>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Durability_Name.");
    return MutationProto_Durability_Name(enum_t_value);
  }
  static inline bool Durability_Parse(const std::string& name,
      Durability* value) {
    return MutationProto_Durability_Parse(name, value);
  }

  typedef MutationProto_MutationType MutationType;
  static constexpr MutationType APPEND =
    MutationProto_MutationType_APPEND;
  static constexpr MutationType INCREMENT =
    MutationProto_MutationType_INCREMENT;
  static constexpr MutationType PUT =
    MutationProto_MutationType_PUT;
  static constexpr MutationType DELETE =
    MutationProto_MutationType_DELETE;
  static inline bool MutationType_IsValid(int value) {
    return MutationProto_MutationType_IsValid(value);
  }
  static constexpr MutationType MutationType_MIN =
    MutationProto_MutationType_MutationType_MIN;
  static constexpr MutationType MutationType_MAX =
    MutationProto_MutationType_MutationType_MAX;
  static constexpr int MutationType_ARRAYSIZE =
    MutationProto_MutationType_MutationType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MutationType_descriptor() {
    return MutationProto_MutationType_descriptor();
  }
  template<typename T>
  static inline const std::string& MutationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MutationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MutationType_Name.");
    return MutationProto_MutationType_Name(enum_t_value);
  }
  static inline bool MutationType_Parse(const std::string& name,
      MutationType* value) {
    return MutationProto_MutationType_Parse(name, value);
  }

  typedef MutationProto_DeleteType DeleteType;
  static constexpr DeleteType DELETE_ONE_VERSION =
    MutationProto_DeleteType_DELETE_ONE_VERSION;
  static constexpr DeleteType DELETE_MULTIPLE_VERSIONS =
    MutationProto_DeleteType_DELETE_MULTIPLE_VERSIONS;
  static constexpr DeleteType DELETE_FAMILY =
    MutationProto_DeleteType_DELETE_FAMILY;
  static constexpr DeleteType DELETE_FAMILY_VERSION =
    MutationProto_DeleteType_DELETE_FAMILY_VERSION;
  static inline bool DeleteType_IsValid(int value) {
    return MutationProto_DeleteType_IsValid(value);
  }
  static constexpr DeleteType DeleteType_MIN =
    MutationProto_DeleteType_DeleteType_MIN;
  static constexpr DeleteType DeleteType_MAX =
    MutationProto_DeleteType_DeleteType_MAX;
  static constexpr int DeleteType_ARRAYSIZE =
    MutationProto_DeleteType_DeleteType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DeleteType_descriptor() {
    return MutationProto_DeleteType_descriptor();
  }
  template<typename T>
  static inline const std::string& DeleteType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DeleteType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DeleteType_Name.");
    return MutationProto_DeleteType_Name(enum_t_value);
  }
  static inline bool DeleteType_Parse(const std::string& name,
      DeleteType* value) {
    return MutationProto_DeleteType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnValueFieldNumber = 3,
    kAttributeFieldNumber = 5,
    kRowFieldNumber = 1,
    kTimeRangeFieldNumber = 7,
    kTimestampFieldNumber = 4,
    kMutateTypeFieldNumber = 2,
    kDurabilityFieldNumber = 6,
    kNonceFieldNumber = 9,
    kAssociatedCellCountFieldNumber = 8,
  };
  // repeated .hbase.pb.MutationProto.ColumnValue column_value = 3;
  int column_value_size() const;
  void clear_column_value();
  ::hbase::pb::MutationProto_ColumnValue* mutable_column_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >*
      mutable_column_value();
  const ::hbase::pb::MutationProto_ColumnValue& column_value(int index) const;
  ::hbase::pb::MutationProto_ColumnValue* add_column_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >&
      column_value() const;

  // repeated .hbase.pb.NameBytesPair attribute = 5;
  int attribute_size() const;
  void clear_attribute();
  ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();
  const ::hbase::pb::NameBytesPair& attribute(int index) const;
  ::hbase::pb::NameBytesPair* add_attribute();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;

  // optional bytes row = 1;
  bool has_row() const;
  void clear_row();
  const std::string& row() const;
  void set_row(const std::string& value);
  void set_row(std::string&& value);
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  std::string* mutable_row();
  std::string* release_row();
  void set_allocated_row(std::string* row);

  // optional .hbase.pb.TimeRange time_range = 7;
  bool has_time_range() const;
  void clear_time_range();
  const ::hbase::pb::TimeRange& time_range() const;
  ::hbase::pb::TimeRange* release_time_range();
  ::hbase::pb::TimeRange* mutable_time_range();
  void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional uint64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .hbase.pb.MutationProto.MutationType mutate_type = 2;
  bool has_mutate_type() const;
  void clear_mutate_type();
  ::hbase::pb::MutationProto_MutationType mutate_type() const;
  void set_mutate_type(::hbase::pb::MutationProto_MutationType value);

  // optional .hbase.pb.MutationProto.Durability durability = 6 [default = USE_DEFAULT];
  bool has_durability() const;
  void clear_durability();
  ::hbase::pb::MutationProto_Durability durability() const;
  void set_durability(::hbase::pb::MutationProto_Durability value);

  // optional uint64 nonce = 9;
  bool has_nonce() const;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional int32 associated_cell_count = 8;
  bool has_associated_cell_count() const;
  void clear_associated_cell_count();
  ::PROTOBUF_NAMESPACE_ID::int32 associated_cell_count() const;
  void set_associated_cell_count(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutationProto)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue > column_value_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
  ::hbase::pb::TimeRange* time_range_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  int mutate_type_;
  int durability_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::int32 associated_cell_count_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MutateRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MutateRequest) */ {
 public:
  MutateRequest();
  virtual ~MutateRequest();

  MutateRequest(const MutateRequest& from);
  MutateRequest(MutateRequest&& from) noexcept
    : MutateRequest() {
    *this = ::std::move(from);
  }

  inline MutateRequest& operator=(const MutateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateRequest& operator=(MutateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MutateRequest* internal_default_instance() {
    return reinterpret_cast<const MutateRequest*>(
               &_MutateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(MutateRequest& a, MutateRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutateRequest* New() const final {
    return CreateMaybeMessage<MutateRequest>(nullptr);
  }

  MutateRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutateRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutateRequest& from);
  void MergeFrom(const MutateRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MutateRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kMutationFieldNumber = 2,
    kConditionFieldNumber = 3,
    kNonceGroupFieldNumber = 4,
  };
  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.MutationProto mutation = 2;
  bool has_mutation() const;
  void clear_mutation();
  const ::hbase::pb::MutationProto& mutation() const;
  ::hbase::pb::MutationProto* release_mutation();
  ::hbase::pb::MutationProto* mutable_mutation();
  void set_allocated_mutation(::hbase::pb::MutationProto* mutation);

  // optional .hbase.pb.Condition condition = 3;
  bool has_condition() const;
  void clear_condition();
  const ::hbase::pb::Condition& condition() const;
  ::hbase::pb::Condition* release_condition();
  ::hbase::pb::Condition* mutable_condition();
  void set_allocated_condition(::hbase::pb::Condition* condition);

  // optional uint64 nonce_group = 4;
  bool has_nonce_group() const;
  void clear_nonce_group();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_group() const;
  void set_nonce_group(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutateRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::MutationProto* mutation_;
  ::hbase::pb::Condition* condition_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_group_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MutateResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MutateResponse) */ {
 public:
  MutateResponse();
  virtual ~MutateResponse();

  MutateResponse(const MutateResponse& from);
  MutateResponse(MutateResponse&& from) noexcept
    : MutateResponse() {
    *this = ::std::move(from);
  }

  inline MutateResponse& operator=(const MutateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MutateResponse& operator=(MutateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MutateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MutateResponse* internal_default_instance() {
    return reinterpret_cast<const MutateResponse*>(
               &_MutateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MutateResponse& a, MutateResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MutateResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MutateResponse* New() const final {
    return CreateMaybeMessage<MutateResponse>(nullptr);
  }

  MutateResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MutateResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MutateResponse& from);
  void MergeFrom(const MutateResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MutateResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MutateResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kProcessedFieldNumber = 2,
  };
  // optional .hbase.pb.Result result = 1;
  bool has_result() const;
  void clear_result();
  const ::hbase::pb::Result& result() const;
  ::hbase::pb::Result* release_result();
  ::hbase::pb::Result* mutable_result();
  void set_allocated_result(::hbase::pb::Result* result);

  // optional bool processed = 2;
  bool has_processed() const;
  void clear_processed();
  bool processed() const;
  void set_processed(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MutateResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Result* result_;
  bool processed_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Scan :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Scan) */ {
 public:
  Scan();
  virtual ~Scan();

  Scan(const Scan& from);
  Scan(Scan&& from) noexcept
    : Scan() {
    *this = ::std::move(from);
  }

  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  inline Scan& operator=(Scan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Scan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Scan* internal_default_instance() {
    return reinterpret_cast<const Scan*>(
               &_Scan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Scan& a, Scan& b) {
    a.Swap(&b);
  }
  inline void Swap(Scan* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Scan* New() const final {
    return CreateMaybeMessage<Scan>(nullptr);
  }

  Scan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Scan>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Scan* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Scan";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Scan_ReadType ReadType;
  static constexpr ReadType DEFAULT =
    Scan_ReadType_DEFAULT;
  static constexpr ReadType STREAM =
    Scan_ReadType_STREAM;
  static constexpr ReadType PREAD =
    Scan_ReadType_PREAD;
  static inline bool ReadType_IsValid(int value) {
    return Scan_ReadType_IsValid(value);
  }
  static constexpr ReadType ReadType_MIN =
    Scan_ReadType_ReadType_MIN;
  static constexpr ReadType ReadType_MAX =
    Scan_ReadType_ReadType_MAX;
  static constexpr int ReadType_ARRAYSIZE =
    Scan_ReadType_ReadType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ReadType_descriptor() {
    return Scan_ReadType_descriptor();
  }
  template<typename T>
  static inline const std::string& ReadType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ReadType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ReadType_Name.");
    return Scan_ReadType_Name(enum_t_value);
  }
  static inline bool ReadType_Parse(const std::string& name,
      ReadType* value) {
    return Scan_ReadType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFieldNumber = 1,
    kAttributeFieldNumber = 2,
    kCfTimeRangeFieldNumber = 19,
    kStartRowFieldNumber = 3,
    kStopRowFieldNumber = 4,
    kFilterFieldNumber = 5,
    kTimeRangeFieldNumber = 6,
    kMaxResultSizeFieldNumber = 10,
    kBatchSizeFieldNumber = 9,
    kStoreLimitFieldNumber = 11,
    kStoreOffsetFieldNumber = 12,
    kLoadColumnFamiliesOnDemandFieldNumber = 13,
    kSmallFieldNumber = 14,
    kReversedFieldNumber = 15,
    kAllowPartialResultsFieldNumber = 18,
    kConsistencyFieldNumber = 16,
    kCachingFieldNumber = 17,
    kMvccReadPointFieldNumber = 20,
    kReadTypeFieldNumber = 23,
    kIncludeStopRowFieldNumber = 22,
    kNeedCursorResultFieldNumber = 24,
    kMaxVersionsFieldNumber = 7,
    kCacheBlocksFieldNumber = 8,
    kIncludeStartRowFieldNumber = 21,
  };
  // repeated .hbase.pb.Column column = 1;
  int column_size() const;
  void clear_column();
  ::hbase::pb::Column* mutable_column(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >*
      mutable_column();
  const ::hbase::pb::Column& column(int index) const;
  ::hbase::pb::Column* add_column();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >&
      column() const;

  // repeated .hbase.pb.NameBytesPair attribute = 2;
  int attribute_size() const;
  void clear_attribute();
  ::hbase::pb::NameBytesPair* mutable_attribute(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
      mutable_attribute();
  const ::hbase::pb::NameBytesPair& attribute(int index) const;
  ::hbase::pb::NameBytesPair* add_attribute();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
      attribute() const;

  // repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 19;
  int cf_time_range_size() const;
  void clear_cf_time_range();
  ::hbase::pb::ColumnFamilyTimeRange* mutable_cf_time_range(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
      mutable_cf_time_range();
  const ::hbase::pb::ColumnFamilyTimeRange& cf_time_range(int index) const;
  ::hbase::pb::ColumnFamilyTimeRange* add_cf_time_range();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
      cf_time_range() const;

  // optional bytes start_row = 3;
  bool has_start_row() const;
  void clear_start_row();
  const std::string& start_row() const;
  void set_start_row(const std::string& value);
  void set_start_row(std::string&& value);
  void set_start_row(const char* value);
  void set_start_row(const void* value, size_t size);
  std::string* mutable_start_row();
  std::string* release_start_row();
  void set_allocated_start_row(std::string* start_row);

  // optional bytes stop_row = 4;
  bool has_stop_row() const;
  void clear_stop_row();
  const std::string& stop_row() const;
  void set_stop_row(const std::string& value);
  void set_stop_row(std::string&& value);
  void set_stop_row(const char* value);
  void set_stop_row(const void* value, size_t size);
  std::string* mutable_stop_row();
  std::string* release_stop_row();
  void set_allocated_stop_row(std::string* stop_row);

  // optional .hbase.pb.Filter filter = 5;
  bool has_filter() const;
  void clear_filter();
  const ::hbase::pb::Filter& filter() const;
  ::hbase::pb::Filter* release_filter();
  ::hbase::pb::Filter* mutable_filter();
  void set_allocated_filter(::hbase::pb::Filter* filter);

  // optional .hbase.pb.TimeRange time_range = 6;
  bool has_time_range() const;
  void clear_time_range();
  const ::hbase::pb::TimeRange& time_range() const;
  ::hbase::pb::TimeRange* release_time_range();
  ::hbase::pb::TimeRange* mutable_time_range();
  void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // optional uint64 max_result_size = 10;
  bool has_max_result_size() const;
  void clear_max_result_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 max_result_size() const;
  void set_max_result_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 batch_size = 9;
  bool has_batch_size() const;
  void clear_batch_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size() const;
  void set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 store_limit = 11;
  bool has_store_limit() const;
  void clear_store_limit();
  ::PROTOBUF_NAMESPACE_ID::uint32 store_limit() const;
  void set_store_limit(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 store_offset = 12;
  bool has_store_offset() const;
  void clear_store_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 store_offset() const;
  void set_store_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool load_column_families_on_demand = 13;
  bool has_load_column_families_on_demand() const;
  void clear_load_column_families_on_demand();
  bool load_column_families_on_demand() const;
  void set_load_column_families_on_demand(bool value);

  // optional bool small = 14 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_small() const;
  PROTOBUF_DEPRECATED void clear_small();
  PROTOBUF_DEPRECATED bool small() const;
  PROTOBUF_DEPRECATED void set_small(bool value);

  // optional bool reversed = 15 [default = false];
  bool has_reversed() const;
  void clear_reversed();
  bool reversed() const;
  void set_reversed(bool value);

  // optional bool allow_partial_results = 18;
  bool has_allow_partial_results() const;
  void clear_allow_partial_results();
  bool allow_partial_results() const;
  void set_allow_partial_results(bool value);

  // optional .hbase.pb.Consistency consistency = 16 [default = STRONG];
  bool has_consistency() const;
  void clear_consistency();
  ::hbase::pb::Consistency consistency() const;
  void set_consistency(::hbase::pb::Consistency value);

  // optional uint32 caching = 17;
  bool has_caching() const;
  void clear_caching();
  ::PROTOBUF_NAMESPACE_ID::uint32 caching() const;
  void set_caching(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 mvcc_read_point = 20 [default = 0];
  bool has_mvcc_read_point() const;
  void clear_mvcc_read_point();
  ::PROTOBUF_NAMESPACE_ID::uint64 mvcc_read_point() const;
  void set_mvcc_read_point(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .hbase.pb.Scan.ReadType readType = 23 [default = DEFAULT];
  bool has_readtype() const;
  void clear_readtype();
  ::hbase::pb::Scan_ReadType readtype() const;
  void set_readtype(::hbase::pb::Scan_ReadType value);

  // optional bool include_stop_row = 22 [default = false];
  bool has_include_stop_row() const;
  void clear_include_stop_row();
  bool include_stop_row() const;
  void set_include_stop_row(bool value);

  // optional bool need_cursor_result = 24 [default = false];
  bool has_need_cursor_result() const;
  void clear_need_cursor_result();
  bool need_cursor_result() const;
  void set_need_cursor_result(bool value);

  // optional uint32 max_versions = 7 [default = 1];
  bool has_max_versions() const;
  void clear_max_versions();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_versions() const;
  void set_max_versions(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool cache_blocks = 8 [default = true];
  bool has_cache_blocks() const;
  void clear_cache_blocks();
  bool cache_blocks() const;
  void set_cache_blocks(bool value);

  // optional bool include_start_row = 21 [default = true];
  bool has_include_start_row() const;
  void clear_include_start_row();
  bool include_start_row() const;
  void set_include_start_row(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Scan)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column > column_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair > attribute_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange > cf_time_range_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_row_;
  ::hbase::pb::Filter* filter_;
  ::hbase::pb::TimeRange* time_range_;
  ::PROTOBUF_NAMESPACE_ID::uint64 max_result_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 batch_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 store_limit_;
  ::PROTOBUF_NAMESPACE_ID::uint32 store_offset_;
  bool load_column_families_on_demand_;
  bool small_;
  bool reversed_;
  bool allow_partial_results_;
  int consistency_;
  ::PROTOBUF_NAMESPACE_ID::uint32 caching_;
  ::PROTOBUF_NAMESPACE_ID::uint64 mvcc_read_point_;
  int readtype_;
  bool include_stop_row_;
  bool need_cursor_result_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_versions_;
  bool cache_blocks_;
  bool include_start_row_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class ScanRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ScanRequest) */ {
 public:
  ScanRequest();
  virtual ~ScanRequest();

  ScanRequest(const ScanRequest& from);
  ScanRequest(ScanRequest&& from) noexcept
    : ScanRequest() {
    *this = ::std::move(from);
  }

  inline ScanRequest& operator=(const ScanRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanRequest& operator=(ScanRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScanRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanRequest* internal_default_instance() {
    return reinterpret_cast<const ScanRequest*>(
               &_ScanRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ScanRequest& a, ScanRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScanRequest* New() const final {
    return CreateMaybeMessage<ScanRequest>(nullptr);
  }

  ScanRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScanRequest& from);
  void MergeFrom(const ScanRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ScanRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kScanFieldNumber = 2,
    kScannerIdFieldNumber = 3,
    kNextCallSeqFieldNumber = 6,
    kNumberOfRowsFieldNumber = 4,
    kCloseScannerFieldNumber = 5,
    kClientHandlesPartialsFieldNumber = 7,
    kClientHandlesHeartbeatsFieldNumber = 8,
    kTrackScanMetricsFieldNumber = 9,
    kRenewFieldNumber = 10,
    kLimitOfRowsFieldNumber = 11,
  };
  // optional .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // optional .hbase.pb.Scan scan = 2;
  bool has_scan() const;
  void clear_scan();
  const ::hbase::pb::Scan& scan() const;
  ::hbase::pb::Scan* release_scan();
  ::hbase::pb::Scan* mutable_scan();
  void set_allocated_scan(::hbase::pb::Scan* scan);

  // optional uint64 scanner_id = 3;
  bool has_scanner_id() const;
  void clear_scanner_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 scanner_id() const;
  void set_scanner_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 next_call_seq = 6;
  bool has_next_call_seq() const;
  void clear_next_call_seq();
  ::PROTOBUF_NAMESPACE_ID::uint64 next_call_seq() const;
  void set_next_call_seq(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 number_of_rows = 4;
  bool has_number_of_rows() const;
  void clear_number_of_rows();
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_rows() const;
  void set_number_of_rows(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool close_scanner = 5;
  bool has_close_scanner() const;
  void clear_close_scanner();
  bool close_scanner() const;
  void set_close_scanner(bool value);

  // optional bool client_handles_partials = 7;
  bool has_client_handles_partials() const;
  void clear_client_handles_partials();
  bool client_handles_partials() const;
  void set_client_handles_partials(bool value);

  // optional bool client_handles_heartbeats = 8;
  bool has_client_handles_heartbeats() const;
  void clear_client_handles_heartbeats();
  bool client_handles_heartbeats() const;
  void set_client_handles_heartbeats(bool value);

  // optional bool track_scan_metrics = 9;
  bool has_track_scan_metrics() const;
  void clear_track_scan_metrics();
  bool track_scan_metrics() const;
  void set_track_scan_metrics(bool value);

  // optional bool renew = 10 [default = false];
  bool has_renew() const;
  void clear_renew();
  bool renew() const;
  void set_renew(bool value);

  // optional uint32 limit_of_rows = 11 [default = 0];
  bool has_limit_of_rows() const;
  void clear_limit_of_rows();
  ::PROTOBUF_NAMESPACE_ID::uint32 limit_of_rows() const;
  void set_limit_of_rows(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ScanRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::Scan* scan_;
  ::PROTOBUF_NAMESPACE_ID::uint64 scanner_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 next_call_seq_;
  ::PROTOBUF_NAMESPACE_ID::uint32 number_of_rows_;
  bool close_scanner_;
  bool client_handles_partials_;
  bool client_handles_heartbeats_;
  bool track_scan_metrics_;
  bool renew_;
  ::PROTOBUF_NAMESPACE_ID::uint32 limit_of_rows_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Cursor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Cursor) */ {
 public:
  Cursor();
  virtual ~Cursor();

  Cursor(const Cursor& from);
  Cursor(Cursor&& from) noexcept
    : Cursor() {
    *this = ::std::move(from);
  }

  inline Cursor& operator=(const Cursor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cursor& operator=(Cursor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cursor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Cursor* internal_default_instance() {
    return reinterpret_cast<const Cursor*>(
               &_Cursor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Cursor& a, Cursor& b) {
    a.Swap(&b);
  }
  inline void Swap(Cursor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cursor* New() const final {
    return CreateMaybeMessage<Cursor>(nullptr);
  }

  Cursor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cursor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cursor& from);
  void MergeFrom(const Cursor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cursor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Cursor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
  };
  // optional bytes row = 1;
  bool has_row() const;
  void clear_row();
  const std::string& row() const;
  void set_row(const std::string& value);
  void set_row(std::string&& value);
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  std::string* mutable_row();
  std::string* release_row();
  void set_allocated_row(std::string* row);

  // @@protoc_insertion_point(class_scope:hbase.pb.Cursor)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class ScanResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ScanResponse) */ {
 public:
  ScanResponse();
  virtual ~ScanResponse();

  ScanResponse(const ScanResponse& from);
  ScanResponse(ScanResponse&& from) noexcept
    : ScanResponse() {
    *this = ::std::move(from);
  }

  inline ScanResponse& operator=(const ScanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScanResponse& operator=(ScanResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ScanResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ScanResponse* internal_default_instance() {
    return reinterpret_cast<const ScanResponse*>(
               &_ScanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ScanResponse& a, ScanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ScanResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ScanResponse* New() const final {
    return CreateMaybeMessage<ScanResponse>(nullptr);
  }

  ScanResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ScanResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ScanResponse& from);
  void MergeFrom(const ScanResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScanResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ScanResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCellsPerResultFieldNumber = 1,
    kResultsFieldNumber = 5,
    kPartialFlagPerResultFieldNumber = 7,
    kScanMetricsFieldNumber = 10,
    kCursorFieldNumber = 12,
    kScannerIdFieldNumber = 2,
    kTtlFieldNumber = 4,
    kMoreResultsFieldNumber = 3,
    kStaleFieldNumber = 6,
    kMoreResultsInRegionFieldNumber = 8,
    kHeartbeatMessageFieldNumber = 9,
    kMvccReadPointFieldNumber = 11,
  };
  // repeated uint32 cells_per_result = 1;
  int cells_per_result_size() const;
  void clear_cells_per_result();
  ::PROTOBUF_NAMESPACE_ID::uint32 cells_per_result(int index) const;
  void set_cells_per_result(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value);
  void add_cells_per_result(::PROTOBUF_NAMESPACE_ID::uint32 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
      cells_per_result() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
      mutable_cells_per_result();

  // repeated .hbase.pb.Result results = 5;
  int results_size() const;
  void clear_results();
  ::hbase::pb::Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Result >*
      mutable_results();
  const ::hbase::pb::Result& results(int index) const;
  ::hbase::pb::Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Result >&
      results() const;

  // repeated bool partial_flag_per_result = 7;
  int partial_flag_per_result_size() const;
  void clear_partial_flag_per_result();
  bool partial_flag_per_result(int index) const;
  void set_partial_flag_per_result(int index, bool value);
  void add_partial_flag_per_result(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      partial_flag_per_result() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_partial_flag_per_result();

  // optional .hbase.pb.ScanMetrics scan_metrics = 10;
  bool has_scan_metrics() const;
  void clear_scan_metrics();
  const ::hbase::pb::ScanMetrics& scan_metrics() const;
  ::hbase::pb::ScanMetrics* release_scan_metrics();
  ::hbase::pb::ScanMetrics* mutable_scan_metrics();
  void set_allocated_scan_metrics(::hbase::pb::ScanMetrics* scan_metrics);

  // optional .hbase.pb.Cursor cursor = 12;
  bool has_cursor() const;
  void clear_cursor();
  const ::hbase::pb::Cursor& cursor() const;
  ::hbase::pb::Cursor* release_cursor();
  ::hbase::pb::Cursor* mutable_cursor();
  void set_allocated_cursor(::hbase::pb::Cursor* cursor);

  // optional uint64 scanner_id = 2;
  bool has_scanner_id() const;
  void clear_scanner_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 scanner_id() const;
  void set_scanner_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 ttl = 4;
  bool has_ttl() const;
  void clear_ttl();
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl() const;
  void set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional bool more_results = 3;
  bool has_more_results() const;
  void clear_more_results();
  bool more_results() const;
  void set_more_results(bool value);

  // optional bool stale = 6;
  bool has_stale() const;
  void clear_stale();
  bool stale() const;
  void set_stale(bool value);

  // optional bool more_results_in_region = 8;
  bool has_more_results_in_region() const;
  void clear_more_results_in_region();
  bool more_results_in_region() const;
  void set_more_results_in_region(bool value);

  // optional bool heartbeat_message = 9;
  bool has_heartbeat_message() const;
  void clear_heartbeat_message();
  bool heartbeat_message() const;
  void set_heartbeat_message(bool value);

  // optional uint64 mvcc_read_point = 11 [default = 0];
  bool has_mvcc_read_point() const;
  void clear_mvcc_read_point();
  ::PROTOBUF_NAMESPACE_ID::uint64 mvcc_read_point() const;
  void set_mvcc_read_point(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ScanResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 > cells_per_result_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Result > results_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > partial_flag_per_result_;
  ::hbase::pb::ScanMetrics* scan_metrics_;
  ::hbase::pb::Cursor* cursor_;
  ::PROTOBUF_NAMESPACE_ID::uint64 scanner_id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ttl_;
  bool more_results_;
  bool stale_;
  bool more_results_in_region_;
  bool heartbeat_message_;
  ::PROTOBUF_NAMESPACE_ID::uint64 mvcc_read_point_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class BulkLoadHFileRequest_FamilyPath :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BulkLoadHFileRequest.FamilyPath) */ {
 public:
  BulkLoadHFileRequest_FamilyPath();
  virtual ~BulkLoadHFileRequest_FamilyPath();

  BulkLoadHFileRequest_FamilyPath(const BulkLoadHFileRequest_FamilyPath& from);
  BulkLoadHFileRequest_FamilyPath(BulkLoadHFileRequest_FamilyPath&& from) noexcept
    : BulkLoadHFileRequest_FamilyPath() {
    *this = ::std::move(from);
  }

  inline BulkLoadHFileRequest_FamilyPath& operator=(const BulkLoadHFileRequest_FamilyPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkLoadHFileRequest_FamilyPath& operator=(BulkLoadHFileRequest_FamilyPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkLoadHFileRequest_FamilyPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkLoadHFileRequest_FamilyPath* internal_default_instance() {
    return reinterpret_cast<const BulkLoadHFileRequest_FamilyPath*>(
               &_BulkLoadHFileRequest_FamilyPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BulkLoadHFileRequest_FamilyPath& a, BulkLoadHFileRequest_FamilyPath& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkLoadHFileRequest_FamilyPath* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkLoadHFileRequest_FamilyPath* New() const final {
    return CreateMaybeMessage<BulkLoadHFileRequest_FamilyPath>(nullptr);
  }

  BulkLoadHFileRequest_FamilyPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkLoadHFileRequest_FamilyPath>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkLoadHFileRequest_FamilyPath& from);
  void MergeFrom(const BulkLoadHFileRequest_FamilyPath& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkLoadHFileRequest_FamilyPath* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BulkLoadHFileRequest.FamilyPath";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kPathFieldNumber = 2,
  };
  // required bytes family = 1;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // required string path = 2;
  bool has_path() const;
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileRequest.FamilyPath)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class BulkLoadHFileRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BulkLoadHFileRequest) */ {
 public:
  BulkLoadHFileRequest();
  virtual ~BulkLoadHFileRequest();

  BulkLoadHFileRequest(const BulkLoadHFileRequest& from);
  BulkLoadHFileRequest(BulkLoadHFileRequest&& from) noexcept
    : BulkLoadHFileRequest() {
    *this = ::std::move(from);
  }

  inline BulkLoadHFileRequest& operator=(const BulkLoadHFileRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkLoadHFileRequest& operator=(BulkLoadHFileRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkLoadHFileRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkLoadHFileRequest* internal_default_instance() {
    return reinterpret_cast<const BulkLoadHFileRequest*>(
               &_BulkLoadHFileRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BulkLoadHFileRequest& a, BulkLoadHFileRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkLoadHFileRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkLoadHFileRequest* New() const final {
    return CreateMaybeMessage<BulkLoadHFileRequest>(nullptr);
  }

  BulkLoadHFileRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkLoadHFileRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkLoadHFileRequest& from);
  void MergeFrom(const BulkLoadHFileRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkLoadHFileRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BulkLoadHFileRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef BulkLoadHFileRequest_FamilyPath FamilyPath;

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyPathFieldNumber = 2,
    kBulkTokenFieldNumber = 5,
    kRegionFieldNumber = 1,
    kFsTokenFieldNumber = 4,
    kAssignSeqNumFieldNumber = 3,
    kCopyFileFieldNumber = 6,
  };
  // repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 2;
  int family_path_size() const;
  void clear_family_path();
  ::hbase::pb::BulkLoadHFileRequest_FamilyPath* mutable_family_path(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
      mutable_family_path();
  const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& family_path(int index) const;
  ::hbase::pb::BulkLoadHFileRequest_FamilyPath* add_family_path();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
      family_path() const;

  // optional string bulk_token = 5;
  bool has_bulk_token() const;
  void clear_bulk_token();
  const std::string& bulk_token() const;
  void set_bulk_token(const std::string& value);
  void set_bulk_token(std::string&& value);
  void set_bulk_token(const char* value);
  void set_bulk_token(const char* value, size_t size);
  std::string* mutable_bulk_token();
  std::string* release_bulk_token();
  void set_allocated_bulk_token(std::string* bulk_token);

  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // optional .hbase.pb.DelegationToken fs_token = 4;
  bool has_fs_token() const;
  void clear_fs_token();
  const ::hbase::pb::DelegationToken& fs_token() const;
  ::hbase::pb::DelegationToken* release_fs_token();
  ::hbase::pb::DelegationToken* mutable_fs_token();
  void set_allocated_fs_token(::hbase::pb::DelegationToken* fs_token);

  // optional bool assign_seq_num = 3;
  bool has_assign_seq_num() const;
  void clear_assign_seq_num();
  bool assign_seq_num() const;
  void set_assign_seq_num(bool value);

  // optional bool copy_file = 6 [default = false];
  bool has_copy_file() const;
  void clear_copy_file();
  bool copy_file() const;
  void set_copy_file(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath > family_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bulk_token_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::DelegationToken* fs_token_;
  bool assign_seq_num_;
  bool copy_file_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class BulkLoadHFileResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BulkLoadHFileResponse) */ {
 public:
  BulkLoadHFileResponse();
  virtual ~BulkLoadHFileResponse();

  BulkLoadHFileResponse(const BulkLoadHFileResponse& from);
  BulkLoadHFileResponse(BulkLoadHFileResponse&& from) noexcept
    : BulkLoadHFileResponse() {
    *this = ::std::move(from);
  }

  inline BulkLoadHFileResponse& operator=(const BulkLoadHFileResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkLoadHFileResponse& operator=(BulkLoadHFileResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkLoadHFileResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkLoadHFileResponse* internal_default_instance() {
    return reinterpret_cast<const BulkLoadHFileResponse*>(
               &_BulkLoadHFileResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BulkLoadHFileResponse& a, BulkLoadHFileResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkLoadHFileResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkLoadHFileResponse* New() const final {
    return CreateMaybeMessage<BulkLoadHFileResponse>(nullptr);
  }

  BulkLoadHFileResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkLoadHFileResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkLoadHFileResponse& from);
  void MergeFrom(const BulkLoadHFileResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkLoadHFileResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BulkLoadHFileResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLoadedFieldNumber = 1,
  };
  // required bool loaded = 1;
  bool has_loaded() const;
  void clear_loaded();
  bool loaded() const;
  void set_loaded(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadHFileResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool loaded_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class DelegationToken :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.DelegationToken) */ {
 public:
  DelegationToken();
  virtual ~DelegationToken();

  DelegationToken(const DelegationToken& from);
  DelegationToken(DelegationToken&& from) noexcept
    : DelegationToken() {
    *this = ::std::move(from);
  }

  inline DelegationToken& operator=(const DelegationToken& from) {
    CopyFrom(from);
    return *this;
  }
  inline DelegationToken& operator=(DelegationToken&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DelegationToken& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DelegationToken* internal_default_instance() {
    return reinterpret_cast<const DelegationToken*>(
               &_DelegationToken_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(DelegationToken& a, DelegationToken& b) {
    a.Swap(&b);
  }
  inline void Swap(DelegationToken* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DelegationToken* New() const final {
    return CreateMaybeMessage<DelegationToken>(nullptr);
  }

  DelegationToken* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DelegationToken>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DelegationToken& from);
  void MergeFrom(const DelegationToken& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DelegationToken* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.DelegationToken";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentifierFieldNumber = 1,
    kPasswordFieldNumber = 2,
    kKindFieldNumber = 3,
    kServiceFieldNumber = 4,
  };
  // optional bytes identifier = 1;
  bool has_identifier() const;
  void clear_identifier();
  const std::string& identifier() const;
  void set_identifier(const std::string& value);
  void set_identifier(std::string&& value);
  void set_identifier(const char* value);
  void set_identifier(const void* value, size_t size);
  std::string* mutable_identifier();
  std::string* release_identifier();
  void set_allocated_identifier(std::string* identifier);

  // optional bytes password = 2;
  bool has_password() const;
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const void* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);

  // optional string kind = 3;
  bool has_kind() const;
  void clear_kind();
  const std::string& kind() const;
  void set_kind(const std::string& value);
  void set_kind(std::string&& value);
  void set_kind(const char* value);
  void set_kind(const char* value, size_t size);
  std::string* mutable_kind();
  std::string* release_kind();
  void set_allocated_kind(std::string* kind);

  // optional string service = 4;
  bool has_service() const;
  void clear_service();
  const std::string& service() const;
  void set_service(const std::string& value);
  void set_service(std::string&& value);
  void set_service(const char* value);
  void set_service(const char* value, size_t size);
  std::string* mutable_service();
  std::string* release_service();
  void set_allocated_service(std::string* service);

  // @@protoc_insertion_point(class_scope:hbase.pb.DelegationToken)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr identifier_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr kind_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class PrepareBulkLoadRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.PrepareBulkLoadRequest) */ {
 public:
  PrepareBulkLoadRequest();
  virtual ~PrepareBulkLoadRequest();

  PrepareBulkLoadRequest(const PrepareBulkLoadRequest& from);
  PrepareBulkLoadRequest(PrepareBulkLoadRequest&& from) noexcept
    : PrepareBulkLoadRequest() {
    *this = ::std::move(from);
  }

  inline PrepareBulkLoadRequest& operator=(const PrepareBulkLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareBulkLoadRequest& operator=(PrepareBulkLoadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrepareBulkLoadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareBulkLoadRequest* internal_default_instance() {
    return reinterpret_cast<const PrepareBulkLoadRequest*>(
               &_PrepareBulkLoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(PrepareBulkLoadRequest& a, PrepareBulkLoadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareBulkLoadRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrepareBulkLoadRequest* New() const final {
    return CreateMaybeMessage<PrepareBulkLoadRequest>(nullptr);
  }

  PrepareBulkLoadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrepareBulkLoadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrepareBulkLoadRequest& from);
  void MergeFrom(const PrepareBulkLoadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareBulkLoadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.PrepareBulkLoadRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableNameFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // required .hbase.pb.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // optional .hbase.pb.RegionSpecifier region = 2;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrepareBulkLoadRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::TableName* table_name_;
  ::hbase::pb::RegionSpecifier* region_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class PrepareBulkLoadResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.PrepareBulkLoadResponse) */ {
 public:
  PrepareBulkLoadResponse();
  virtual ~PrepareBulkLoadResponse();

  PrepareBulkLoadResponse(const PrepareBulkLoadResponse& from);
  PrepareBulkLoadResponse(PrepareBulkLoadResponse&& from) noexcept
    : PrepareBulkLoadResponse() {
    *this = ::std::move(from);
  }

  inline PrepareBulkLoadResponse& operator=(const PrepareBulkLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrepareBulkLoadResponse& operator=(PrepareBulkLoadResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrepareBulkLoadResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrepareBulkLoadResponse* internal_default_instance() {
    return reinterpret_cast<const PrepareBulkLoadResponse*>(
               &_PrepareBulkLoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(PrepareBulkLoadResponse& a, PrepareBulkLoadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PrepareBulkLoadResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrepareBulkLoadResponse* New() const final {
    return CreateMaybeMessage<PrepareBulkLoadResponse>(nullptr);
  }

  PrepareBulkLoadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrepareBulkLoadResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrepareBulkLoadResponse& from);
  void MergeFrom(const PrepareBulkLoadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrepareBulkLoadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.PrepareBulkLoadResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulkTokenFieldNumber = 1,
  };
  // required string bulk_token = 1;
  bool has_bulk_token() const;
  void clear_bulk_token();
  const std::string& bulk_token() const;
  void set_bulk_token(const std::string& value);
  void set_bulk_token(std::string&& value);
  void set_bulk_token(const char* value);
  void set_bulk_token(const char* value, size_t size);
  std::string* mutable_bulk_token();
  std::string* release_bulk_token();
  void set_allocated_bulk_token(std::string* bulk_token);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrepareBulkLoadResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bulk_token_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CleanupBulkLoadRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CleanupBulkLoadRequest) */ {
 public:
  CleanupBulkLoadRequest();
  virtual ~CleanupBulkLoadRequest();

  CleanupBulkLoadRequest(const CleanupBulkLoadRequest& from);
  CleanupBulkLoadRequest(CleanupBulkLoadRequest&& from) noexcept
    : CleanupBulkLoadRequest() {
    *this = ::std::move(from);
  }

  inline CleanupBulkLoadRequest& operator=(const CleanupBulkLoadRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanupBulkLoadRequest& operator=(CleanupBulkLoadRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CleanupBulkLoadRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupBulkLoadRequest* internal_default_instance() {
    return reinterpret_cast<const CleanupBulkLoadRequest*>(
               &_CleanupBulkLoadRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CleanupBulkLoadRequest& a, CleanupBulkLoadRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanupBulkLoadRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CleanupBulkLoadRequest* New() const final {
    return CreateMaybeMessage<CleanupBulkLoadRequest>(nullptr);
  }

  CleanupBulkLoadRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CleanupBulkLoadRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CleanupBulkLoadRequest& from);
  void MergeFrom(const CleanupBulkLoadRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupBulkLoadRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CleanupBulkLoadRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulkTokenFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // required string bulk_token = 1;
  bool has_bulk_token() const;
  void clear_bulk_token();
  const std::string& bulk_token() const;
  void set_bulk_token(const std::string& value);
  void set_bulk_token(std::string&& value);
  void set_bulk_token(const char* value);
  void set_bulk_token(const char* value, size_t size);
  std::string* mutable_bulk_token();
  std::string* release_bulk_token();
  void set_allocated_bulk_token(std::string* bulk_token);

  // optional .hbase.pb.RegionSpecifier region = 2;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // @@protoc_insertion_point(class_scope:hbase.pb.CleanupBulkLoadRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bulk_token_;
  ::hbase::pb::RegionSpecifier* region_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CleanupBulkLoadResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CleanupBulkLoadResponse) */ {
 public:
  CleanupBulkLoadResponse();
  virtual ~CleanupBulkLoadResponse();

  CleanupBulkLoadResponse(const CleanupBulkLoadResponse& from);
  CleanupBulkLoadResponse(CleanupBulkLoadResponse&& from) noexcept
    : CleanupBulkLoadResponse() {
    *this = ::std::move(from);
  }

  inline CleanupBulkLoadResponse& operator=(const CleanupBulkLoadResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CleanupBulkLoadResponse& operator=(CleanupBulkLoadResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CleanupBulkLoadResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CleanupBulkLoadResponse* internal_default_instance() {
    return reinterpret_cast<const CleanupBulkLoadResponse*>(
               &_CleanupBulkLoadResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CleanupBulkLoadResponse& a, CleanupBulkLoadResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CleanupBulkLoadResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CleanupBulkLoadResponse* New() const final {
    return CreateMaybeMessage<CleanupBulkLoadResponse>(nullptr);
  }

  CleanupBulkLoadResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CleanupBulkLoadResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CleanupBulkLoadResponse& from);
  void MergeFrom(const CleanupBulkLoadResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CleanupBulkLoadResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CleanupBulkLoadResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.CleanupBulkLoadResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CoprocessorServiceCall :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CoprocessorServiceCall) */ {
 public:
  CoprocessorServiceCall();
  virtual ~CoprocessorServiceCall();

  CoprocessorServiceCall(const CoprocessorServiceCall& from);
  CoprocessorServiceCall(CoprocessorServiceCall&& from) noexcept
    : CoprocessorServiceCall() {
    *this = ::std::move(from);
  }

  inline CoprocessorServiceCall& operator=(const CoprocessorServiceCall& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoprocessorServiceCall& operator=(CoprocessorServiceCall&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoprocessorServiceCall& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoprocessorServiceCall* internal_default_instance() {
    return reinterpret_cast<const CoprocessorServiceCall*>(
               &_CoprocessorServiceCall_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CoprocessorServiceCall& a, CoprocessorServiceCall& b) {
    a.Swap(&b);
  }
  inline void Swap(CoprocessorServiceCall* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoprocessorServiceCall* New() const final {
    return CreateMaybeMessage<CoprocessorServiceCall>(nullptr);
  }

  CoprocessorServiceCall* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoprocessorServiceCall>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoprocessorServiceCall& from);
  void MergeFrom(const CoprocessorServiceCall& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoprocessorServiceCall* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CoprocessorServiceCall";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowFieldNumber = 1,
    kServiceNameFieldNumber = 2,
    kMethodNameFieldNumber = 3,
    kRequestFieldNumber = 4,
  };
  // required bytes row = 1;
  bool has_row() const;
  void clear_row();
  const std::string& row() const;
  void set_row(const std::string& value);
  void set_row(std::string&& value);
  void set_row(const char* value);
  void set_row(const void* value, size_t size);
  std::string* mutable_row();
  std::string* release_row();
  void set_allocated_row(std::string* row);

  // required string service_name = 2;
  bool has_service_name() const;
  void clear_service_name();
  const std::string& service_name() const;
  void set_service_name(const std::string& value);
  void set_service_name(std::string&& value);
  void set_service_name(const char* value);
  void set_service_name(const char* value, size_t size);
  std::string* mutable_service_name();
  std::string* release_service_name();
  void set_allocated_service_name(std::string* service_name);

  // required string method_name = 3;
  bool has_method_name() const;
  void clear_method_name();
  const std::string& method_name() const;
  void set_method_name(const std::string& value);
  void set_method_name(std::string&& value);
  void set_method_name(const char* value);
  void set_method_name(const char* value, size_t size);
  std::string* mutable_method_name();
  std::string* release_method_name();
  void set_allocated_method_name(std::string* method_name);

  // required bytes request = 4;
  bool has_request() const;
  void clear_request();
  const std::string& request() const;
  void set_request(const std::string& value);
  void set_request(std::string&& value);
  void set_request(const char* value);
  void set_request(const void* value, size_t size);
  std::string* mutable_request();
  std::string* release_request();
  void set_allocated_request(std::string* request);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceCall)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr service_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr method_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CoprocessorServiceResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CoprocessorServiceResult) */ {
 public:
  CoprocessorServiceResult();
  virtual ~CoprocessorServiceResult();

  CoprocessorServiceResult(const CoprocessorServiceResult& from);
  CoprocessorServiceResult(CoprocessorServiceResult&& from) noexcept
    : CoprocessorServiceResult() {
    *this = ::std::move(from);
  }

  inline CoprocessorServiceResult& operator=(const CoprocessorServiceResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoprocessorServiceResult& operator=(CoprocessorServiceResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoprocessorServiceResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoprocessorServiceResult* internal_default_instance() {
    return reinterpret_cast<const CoprocessorServiceResult*>(
               &_CoprocessorServiceResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CoprocessorServiceResult& a, CoprocessorServiceResult& b) {
    a.Swap(&b);
  }
  inline void Swap(CoprocessorServiceResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoprocessorServiceResult* New() const final {
    return CreateMaybeMessage<CoprocessorServiceResult>(nullptr);
  }

  CoprocessorServiceResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoprocessorServiceResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoprocessorServiceResult& from);
  void MergeFrom(const CoprocessorServiceResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoprocessorServiceResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CoprocessorServiceResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional .hbase.pb.NameBytesPair value = 1;
  bool has_value() const;
  void clear_value();
  const ::hbase::pb::NameBytesPair& value() const;
  ::hbase::pb::NameBytesPair* release_value();
  ::hbase::pb::NameBytesPair* mutable_value();
  void set_allocated_value(::hbase::pb::NameBytesPair* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::NameBytesPair* value_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CoprocessorServiceRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CoprocessorServiceRequest) */ {
 public:
  CoprocessorServiceRequest();
  virtual ~CoprocessorServiceRequest();

  CoprocessorServiceRequest(const CoprocessorServiceRequest& from);
  CoprocessorServiceRequest(CoprocessorServiceRequest&& from) noexcept
    : CoprocessorServiceRequest() {
    *this = ::std::move(from);
  }

  inline CoprocessorServiceRequest& operator=(const CoprocessorServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoprocessorServiceRequest& operator=(CoprocessorServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoprocessorServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoprocessorServiceRequest* internal_default_instance() {
    return reinterpret_cast<const CoprocessorServiceRequest*>(
               &_CoprocessorServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CoprocessorServiceRequest& a, CoprocessorServiceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CoprocessorServiceRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoprocessorServiceRequest* New() const final {
    return CreateMaybeMessage<CoprocessorServiceRequest>(nullptr);
  }

  CoprocessorServiceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoprocessorServiceRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoprocessorServiceRequest& from);
  void MergeFrom(const CoprocessorServiceRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoprocessorServiceRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CoprocessorServiceRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kCallFieldNumber = 2,
  };
  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.CoprocessorServiceCall call = 2;
  bool has_call() const;
  void clear_call();
  const ::hbase::pb::CoprocessorServiceCall& call() const;
  ::hbase::pb::CoprocessorServiceCall* release_call();
  ::hbase::pb::CoprocessorServiceCall* mutable_call();
  void set_allocated_call(::hbase::pb::CoprocessorServiceCall* call);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::CoprocessorServiceCall* call_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class CoprocessorServiceResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CoprocessorServiceResponse) */ {
 public:
  CoprocessorServiceResponse();
  virtual ~CoprocessorServiceResponse();

  CoprocessorServiceResponse(const CoprocessorServiceResponse& from);
  CoprocessorServiceResponse(CoprocessorServiceResponse&& from) noexcept
    : CoprocessorServiceResponse() {
    *this = ::std::move(from);
  }

  inline CoprocessorServiceResponse& operator=(const CoprocessorServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoprocessorServiceResponse& operator=(CoprocessorServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CoprocessorServiceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoprocessorServiceResponse* internal_default_instance() {
    return reinterpret_cast<const CoprocessorServiceResponse*>(
               &_CoprocessorServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CoprocessorServiceResponse& a, CoprocessorServiceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CoprocessorServiceResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CoprocessorServiceResponse* New() const final {
    return CreateMaybeMessage<CoprocessorServiceResponse>(nullptr);
  }

  CoprocessorServiceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CoprocessorServiceResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CoprocessorServiceResponse& from);
  void MergeFrom(const CoprocessorServiceResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoprocessorServiceResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CoprocessorServiceResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // required .hbase.pb.NameBytesPair value = 2;
  bool has_value() const;
  void clear_value();
  const ::hbase::pb::NameBytesPair& value() const;
  ::hbase::pb::NameBytesPair* release_value();
  ::hbase::pb::NameBytesPair* mutable_value();
  void set_allocated_value(::hbase::pb::NameBytesPair* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.CoprocessorServiceResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* region_;
  ::hbase::pb::NameBytesPair* value_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class Action :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(nullptr);
  }

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Action";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMutationFieldNumber = 2,
    kGetFieldNumber = 3,
    kServiceCallFieldNumber = 4,
    kIndexFieldNumber = 1,
  };
  // optional .hbase.pb.MutationProto mutation = 2;
  bool has_mutation() const;
  void clear_mutation();
  const ::hbase::pb::MutationProto& mutation() const;
  ::hbase::pb::MutationProto* release_mutation();
  ::hbase::pb::MutationProto* mutable_mutation();
  void set_allocated_mutation(::hbase::pb::MutationProto* mutation);

  // optional .hbase.pb.Get get = 3;
  bool has_get() const;
  void clear_get();
  const ::hbase::pb::Get& get() const;
  ::hbase::pb::Get* release_get();
  ::hbase::pb::Get* mutable_get();
  void set_allocated_get(::hbase::pb::Get* get);

  // optional .hbase.pb.CoprocessorServiceCall service_call = 4;
  bool has_service_call() const;
  void clear_service_call();
  const ::hbase::pb::CoprocessorServiceCall& service_call() const;
  ::hbase::pb::CoprocessorServiceCall* release_service_call();
  ::hbase::pb::CoprocessorServiceCall* mutable_service_call();
  void set_allocated_service_call(::hbase::pb::CoprocessorServiceCall* service_call);

  // optional uint32 index = 1;
  bool has_index() const;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Action)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::MutationProto* mutation_;
  ::hbase::pb::Get* get_;
  ::hbase::pb::CoprocessorServiceCall* service_call_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class RegionAction :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionAction) */ {
 public:
  RegionAction();
  virtual ~RegionAction();

  RegionAction(const RegionAction& from);
  RegionAction(RegionAction&& from) noexcept
    : RegionAction() {
    *this = ::std::move(from);
  }

  inline RegionAction& operator=(const RegionAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionAction& operator=(RegionAction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionAction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionAction* internal_default_instance() {
    return reinterpret_cast<const RegionAction*>(
               &_RegionAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(RegionAction& a, RegionAction& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionAction* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionAction* New() const final {
    return CreateMaybeMessage<RegionAction>(nullptr);
  }

  RegionAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionAction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionAction& from);
  void MergeFrom(const RegionAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionAction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionAction";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kRegionFieldNumber = 1,
    kAtomicFieldNumber = 2,
  };
  // repeated .hbase.pb.Action action = 3;
  int action_size() const;
  void clear_action();
  ::hbase::pb::Action* mutable_action(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Action >*
      mutable_action();
  const ::hbase::pb::Action& action(int index) const;
  ::hbase::pb::Action* add_action();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Action >&
      action() const;

  // required .hbase.pb.RegionSpecifier region = 1;
  bool has_region() const;
  void clear_region();
  const ::hbase::pb::RegionSpecifier& region() const;
  ::hbase::pb::RegionSpecifier* release_region();
  ::hbase::pb::RegionSpecifier* mutable_region();
  void set_allocated_region(::hbase::pb::RegionSpecifier* region);

  // optional bool atomic = 2;
  bool has_atomic() const;
  void clear_atomic();
  bool atomic() const;
  void set_atomic(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionAction)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Action > action_;
  ::hbase::pb::RegionSpecifier* region_;
  bool atomic_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class RegionLoadStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionLoadStats) */ {
 public:
  RegionLoadStats();
  virtual ~RegionLoadStats();

  RegionLoadStats(const RegionLoadStats& from);
  RegionLoadStats(RegionLoadStats&& from) noexcept
    : RegionLoadStats() {
    *this = ::std::move(from);
  }

  inline RegionLoadStats& operator=(const RegionLoadStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLoadStats& operator=(RegionLoadStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionLoadStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionLoadStats* internal_default_instance() {
    return reinterpret_cast<const RegionLoadStats*>(
               &_RegionLoadStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(RegionLoadStats& a, RegionLoadStats& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLoadStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionLoadStats* New() const final {
    return CreateMaybeMessage<RegionLoadStats>(nullptr);
  }

  RegionLoadStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionLoadStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionLoadStats& from);
  void MergeFrom(const RegionLoadStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLoadStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionLoadStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemStoreLoadFieldNumber = 1,
    kHeapOccupancyFieldNumber = 2,
    kCompactionPressureFieldNumber = 3,
  };
  // optional int32 memStoreLoad = 1 [default = 0];
  bool has_memstoreload() const;
  void clear_memstoreload();
  ::PROTOBUF_NAMESPACE_ID::int32 memstoreload() const;
  void set_memstoreload(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 heapOccupancy = 2 [default = 0];
  bool has_heapoccupancy() const;
  void clear_heapoccupancy();
  ::PROTOBUF_NAMESPACE_ID::int32 heapoccupancy() const;
  void set_heapoccupancy(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 compactionPressure = 3 [default = 0];
  bool has_compactionpressure() const;
  void clear_compactionpressure();
  ::PROTOBUF_NAMESPACE_ID::int32 compactionpressure() const;
  void set_compactionpressure(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionLoadStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 memstoreload_;
  ::PROTOBUF_NAMESPACE_ID::int32 heapoccupancy_;
  ::PROTOBUF_NAMESPACE_ID::int32 compactionpressure_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MultiRegionLoadStats :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MultiRegionLoadStats) */ {
 public:
  MultiRegionLoadStats();
  virtual ~MultiRegionLoadStats();

  MultiRegionLoadStats(const MultiRegionLoadStats& from);
  MultiRegionLoadStats(MultiRegionLoadStats&& from) noexcept
    : MultiRegionLoadStats() {
    *this = ::std::move(from);
  }

  inline MultiRegionLoadStats& operator=(const MultiRegionLoadStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiRegionLoadStats& operator=(MultiRegionLoadStats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiRegionLoadStats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiRegionLoadStats* internal_default_instance() {
    return reinterpret_cast<const MultiRegionLoadStats*>(
               &_MultiRegionLoadStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(MultiRegionLoadStats& a, MultiRegionLoadStats& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiRegionLoadStats* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiRegionLoadStats* New() const final {
    return CreateMaybeMessage<MultiRegionLoadStats>(nullptr);
  }

  MultiRegionLoadStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiRegionLoadStats>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiRegionLoadStats& from);
  void MergeFrom(const MultiRegionLoadStats& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiRegionLoadStats* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MultiRegionLoadStats";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kStatFieldNumber = 2,
  };
  // repeated .hbase.pb.RegionSpecifier region = 1;
  int region_size() const;
  void clear_region();
  ::hbase::pb::RegionSpecifier* mutable_region(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionSpecifier >*
      mutable_region();
  const ::hbase::pb::RegionSpecifier& region(int index) const;
  ::hbase::pb::RegionSpecifier* add_region();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionSpecifier >&
      region() const;

  // repeated .hbase.pb.RegionLoadStats stat = 2;
  int stat_size() const;
  void clear_stat();
  ::hbase::pb::RegionLoadStats* mutable_stat(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoadStats >*
      mutable_stat();
  const ::hbase::pb::RegionLoadStats& stat(int index) const;
  ::hbase::pb::RegionLoadStats* add_stat();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoadStats >&
      stat() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRegionLoadStats)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionSpecifier > region_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoadStats > stat_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class ResultOrException :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ResultOrException) */ {
 public:
  ResultOrException();
  virtual ~ResultOrException();

  ResultOrException(const ResultOrException& from);
  ResultOrException(ResultOrException&& from) noexcept
    : ResultOrException() {
    *this = ::std::move(from);
  }

  inline ResultOrException& operator=(const ResultOrException& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResultOrException& operator=(ResultOrException&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ResultOrException& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResultOrException* internal_default_instance() {
    return reinterpret_cast<const ResultOrException*>(
               &_ResultOrException_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(ResultOrException& a, ResultOrException& b) {
    a.Swap(&b);
  }
  inline void Swap(ResultOrException* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ResultOrException* New() const final {
    return CreateMaybeMessage<ResultOrException>(nullptr);
  }

  ResultOrException* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ResultOrException>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ResultOrException& from);
  void MergeFrom(const ResultOrException& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResultOrException* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ResultOrException";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kExceptionFieldNumber = 3,
    kServiceResultFieldNumber = 4,
    kLoadStatsFieldNumber = 5,
    kIndexFieldNumber = 1,
  };
  // optional .hbase.pb.Result result = 2;
  bool has_result() const;
  void clear_result();
  const ::hbase::pb::Result& result() const;
  ::hbase::pb::Result* release_result();
  ::hbase::pb::Result* mutable_result();
  void set_allocated_result(::hbase::pb::Result* result);

  // optional .hbase.pb.NameBytesPair exception = 3;
  bool has_exception() const;
  void clear_exception();
  const ::hbase::pb::NameBytesPair& exception() const;
  ::hbase::pb::NameBytesPair* release_exception();
  ::hbase::pb::NameBytesPair* mutable_exception();
  void set_allocated_exception(::hbase::pb::NameBytesPair* exception);

  // optional .hbase.pb.CoprocessorServiceResult service_result = 4;
  bool has_service_result() const;
  void clear_service_result();
  const ::hbase::pb::CoprocessorServiceResult& service_result() const;
  ::hbase::pb::CoprocessorServiceResult* release_service_result();
  ::hbase::pb::CoprocessorServiceResult* mutable_service_result();
  void set_allocated_service_result(::hbase::pb::CoprocessorServiceResult* service_result);

  // optional .hbase.pb.RegionLoadStats loadStats = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_loadstats() const;
  PROTOBUF_DEPRECATED void clear_loadstats();
  PROTOBUF_DEPRECATED const ::hbase::pb::RegionLoadStats& loadstats() const;
  PROTOBUF_DEPRECATED ::hbase::pb::RegionLoadStats* release_loadstats();
  PROTOBUF_DEPRECATED ::hbase::pb::RegionLoadStats* mutable_loadstats();
  PROTOBUF_DEPRECATED void set_allocated_loadstats(::hbase::pb::RegionLoadStats* loadstats);

  // optional uint32 index = 1;
  bool has_index() const;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ResultOrException)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Result* result_;
  ::hbase::pb::NameBytesPair* exception_;
  ::hbase::pb::CoprocessorServiceResult* service_result_;
  ::hbase::pb::RegionLoadStats* loadstats_;
  ::PROTOBUF_NAMESPACE_ID::uint32 index_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class RegionActionResult :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionActionResult) */ {
 public:
  RegionActionResult();
  virtual ~RegionActionResult();

  RegionActionResult(const RegionActionResult& from);
  RegionActionResult(RegionActionResult&& from) noexcept
    : RegionActionResult() {
    *this = ::std::move(from);
  }

  inline RegionActionResult& operator=(const RegionActionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionActionResult& operator=(RegionActionResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionActionResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionActionResult* internal_default_instance() {
    return reinterpret_cast<const RegionActionResult*>(
               &_RegionActionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(RegionActionResult& a, RegionActionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionActionResult* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionActionResult* New() const final {
    return CreateMaybeMessage<RegionActionResult>(nullptr);
  }

  RegionActionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionActionResult>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionActionResult& from);
  void MergeFrom(const RegionActionResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionActionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionActionResult";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultOrExceptionFieldNumber = 1,
    kExceptionFieldNumber = 2,
  };
  // repeated .hbase.pb.ResultOrException resultOrException = 1;
  int resultorexception_size() const;
  void clear_resultorexception();
  ::hbase::pb::ResultOrException* mutable_resultorexception(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ResultOrException >*
      mutable_resultorexception();
  const ::hbase::pb::ResultOrException& resultorexception(int index) const;
  ::hbase::pb::ResultOrException* add_resultorexception();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ResultOrException >&
      resultorexception() const;

  // optional .hbase.pb.NameBytesPair exception = 2;
  bool has_exception() const;
  void clear_exception();
  const ::hbase::pb::NameBytesPair& exception() const;
  ::hbase::pb::NameBytesPair* release_exception();
  ::hbase::pb::NameBytesPair* mutable_exception();
  void set_allocated_exception(::hbase::pb::NameBytesPair* exception);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionActionResult)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ResultOrException > resultorexception_;
  ::hbase::pb::NameBytesPair* exception_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MultiRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MultiRequest) */ {
 public:
  MultiRequest();
  virtual ~MultiRequest();

  MultiRequest(const MultiRequest& from);
  MultiRequest(MultiRequest&& from) noexcept
    : MultiRequest() {
    *this = ::std::move(from);
  }

  inline MultiRequest& operator=(const MultiRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiRequest& operator=(MultiRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiRequest* internal_default_instance() {
    return reinterpret_cast<const MultiRequest*>(
               &_MultiRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(MultiRequest& a, MultiRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiRequest* New() const final {
    return CreateMaybeMessage<MultiRequest>(nullptr);
  }

  MultiRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiRequest& from);
  void MergeFrom(const MultiRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MultiRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionActionFieldNumber = 1,
    kConditionFieldNumber = 3,
    kNonceGroupFieldNumber = 2,
  };
  // repeated .hbase.pb.RegionAction regionAction = 1;
  int regionaction_size() const;
  void clear_regionaction();
  ::hbase::pb::RegionAction* mutable_regionaction(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionAction >*
      mutable_regionaction();
  const ::hbase::pb::RegionAction& regionaction(int index) const;
  ::hbase::pb::RegionAction* add_regionaction();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionAction >&
      regionaction() const;

  // optional .hbase.pb.Condition condition = 3;
  bool has_condition() const;
  void clear_condition();
  const ::hbase::pb::Condition& condition() const;
  ::hbase::pb::Condition* release_condition();
  ::hbase::pb::Condition* mutable_condition();
  void set_allocated_condition(::hbase::pb::Condition* condition);

  // optional uint64 nonceGroup = 2;
  bool has_noncegroup() const;
  void clear_noncegroup();
  ::PROTOBUF_NAMESPACE_ID::uint64 noncegroup() const;
  void set_noncegroup(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionAction > regionaction_;
  ::hbase::pb::Condition* condition_;
  ::PROTOBUF_NAMESPACE_ID::uint64 noncegroup_;
  friend struct ::TableStruct_Client_2eproto;
};
// -------------------------------------------------------------------

class MultiResponse :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MultiResponse) */ {
 public:
  MultiResponse();
  virtual ~MultiResponse();

  MultiResponse(const MultiResponse& from);
  MultiResponse(MultiResponse&& from) noexcept
    : MultiResponse() {
    *this = ::std::move(from);
  }

  inline MultiResponse& operator=(const MultiResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiResponse& operator=(MultiResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiResponse* internal_default_instance() {
    return reinterpret_cast<const MultiResponse*>(
               &_MultiResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MultiResponse& a, MultiResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiResponse* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiResponse* New() const final {
    return CreateMaybeMessage<MultiResponse>(nullptr);
  }

  MultiResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiResponse& from);
  void MergeFrom(const MultiResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MultiResponse";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Client_2eproto);
    return ::descriptor_table_Client_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionActionResultFieldNumber = 1,
    kRegionStatisticsFieldNumber = 3,
    kProcessedFieldNumber = 2,
  };
  // repeated .hbase.pb.RegionActionResult regionActionResult = 1;
  int regionactionresult_size() const;
  void clear_regionactionresult();
  ::hbase::pb::RegionActionResult* mutable_regionactionresult(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionActionResult >*
      mutable_regionactionresult();
  const ::hbase::pb::RegionActionResult& regionactionresult(int index) const;
  ::hbase::pb::RegionActionResult* add_regionactionresult();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionActionResult >&
      regionactionresult() const;

  // optional .hbase.pb.MultiRegionLoadStats regionStatistics = 3;
  bool has_regionstatistics() const;
  void clear_regionstatistics();
  const ::hbase::pb::MultiRegionLoadStats& regionstatistics() const;
  ::hbase::pb::MultiRegionLoadStats* release_regionstatistics();
  ::hbase::pb::MultiRegionLoadStats* mutable_regionstatistics();
  void set_allocated_regionstatistics(::hbase::pb::MultiRegionLoadStats* regionstatistics);

  // optional bool processed = 2;
  bool has_processed() const;
  void clear_processed();
  bool processed() const;
  void set_processed(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiResponse)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionActionResult > regionactionresult_;
  ::hbase::pb::MultiRegionLoadStats* regionstatistics_;
  bool processed_;
  friend struct ::TableStruct_Client_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Authorizations

// repeated string label = 1;
inline int Authorizations::label_size() const {
  return label_.size();
}
inline void Authorizations::clear_label() {
  label_.Clear();
}
inline const std::string& Authorizations::label(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Authorizations.label)
  return label_.Get(index);
}
inline std::string* Authorizations::mutable_label(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Authorizations.label)
  return label_.Mutable(index);
}
inline void Authorizations::set_label(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.Authorizations.label)
  label_.Mutable(index)->assign(value);
}
inline void Authorizations::set_label(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.Authorizations.label)
  label_.Mutable(index)->assign(std::move(value));
}
inline void Authorizations::set_label(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.Authorizations.label)
}
inline void Authorizations::set_label(int index, const char* value, size_t size) {
  label_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Authorizations.label)
}
inline std::string* Authorizations::add_label() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.Authorizations.label)
  return label_.Add();
}
inline void Authorizations::add_label(const std::string& value) {
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.Authorizations.label)
}
inline void Authorizations::add_label(std::string&& value) {
  label_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.Authorizations.label)
}
inline void Authorizations::add_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.Authorizations.label)
}
inline void Authorizations::add_label(const char* value, size_t size) {
  label_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.Authorizations.label)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Authorizations::label() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Authorizations.label)
  return label_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Authorizations::mutable_label() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Authorizations.label)
  return &label_;
}

// -------------------------------------------------------------------

// CellVisibility

// required string expression = 1;
inline bool CellVisibility::has_expression() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CellVisibility::clear_expression() {
  expression_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CellVisibility::expression() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CellVisibility.expression)
  return expression_.GetNoArena();
}
inline void CellVisibility::set_expression(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  expression_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CellVisibility.expression)
}
inline void CellVisibility::set_expression(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  expression_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CellVisibility.expression)
}
inline void CellVisibility::set_expression(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  expression_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CellVisibility.expression)
}
inline void CellVisibility::set_expression(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  expression_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CellVisibility.expression)
}
inline std::string* CellVisibility::mutable_expression() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CellVisibility.expression)
  return expression_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CellVisibility::release_expression() {
  // @@protoc_insertion_point(field_release:hbase.pb.CellVisibility.expression)
  if (!has_expression()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return expression_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CellVisibility::set_allocated_expression(std::string* expression) {
  if (expression != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expression_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), expression);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CellVisibility.expression)
}

// -------------------------------------------------------------------

// Column

// required bytes family = 1;
inline bool Column::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Column::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Column.family)
  return family_.GetNoArena();
}
inline void Column::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Column.family)
}
inline void Column::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Column.family)
}
inline void Column::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Column.family)
}
inline void Column::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Column.family)
}
inline std::string* Column::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Column.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Column::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.Column.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Column::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Column.family)
}

// repeated bytes qualifier = 2;
inline int Column::qualifier_size() const {
  return qualifier_.size();
}
inline void Column::clear_qualifier() {
  qualifier_.Clear();
}
inline const std::string& Column::qualifier(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Column.qualifier)
  return qualifier_.Get(index);
}
inline std::string* Column::mutable_qualifier(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Column.qualifier)
  return qualifier_.Mutable(index);
}
inline void Column::set_qualifier(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.Column.qualifier)
  qualifier_.Mutable(index)->assign(value);
}
inline void Column::set_qualifier(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.Column.qualifier)
  qualifier_.Mutable(index)->assign(std::move(value));
}
inline void Column::set_qualifier(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qualifier_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.Column.qualifier)
}
inline void Column::set_qualifier(int index, const void* value, size_t size) {
  qualifier_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Column.qualifier)
}
inline std::string* Column::add_qualifier() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.Column.qualifier)
  return qualifier_.Add();
}
inline void Column::add_qualifier(const std::string& value) {
  qualifier_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.Column.qualifier)
}
inline void Column::add_qualifier(std::string&& value) {
  qualifier_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.Column.qualifier)
}
inline void Column::add_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qualifier_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.Column.qualifier)
}
inline void Column::add_qualifier(const void* value, size_t size) {
  qualifier_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.Column.qualifier)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Column::qualifier() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Column.qualifier)
  return qualifier_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Column::mutable_qualifier() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Column.qualifier)
  return &qualifier_;
}

// -------------------------------------------------------------------

// Get

// required bytes row = 1;
inline bool Get::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Get::clear_row() {
  row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Get::row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.row)
  return row_.GetNoArena();
}
inline void Get::set_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Get.row)
}
inline void Get::set_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Get.row)
}
inline void Get::set_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Get.row)
}
inline void Get::set_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Get.row)
}
inline std::string* Get::mutable_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.row)
  return row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Get::release_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.Get.row)
  if (!has_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Get::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Get.row)
}

// repeated .hbase.pb.Column column = 2;
inline int Get::column_size() const {
  return column_.size();
}
inline void Get::clear_column() {
  column_.Clear();
}
inline ::hbase::pb::Column* Get::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.column)
  return column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >*
Get::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Get.column)
  return &column_;
}
inline const ::hbase::pb::Column& Get::column(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.column)
  return column_.Get(index);
}
inline ::hbase::pb::Column* Get::add_column() {
  // @@protoc_insertion_point(field_add:hbase.pb.Get.column)
  return column_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >&
Get::column() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Get.column)
  return column_;
}

// repeated .hbase.pb.NameBytesPair attribute = 3;
inline int Get::attribute_size() const {
  return attribute_.size();
}
inline ::hbase::pb::NameBytesPair* Get::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.attribute)
  return attribute_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
Get::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Get.attribute)
  return &attribute_;
}
inline const ::hbase::pb::NameBytesPair& Get::attribute(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.attribute)
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* Get::add_attribute() {
  // @@protoc_insertion_point(field_add:hbase.pb.Get.attribute)
  return attribute_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
Get::attribute() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Get.attribute)
  return attribute_;
}

// optional .hbase.pb.Filter filter = 4;
inline bool Get::has_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::Filter& Get::filter() const {
  const ::hbase::pb::Filter* p = filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.Get.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Filter*>(
      &::hbase::pb::_Filter_default_instance_);
}
inline ::hbase::pb::Filter* Get::release_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.Get.filter)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::Filter* Get::mutable_filter() {
  _has_bits_[0] |= 0x00000002u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Filter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.filter)
  return filter_;
}
inline void Get::set_allocated_filter(::hbase::pb::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Get.filter)
}

// optional .hbase.pb.TimeRange time_range = 5;
inline bool Get::has_time_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::TimeRange& Get::time_range() const {
  const ::hbase::pb::TimeRange* p = time_range_;
  // @@protoc_insertion_point(field_get:hbase.pb.Get.time_range)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimeRange*>(
      &::hbase::pb::_TimeRange_default_instance_);
}
inline ::hbase::pb::TimeRange* Get::release_time_range() {
  // @@protoc_insertion_point(field_release:hbase.pb.Get.time_range)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimeRange* Get::mutable_time_range() {
  _has_bits_[0] |= 0x00000004u;
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimeRange>(GetArenaNoVirtual());
    time_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.time_range)
  return time_range_;
}
inline void Get::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Get.time_range)
}

// optional uint32 max_versions = 6 [default = 1];
inline bool Get::has_max_versions() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Get::clear_max_versions() {
  max_versions_ = 1u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Get::max_versions() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.max_versions)
  return max_versions_;
}
inline void Get::set_max_versions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  max_versions_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.max_versions)
}

// optional bool cache_blocks = 7 [default = true];
inline bool Get::has_cache_blocks() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Get::clear_cache_blocks() {
  cache_blocks_ = true;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Get::cache_blocks() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.cache_blocks)
  return cache_blocks_;
}
inline void Get::set_cache_blocks(bool value) {
  _has_bits_[0] |= 0x00000400u;
  cache_blocks_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.cache_blocks)
}

// optional uint32 store_limit = 8;
inline bool Get::has_store_limit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Get::clear_store_limit() {
  store_limit_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Get::store_limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.store_limit)
  return store_limit_;
}
inline void Get::set_store_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  store_limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.store_limit)
}

// optional uint32 store_offset = 9;
inline bool Get::has_store_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Get::clear_store_offset() {
  store_offset_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Get::store_offset() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.store_offset)
  return store_offset_;
}
inline void Get::set_store_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  store_offset_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.store_offset)
}

// optional bool existence_only = 10 [default = false];
inline bool Get::has_existence_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Get::clear_existence_only() {
  existence_only_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Get::existence_only() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.existence_only)
  return existence_only_;
}
inline void Get::set_existence_only(bool value) {
  _has_bits_[0] |= 0x00000020u;
  existence_only_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.existence_only)
}

// optional bool closest_row_before = 11 [default = false];
inline bool Get::has_closest_row_before() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Get::clear_closest_row_before() {
  closest_row_before_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Get::closest_row_before() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.closest_row_before)
  return closest_row_before_;
}
inline void Get::set_closest_row_before(bool value) {
  _has_bits_[0] |= 0x00000040u;
  closest_row_before_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.closest_row_before)
}

// optional .hbase.pb.Consistency consistency = 12 [default = STRONG];
inline bool Get::has_consistency() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Get::clear_consistency() {
  consistency_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::hbase::pb::Consistency Get::consistency() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.consistency)
  return static_cast< ::hbase::pb::Consistency >(consistency_);
}
inline void Get::set_consistency(::hbase::pb::Consistency value) {
  assert(::hbase::pb::Consistency_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  consistency_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.consistency)
}

// repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 13;
inline int Get::cf_time_range_size() const {
  return cf_time_range_.size();
}
inline ::hbase::pb::ColumnFamilyTimeRange* Get::mutable_cf_time_range(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Get.cf_time_range)
  return cf_time_range_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
Get::mutable_cf_time_range() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Get.cf_time_range)
  return &cf_time_range_;
}
inline const ::hbase::pb::ColumnFamilyTimeRange& Get::cf_time_range(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.cf_time_range)
  return cf_time_range_.Get(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Get::add_cf_time_range() {
  // @@protoc_insertion_point(field_add:hbase.pb.Get.cf_time_range)
  return cf_time_range_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
Get::cf_time_range() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Get.cf_time_range)
  return cf_time_range_;
}

// optional bool load_column_families_on_demand = 14;
inline bool Get::has_load_column_families_on_demand() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Get::clear_load_column_families_on_demand() {
  load_column_families_on_demand_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Get::load_column_families_on_demand() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Get.load_column_families_on_demand)
  return load_column_families_on_demand_;
}
inline void Get::set_load_column_families_on_demand(bool value) {
  _has_bits_[0] |= 0x00000080u;
  load_column_families_on_demand_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Get.load_column_families_on_demand)
}

// -------------------------------------------------------------------

// Result

// repeated .hbase.pb.Cell cell = 1;
inline int Result::cell_size() const {
  return cell_.size();
}
inline ::hbase::pb::Cell* Result::mutable_cell(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Result.cell)
  return cell_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Cell >*
Result::mutable_cell() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Result.cell)
  return &cell_;
}
inline const ::hbase::pb::Cell& Result::cell(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Result.cell)
  return cell_.Get(index);
}
inline ::hbase::pb::Cell* Result::add_cell() {
  // @@protoc_insertion_point(field_add:hbase.pb.Result.cell)
  return cell_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Cell >&
Result::cell() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Result.cell)
  return cell_;
}

// optional int32 associated_cell_count = 2;
inline bool Result::has_associated_cell_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::clear_associated_cell_count() {
  associated_cell_count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Result::associated_cell_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Result.associated_cell_count)
  return associated_cell_count_;
}
inline void Result::set_associated_cell_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  associated_cell_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Result.associated_cell_count)
}

// optional bool exists = 3;
inline bool Result::has_exists() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::clear_exists() {
  exists_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool Result::exists() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Result.exists)
  return exists_;
}
inline void Result::set_exists(bool value) {
  _has_bits_[0] |= 0x00000002u;
  exists_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Result.exists)
}

// optional bool stale = 4 [default = false];
inline bool Result::has_stale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::clear_stale() {
  stale_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Result::stale() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Result.stale)
  return stale_;
}
inline void Result::set_stale(bool value) {
  _has_bits_[0] |= 0x00000004u;
  stale_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Result.stale)
}

// optional bool partial = 5 [default = false];
inline bool Result::has_partial() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::clear_partial() {
  partial_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Result::partial() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Result.partial)
  return partial_;
}
inline void Result::set_partial(bool value) {
  _has_bits_[0] |= 0x00000008u;
  partial_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Result.partial)
}

// -------------------------------------------------------------------

// GetRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool GetRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& GetRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.GetRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* GetRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetRequest.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* GetRequest::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetRequest.region)
  return region_;
}
inline void GetRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetRequest.region)
}

// required .hbase.pb.Get get = 2;
inline bool GetRequest::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetRequest::clear_get() {
  if (get_ != nullptr) get_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::Get& GetRequest::get() const {
  const ::hbase::pb::Get* p = get_;
  // @@protoc_insertion_point(field_get:hbase.pb.GetRequest.get)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Get*>(
      &::hbase::pb::_Get_default_instance_);
}
inline ::hbase::pb::Get* GetRequest::release_get() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetRequest.get)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Get* temp = get_;
  get_ = nullptr;
  return temp;
}
inline ::hbase::pb::Get* GetRequest::mutable_get() {
  _has_bits_[0] |= 0x00000002u;
  if (get_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Get>(GetArenaNoVirtual());
    get_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetRequest.get)
  return get_;
}
inline void GetRequest::set_allocated_get(::hbase::pb::Get* get) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete get_;
  }
  if (get) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      get = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  get_ = get;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetRequest.get)
}

// -------------------------------------------------------------------

// GetResponse

// optional .hbase.pb.Result result = 1;
inline bool GetResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Result& GetResponse::result() const {
  const ::hbase::pb::Result* p = result_;
  // @@protoc_insertion_point(field_get:hbase.pb.GetResponse.result)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Result*>(
      &::hbase::pb::_Result_default_instance_);
}
inline ::hbase::pb::Result* GetResponse::release_result() {
  // @@protoc_insertion_point(field_release:hbase.pb.GetResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hbase::pb::Result* GetResponse::mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Result>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.GetResponse.result)
  return result_;
}
inline void GetResponse::set_allocated_result(::hbase::pb::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.GetResponse.result)
}

// -------------------------------------------------------------------

// Condition

// required bytes row = 1;
inline bool Condition::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::clear_row() {
  row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Condition::row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.row)
  return row_.GetNoArena();
}
inline void Condition::set_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Condition.row)
}
inline void Condition::set_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Condition.row)
}
inline void Condition::set_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Condition.row)
}
inline void Condition::set_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Condition.row)
}
inline std::string* Condition::mutable_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Condition.row)
  return row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Condition::release_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.Condition.row)
  if (!has_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Condition::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Condition.row)
}

// required bytes family = 2;
inline bool Condition::has_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Condition::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Condition::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.family)
  return family_.GetNoArena();
}
inline void Condition::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Condition.family)
}
inline void Condition::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Condition.family)
}
inline void Condition::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Condition.family)
}
inline void Condition::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Condition.family)
}
inline std::string* Condition::mutable_family() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Condition.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Condition::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.Condition.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Condition::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Condition.family)
}

// required bytes qualifier = 3;
inline bool Condition::has_qualifier() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Condition::clear_qualifier() {
  qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Condition::qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.qualifier)
  return qualifier_.GetNoArena();
}
inline void Condition::set_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Condition.qualifier)
}
inline void Condition::set_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Condition.qualifier)
}
inline void Condition::set_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Condition.qualifier)
}
inline void Condition::set_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Condition.qualifier)
}
inline std::string* Condition::mutable_qualifier() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Condition.qualifier)
  return qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Condition::release_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.Condition.qualifier)
  if (!has_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Condition::set_allocated_qualifier(std::string* qualifier) {
  if (qualifier != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Condition.qualifier)
}

// required .hbase.pb.CompareType compare_type = 4;
inline bool Condition::has_compare_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Condition::clear_compare_type() {
  compare_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hbase::pb::CompareType Condition::compare_type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.compare_type)
  return static_cast< ::hbase::pb::CompareType >(compare_type_);
}
inline void Condition::set_compare_type(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  compare_type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Condition.compare_type)
}

// required .hbase.pb.Comparator comparator = 5;
inline bool Condition::has_comparator() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::hbase::pb::Comparator& Condition::comparator() const {
  const ::hbase::pb::Comparator* p = comparator_;
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.comparator)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Comparator*>(
      &::hbase::pb::_Comparator_default_instance_);
}
inline ::hbase::pb::Comparator* Condition::release_comparator() {
  // @@protoc_insertion_point(field_release:hbase.pb.Condition.comparator)
  _has_bits_[0] &= ~0x00000008u;
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = nullptr;
  return temp;
}
inline ::hbase::pb::Comparator* Condition::mutable_comparator() {
  _has_bits_[0] |= 0x00000008u;
  if (comparator_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Comparator>(GetArenaNoVirtual());
    comparator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Condition.comparator)
  return comparator_;
}
inline void Condition::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(comparator_);
  }
  if (comparator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      comparator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  comparator_ = comparator;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Condition.comparator)
}

// optional .hbase.pb.TimeRange time_range = 6;
inline bool Condition::has_time_range() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline const ::hbase::pb::TimeRange& Condition::time_range() const {
  const ::hbase::pb::TimeRange* p = time_range_;
  // @@protoc_insertion_point(field_get:hbase.pb.Condition.time_range)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimeRange*>(
      &::hbase::pb::_TimeRange_default_instance_);
}
inline ::hbase::pb::TimeRange* Condition::release_time_range() {
  // @@protoc_insertion_point(field_release:hbase.pb.Condition.time_range)
  _has_bits_[0] &= ~0x00000010u;
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimeRange* Condition::mutable_time_range() {
  _has_bits_[0] |= 0x00000010u;
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimeRange>(GetArenaNoVirtual());
    time_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Condition.time_range)
  return time_range_;
}
inline void Condition::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Condition.time_range)
}

// -------------------------------------------------------------------

// MutationProto_ColumnValue_QualifierValue

// optional bytes qualifier = 1;
inline bool MutationProto_ColumnValue_QualifierValue::has_qualifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_qualifier() {
  qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MutationProto_ColumnValue_QualifierValue::qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
  return qualifier_.GetNoArena();
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
}
inline void MutationProto_ColumnValue_QualifierValue::set_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
}
inline std::string* MutationProto_ColumnValue_QualifierValue::mutable_qualifier() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
  return qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MutationProto_ColumnValue_QualifierValue::release_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
  if (!has_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_qualifier(std::string* qualifier) {
  if (qualifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.ColumnValue.QualifierValue.qualifier)
}

// optional bytes value = 2;
inline bool MutationProto_ColumnValue_QualifierValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MutationProto_ColumnValue_QualifierValue::value() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
  return value_.GetNoArena();
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
}
inline void MutationProto_ColumnValue_QualifierValue::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
}
inline std::string* MutationProto_ColumnValue_QualifierValue::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MutationProto_ColumnValue_QualifierValue::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.ColumnValue.QualifierValue.value)
}

// optional uint64 timestamp = 3;
inline bool MutationProto_ColumnValue_QualifierValue::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MutationProto_ColumnValue_QualifierValue::timestamp() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.QualifierValue.timestamp)
  return timestamp_;
}
inline void MutationProto_ColumnValue_QualifierValue::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.QualifierValue.timestamp)
}

// optional .hbase.pb.MutationProto.DeleteType delete_type = 4;
inline bool MutationProto_ColumnValue_QualifierValue::has_delete_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_delete_type() {
  delete_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::hbase::pb::MutationProto_DeleteType MutationProto_ColumnValue_QualifierValue::delete_type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.QualifierValue.delete_type)
  return static_cast< ::hbase::pb::MutationProto_DeleteType >(delete_type_);
}
inline void MutationProto_ColumnValue_QualifierValue::set_delete_type(::hbase::pb::MutationProto_DeleteType value) {
  assert(::hbase::pb::MutationProto_DeleteType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  delete_type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.QualifierValue.delete_type)
}

// optional bytes tags = 5;
inline bool MutationProto_ColumnValue_QualifierValue::has_tags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutationProto_ColumnValue_QualifierValue::clear_tags() {
  tags_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MutationProto_ColumnValue_QualifierValue::tags() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
  return tags_.GetNoArena();
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  tags_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
}
inline void MutationProto_ColumnValue_QualifierValue::set_tags(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  tags_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
}
inline std::string* MutationProto_ColumnValue_QualifierValue::mutable_tags() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
  return tags_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MutationProto_ColumnValue_QualifierValue::release_tags() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
  if (!has_tags()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return tags_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MutationProto_ColumnValue_QualifierValue::set_allocated_tags(std::string* tags) {
  if (tags != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tags_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tags);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.ColumnValue.QualifierValue.tags)
}

// -------------------------------------------------------------------

// MutationProto_ColumnValue

// required bytes family = 1;
inline bool MutationProto_ColumnValue::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto_ColumnValue::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MutationProto_ColumnValue::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.family)
  return family_.GetNoArena();
}
inline void MutationProto_ColumnValue::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.ColumnValue.family)
}
inline void MutationProto_ColumnValue::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.MutationProto.ColumnValue.family)
}
inline void MutationProto_ColumnValue::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.MutationProto.ColumnValue.family)
}
inline void MutationProto_ColumnValue::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MutationProto.ColumnValue.family)
}
inline std::string* MutationProto_ColumnValue::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.ColumnValue.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MutationProto_ColumnValue::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.ColumnValue.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MutationProto_ColumnValue::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.ColumnValue.family)
}

// repeated .hbase.pb.MutationProto.ColumnValue.QualifierValue qualifier_value = 2;
inline int MutationProto_ColumnValue::qualifier_value_size() const {
  return qualifier_value_.size();
}
inline void MutationProto_ColumnValue::clear_qualifier_value() {
  qualifier_value_.Clear();
}
inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* MutationProto_ColumnValue::mutable_qualifier_value(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.ColumnValue.qualifier_value)
  return qualifier_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >*
MutationProto_ColumnValue::mutable_qualifier_value() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MutationProto.ColumnValue.qualifier_value)
  return &qualifier_value_;
}
inline const ::hbase::pb::MutationProto_ColumnValue_QualifierValue& MutationProto_ColumnValue::qualifier_value(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.ColumnValue.qualifier_value)
  return qualifier_value_.Get(index);
}
inline ::hbase::pb::MutationProto_ColumnValue_QualifierValue* MutationProto_ColumnValue::add_qualifier_value() {
  // @@protoc_insertion_point(field_add:hbase.pb.MutationProto.ColumnValue.qualifier_value)
  return qualifier_value_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue_QualifierValue >&
MutationProto_ColumnValue::qualifier_value() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MutationProto.ColumnValue.qualifier_value)
  return qualifier_value_;
}

// -------------------------------------------------------------------

// MutationProto

// optional bytes row = 1;
inline bool MutationProto::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutationProto::clear_row() {
  row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MutationProto::row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.row)
  return row_.GetNoArena();
}
inline void MutationProto::set_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.row)
}
inline void MutationProto::set_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.MutationProto.row)
}
inline void MutationProto::set_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.MutationProto.row)
}
inline void MutationProto::set_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MutationProto.row)
}
inline std::string* MutationProto::mutable_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.row)
  return row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* MutationProto::release_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.row)
  if (!has_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void MutationProto::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.row)
}

// optional .hbase.pb.MutationProto.MutationType mutate_type = 2;
inline bool MutationProto::has_mutate_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutationProto::clear_mutate_type() {
  mutate_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hbase::pb::MutationProto_MutationType MutationProto::mutate_type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.mutate_type)
  return static_cast< ::hbase::pb::MutationProto_MutationType >(mutate_type_);
}
inline void MutationProto::set_mutate_type(::hbase::pb::MutationProto_MutationType value) {
  assert(::hbase::pb::MutationProto_MutationType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  mutate_type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.mutate_type)
}

// repeated .hbase.pb.MutationProto.ColumnValue column_value = 3;
inline int MutationProto::column_value_size() const {
  return column_value_.size();
}
inline void MutationProto::clear_column_value() {
  column_value_.Clear();
}
inline ::hbase::pb::MutationProto_ColumnValue* MutationProto::mutable_column_value(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.column_value)
  return column_value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >*
MutationProto::mutable_column_value() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MutationProto.column_value)
  return &column_value_;
}
inline const ::hbase::pb::MutationProto_ColumnValue& MutationProto::column_value(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.column_value)
  return column_value_.Get(index);
}
inline ::hbase::pb::MutationProto_ColumnValue* MutationProto::add_column_value() {
  // @@protoc_insertion_point(field_add:hbase.pb.MutationProto.column_value)
  return column_value_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::MutationProto_ColumnValue >&
MutationProto::column_value() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MutationProto.column_value)
  return column_value_;
}

// optional uint64 timestamp = 4;
inline bool MutationProto::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutationProto::clear_timestamp() {
  timestamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MutationProto::timestamp() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.timestamp)
  return timestamp_;
}
inline void MutationProto::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.timestamp)
}

// repeated .hbase.pb.NameBytesPair attribute = 5;
inline int MutationProto::attribute_size() const {
  return attribute_.size();
}
inline ::hbase::pb::NameBytesPair* MutationProto::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.attribute)
  return attribute_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
MutationProto::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MutationProto.attribute)
  return &attribute_;
}
inline const ::hbase::pb::NameBytesPair& MutationProto::attribute(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.attribute)
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* MutationProto::add_attribute() {
  // @@protoc_insertion_point(field_add:hbase.pb.MutationProto.attribute)
  return attribute_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
MutationProto::attribute() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MutationProto.attribute)
  return attribute_;
}

// optional .hbase.pb.MutationProto.Durability durability = 6 [default = USE_DEFAULT];
inline bool MutationProto::has_durability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MutationProto::clear_durability() {
  durability_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::hbase::pb::MutationProto_Durability MutationProto::durability() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.durability)
  return static_cast< ::hbase::pb::MutationProto_Durability >(durability_);
}
inline void MutationProto::set_durability(::hbase::pb::MutationProto_Durability value) {
  assert(::hbase::pb::MutationProto_Durability_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  durability_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.durability)
}

// optional .hbase.pb.TimeRange time_range = 7;
inline bool MutationProto::has_time_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::TimeRange& MutationProto::time_range() const {
  const ::hbase::pb::TimeRange* p = time_range_;
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.time_range)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimeRange*>(
      &::hbase::pb::_TimeRange_default_instance_);
}
inline ::hbase::pb::TimeRange* MutationProto::release_time_range() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutationProto.time_range)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimeRange* MutationProto::mutable_time_range() {
  _has_bits_[0] |= 0x00000002u;
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimeRange>(GetArenaNoVirtual());
    time_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutationProto.time_range)
  return time_range_;
}
inline void MutationProto::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutationProto.time_range)
}

// optional int32 associated_cell_count = 8;
inline bool MutationProto::has_associated_cell_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MutationProto::clear_associated_cell_count() {
  associated_cell_count_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 MutationProto::associated_cell_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.associated_cell_count)
  return associated_cell_count_;
}
inline void MutationProto::set_associated_cell_count(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  associated_cell_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.associated_cell_count)
}

// optional uint64 nonce = 9;
inline bool MutationProto::has_nonce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MutationProto::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MutationProto::nonce() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutationProto.nonce)
  return nonce_;
}
inline void MutationProto::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  nonce_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutationProto.nonce)
}

// -------------------------------------------------------------------

// MutateRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool MutateRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& MutateRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.MutateRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* MutateRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutateRequest.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* MutateRequest::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutateRequest.region)
  return region_;
}
inline void MutateRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutateRequest.region)
}

// required .hbase.pb.MutationProto mutation = 2;
inline bool MutateRequest::has_mutation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutateRequest::clear_mutation() {
  if (mutation_ != nullptr) mutation_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::MutationProto& MutateRequest::mutation() const {
  const ::hbase::pb::MutationProto* p = mutation_;
  // @@protoc_insertion_point(field_get:hbase.pb.MutateRequest.mutation)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::MutationProto*>(
      &::hbase::pb::_MutationProto_default_instance_);
}
inline ::hbase::pb::MutationProto* MutateRequest::release_mutation() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutateRequest.mutation)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::MutationProto* temp = mutation_;
  mutation_ = nullptr;
  return temp;
}
inline ::hbase::pb::MutationProto* MutateRequest::mutable_mutation() {
  _has_bits_[0] |= 0x00000002u;
  if (mutation_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::MutationProto>(GetArenaNoVirtual());
    mutation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutateRequest.mutation)
  return mutation_;
}
inline void MutateRequest::set_allocated_mutation(::hbase::pb::MutationProto* mutation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mutation_;
  }
  if (mutation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mutation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mutation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  mutation_ = mutation;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutateRequest.mutation)
}

// optional .hbase.pb.Condition condition = 3;
inline bool MutateRequest::has_condition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MutateRequest::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::Condition& MutateRequest::condition() const {
  const ::hbase::pb::Condition* p = condition_;
  // @@protoc_insertion_point(field_get:hbase.pb.MutateRequest.condition)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Condition*>(
      &::hbase::pb::_Condition_default_instance_);
}
inline ::hbase::pb::Condition* MutateRequest::release_condition() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutateRequest.condition)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::hbase::pb::Condition* MutateRequest::mutable_condition() {
  _has_bits_[0] |= 0x00000004u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Condition>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutateRequest.condition)
  return condition_;
}
inline void MutateRequest::set_allocated_condition(::hbase::pb::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutateRequest.condition)
}

// optional uint64 nonce_group = 4;
inline bool MutateRequest::has_nonce_group() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MutateRequest::clear_nonce_group() {
  nonce_group_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MutateRequest::nonce_group() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutateRequest.nonce_group)
  return nonce_group_;
}
inline void MutateRequest::set_nonce_group(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  nonce_group_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutateRequest.nonce_group)
}

// -------------------------------------------------------------------

// MutateResponse

// optional .hbase.pb.Result result = 1;
inline bool MutateResponse::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MutateResponse::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Result& MutateResponse::result() const {
  const ::hbase::pb::Result* p = result_;
  // @@protoc_insertion_point(field_get:hbase.pb.MutateResponse.result)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Result*>(
      &::hbase::pb::_Result_default_instance_);
}
inline ::hbase::pb::Result* MutateResponse::release_result() {
  // @@protoc_insertion_point(field_release:hbase.pb.MutateResponse.result)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hbase::pb::Result* MutateResponse::mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Result>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MutateResponse.result)
  return result_;
}
inline void MutateResponse::set_allocated_result(::hbase::pb::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MutateResponse.result)
}

// optional bool processed = 2;
inline bool MutateResponse::has_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MutateResponse::clear_processed() {
  processed_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MutateResponse::processed() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MutateResponse.processed)
  return processed_;
}
inline void MutateResponse::set_processed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  processed_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MutateResponse.processed)
}

// -------------------------------------------------------------------

// Scan

// repeated .hbase.pb.Column column = 1;
inline int Scan::column_size() const {
  return column_.size();
}
inline void Scan::clear_column() {
  column_.Clear();
}
inline ::hbase::pb::Column* Scan::mutable_column(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.column)
  return column_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >*
Scan::mutable_column() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Scan.column)
  return &column_;
}
inline const ::hbase::pb::Column& Scan::column(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.column)
  return column_.Get(index);
}
inline ::hbase::pb::Column* Scan::add_column() {
  // @@protoc_insertion_point(field_add:hbase.pb.Scan.column)
  return column_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Column >&
Scan::column() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Scan.column)
  return column_;
}

// repeated .hbase.pb.NameBytesPair attribute = 2;
inline int Scan::attribute_size() const {
  return attribute_.size();
}
inline ::hbase::pb::NameBytesPair* Scan::mutable_attribute(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.attribute)
  return attribute_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >*
Scan::mutable_attribute() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Scan.attribute)
  return &attribute_;
}
inline const ::hbase::pb::NameBytesPair& Scan::attribute(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.attribute)
  return attribute_.Get(index);
}
inline ::hbase::pb::NameBytesPair* Scan::add_attribute() {
  // @@protoc_insertion_point(field_add:hbase.pb.Scan.attribute)
  return attribute_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameBytesPair >&
Scan::attribute() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Scan.attribute)
  return attribute_;
}

// optional bytes start_row = 3;
inline bool Scan::has_start_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scan::clear_start_row() {
  start_row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Scan::start_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.start_row)
  return start_row_.GetNoArena();
}
inline void Scan::set_start_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.start_row)
}
inline void Scan::set_start_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Scan.start_row)
}
inline void Scan::set_start_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Scan.start_row)
}
inline void Scan::set_start_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Scan.start_row)
}
inline std::string* Scan::mutable_start_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.start_row)
  return start_row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Scan::release_start_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.Scan.start_row)
  if (!has_start_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Scan::set_allocated_start_row(std::string* start_row) {
  if (start_row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Scan.start_row)
}

// optional bytes stop_row = 4;
inline bool Scan::has_stop_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Scan::clear_stop_row() {
  stop_row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Scan::stop_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.stop_row)
  return stop_row_.GetNoArena();
}
inline void Scan::set_stop_row(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.stop_row)
}
inline void Scan::set_stop_row(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Scan.stop_row)
}
inline void Scan::set_stop_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Scan.stop_row)
}
inline void Scan::set_stop_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Scan.stop_row)
}
inline std::string* Scan::mutable_stop_row() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.stop_row)
  return stop_row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Scan::release_stop_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.Scan.stop_row)
  if (!has_stop_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return stop_row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Scan::set_allocated_stop_row(std::string* stop_row) {
  if (stop_row != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stop_row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stop_row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Scan.stop_row)
}

// optional .hbase.pb.Filter filter = 5;
inline bool Scan::has_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::Filter& Scan::filter() const {
  const ::hbase::pb::Filter* p = filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Filter*>(
      &::hbase::pb::_Filter_default_instance_);
}
inline ::hbase::pb::Filter* Scan::release_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.Scan.filter)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::Filter* Scan::mutable_filter() {
  _has_bits_[0] |= 0x00000004u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Filter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.filter)
  return filter_;
}
inline void Scan::set_allocated_filter(::hbase::pb::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(filter_);
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Scan.filter)
}

// optional .hbase.pb.TimeRange time_range = 6;
inline bool Scan::has_time_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::hbase::pb::TimeRange& Scan::time_range() const {
  const ::hbase::pb::TimeRange* p = time_range_;
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.time_range)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimeRange*>(
      &::hbase::pb::_TimeRange_default_instance_);
}
inline ::hbase::pb::TimeRange* Scan::release_time_range() {
  // @@protoc_insertion_point(field_release:hbase.pb.Scan.time_range)
  _has_bits_[0] &= ~0x00000008u;
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimeRange* Scan::mutable_time_range() {
  _has_bits_[0] |= 0x00000008u;
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimeRange>(GetArenaNoVirtual());
    time_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.time_range)
  return time_range_;
}
inline void Scan::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_range_);
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Scan.time_range)
}

// optional uint32 max_versions = 7 [default = 1];
inline bool Scan::has_max_versions() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Scan::clear_max_versions() {
  max_versions_ = 1u;
  _has_bits_[0] &= ~0x00040000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Scan::max_versions() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.max_versions)
  return max_versions_;
}
inline void Scan::set_max_versions(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00040000u;
  max_versions_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.max_versions)
}

// optional bool cache_blocks = 8 [default = true];
inline bool Scan::has_cache_blocks() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Scan::clear_cache_blocks() {
  cache_blocks_ = true;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool Scan::cache_blocks() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.cache_blocks)
  return cache_blocks_;
}
inline void Scan::set_cache_blocks(bool value) {
  _has_bits_[0] |= 0x00080000u;
  cache_blocks_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.cache_blocks)
}

// optional uint32 batch_size = 9;
inline bool Scan::has_batch_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Scan::clear_batch_size() {
  batch_size_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Scan::batch_size() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.batch_size)
  return batch_size_;
}
inline void Scan::set_batch_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  batch_size_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.batch_size)
}

// optional uint64 max_result_size = 10;
inline bool Scan::has_max_result_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Scan::clear_max_result_size() {
  max_result_size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Scan::max_result_size() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.max_result_size)
  return max_result_size_;
}
inline void Scan::set_max_result_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  max_result_size_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.max_result_size)
}

// optional uint32 store_limit = 11;
inline bool Scan::has_store_limit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Scan::clear_store_limit() {
  store_limit_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Scan::store_limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.store_limit)
  return store_limit_;
}
inline void Scan::set_store_limit(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  store_limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.store_limit)
}

// optional uint32 store_offset = 12;
inline bool Scan::has_store_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Scan::clear_store_offset() {
  store_offset_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Scan::store_offset() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.store_offset)
  return store_offset_;
}
inline void Scan::set_store_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  store_offset_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.store_offset)
}

// optional bool load_column_families_on_demand = 13;
inline bool Scan::has_load_column_families_on_demand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Scan::clear_load_column_families_on_demand() {
  load_column_families_on_demand_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Scan::load_column_families_on_demand() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.load_column_families_on_demand)
  return load_column_families_on_demand_;
}
inline void Scan::set_load_column_families_on_demand(bool value) {
  _has_bits_[0] |= 0x00000100u;
  load_column_families_on_demand_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.load_column_families_on_demand)
}

// optional bool small = 14 [deprecated = true];
inline bool Scan::has_small() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Scan::clear_small() {
  small_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Scan::small() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.small)
  return small_;
}
inline void Scan::set_small(bool value) {
  _has_bits_[0] |= 0x00000200u;
  small_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.small)
}

// optional bool reversed = 15 [default = false];
inline bool Scan::has_reversed() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Scan::clear_reversed() {
  reversed_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Scan::reversed() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.reversed)
  return reversed_;
}
inline void Scan::set_reversed(bool value) {
  _has_bits_[0] |= 0x00000400u;
  reversed_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.reversed)
}

// optional .hbase.pb.Consistency consistency = 16 [default = STRONG];
inline bool Scan::has_consistency() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Scan::clear_consistency() {
  consistency_ = 0;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::hbase::pb::Consistency Scan::consistency() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.consistency)
  return static_cast< ::hbase::pb::Consistency >(consistency_);
}
inline void Scan::set_consistency(::hbase::pb::Consistency value) {
  assert(::hbase::pb::Consistency_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  consistency_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.consistency)
}

// optional uint32 caching = 17;
inline bool Scan::has_caching() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Scan::clear_caching() {
  caching_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Scan::caching() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.caching)
  return caching_;
}
inline void Scan::set_caching(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  caching_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.caching)
}

// optional bool allow_partial_results = 18;
inline bool Scan::has_allow_partial_results() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Scan::clear_allow_partial_results() {
  allow_partial_results_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool Scan::allow_partial_results() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.allow_partial_results)
  return allow_partial_results_;
}
inline void Scan::set_allow_partial_results(bool value) {
  _has_bits_[0] |= 0x00000800u;
  allow_partial_results_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.allow_partial_results)
}

// repeated .hbase.pb.ColumnFamilyTimeRange cf_time_range = 19;
inline int Scan::cf_time_range_size() const {
  return cf_time_range_.size();
}
inline ::hbase::pb::ColumnFamilyTimeRange* Scan::mutable_cf_time_range(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.Scan.cf_time_range)
  return cf_time_range_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >*
Scan::mutable_cf_time_range() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.Scan.cf_time_range)
  return &cf_time_range_;
}
inline const ::hbase::pb::ColumnFamilyTimeRange& Scan::cf_time_range(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.cf_time_range)
  return cf_time_range_.Get(index);
}
inline ::hbase::pb::ColumnFamilyTimeRange* Scan::add_cf_time_range() {
  // @@protoc_insertion_point(field_add:hbase.pb.Scan.cf_time_range)
  return cf_time_range_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilyTimeRange >&
Scan::cf_time_range() const {
  // @@protoc_insertion_point(field_list:hbase.pb.Scan.cf_time_range)
  return cf_time_range_;
}

// optional uint64 mvcc_read_point = 20 [default = 0];
inline bool Scan::has_mvcc_read_point() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Scan::clear_mvcc_read_point() {
  mvcc_read_point_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Scan::mvcc_read_point() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.mvcc_read_point)
  return mvcc_read_point_;
}
inline void Scan::set_mvcc_read_point(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  mvcc_read_point_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.mvcc_read_point)
}

// optional bool include_start_row = 21 [default = true];
inline bool Scan::has_include_start_row() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Scan::clear_include_start_row() {
  include_start_row_ = true;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool Scan::include_start_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.include_start_row)
  return include_start_row_;
}
inline void Scan::set_include_start_row(bool value) {
  _has_bits_[0] |= 0x00100000u;
  include_start_row_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.include_start_row)
}

// optional bool include_stop_row = 22 [default = false];
inline bool Scan::has_include_stop_row() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Scan::clear_include_stop_row() {
  include_stop_row_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool Scan::include_stop_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.include_stop_row)
  return include_stop_row_;
}
inline void Scan::set_include_stop_row(bool value) {
  _has_bits_[0] |= 0x00010000u;
  include_stop_row_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.include_stop_row)
}

// optional .hbase.pb.Scan.ReadType readType = 23 [default = DEFAULT];
inline bool Scan::has_readtype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Scan::clear_readtype() {
  readtype_ = 0;
  _has_bits_[0] &= ~0x00008000u;
}
inline ::hbase::pb::Scan_ReadType Scan::readtype() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.readType)
  return static_cast< ::hbase::pb::Scan_ReadType >(readtype_);
}
inline void Scan::set_readtype(::hbase::pb::Scan_ReadType value) {
  assert(::hbase::pb::Scan_ReadType_IsValid(value));
  _has_bits_[0] |= 0x00008000u;
  readtype_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.readType)
}

// optional bool need_cursor_result = 24 [default = false];
inline bool Scan::has_need_cursor_result() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Scan::clear_need_cursor_result() {
  need_cursor_result_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool Scan::need_cursor_result() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Scan.need_cursor_result)
  return need_cursor_result_;
}
inline void Scan::set_need_cursor_result(bool value) {
  _has_bits_[0] |= 0x00020000u;
  need_cursor_result_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Scan.need_cursor_result)
}

// -------------------------------------------------------------------

// ScanRequest

// optional .hbase.pb.RegionSpecifier region = 1;
inline bool ScanRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& ScanRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* ScanRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.ScanRequest.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* ScanRequest::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ScanRequest.region)
  return region_;
}
inline void ScanRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ScanRequest.region)
}

// optional .hbase.pb.Scan scan = 2;
inline bool ScanRequest::has_scan() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanRequest::clear_scan() {
  if (scan_ != nullptr) scan_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::Scan& ScanRequest::scan() const {
  const ::hbase::pb::Scan* p = scan_;
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.scan)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Scan*>(
      &::hbase::pb::_Scan_default_instance_);
}
inline ::hbase::pb::Scan* ScanRequest::release_scan() {
  // @@protoc_insertion_point(field_release:hbase.pb.ScanRequest.scan)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Scan* temp = scan_;
  scan_ = nullptr;
  return temp;
}
inline ::hbase::pb::Scan* ScanRequest::mutable_scan() {
  _has_bits_[0] |= 0x00000002u;
  if (scan_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Scan>(GetArenaNoVirtual());
    scan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ScanRequest.scan)
  return scan_;
}
inline void ScanRequest::set_allocated_scan(::hbase::pb::Scan* scan) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete scan_;
  }
  if (scan) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scan = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scan, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  scan_ = scan;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ScanRequest.scan)
}

// optional uint64 scanner_id = 3;
inline bool ScanRequest::has_scanner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanRequest::clear_scanner_id() {
  scanner_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanRequest::scanner_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.scanner_id)
  return scanner_id_;
}
inline void ScanRequest::set_scanner_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  scanner_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.scanner_id)
}

// optional uint32 number_of_rows = 4;
inline bool ScanRequest::has_number_of_rows() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScanRequest::clear_number_of_rows() {
  number_of_rows_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScanRequest::number_of_rows() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.number_of_rows)
  return number_of_rows_;
}
inline void ScanRequest::set_number_of_rows(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  number_of_rows_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.number_of_rows)
}

// optional bool close_scanner = 5;
inline bool ScanRequest::has_close_scanner() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScanRequest::clear_close_scanner() {
  close_scanner_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ScanRequest::close_scanner() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.close_scanner)
  return close_scanner_;
}
inline void ScanRequest::set_close_scanner(bool value) {
  _has_bits_[0] |= 0x00000020u;
  close_scanner_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.close_scanner)
}

// optional uint64 next_call_seq = 6;
inline bool ScanRequest::has_next_call_seq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanRequest::clear_next_call_seq() {
  next_call_seq_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanRequest::next_call_seq() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.next_call_seq)
  return next_call_seq_;
}
inline void ScanRequest::set_next_call_seq(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  next_call_seq_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.next_call_seq)
}

// optional bool client_handles_partials = 7;
inline bool ScanRequest::has_client_handles_partials() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScanRequest::clear_client_handles_partials() {
  client_handles_partials_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ScanRequest::client_handles_partials() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.client_handles_partials)
  return client_handles_partials_;
}
inline void ScanRequest::set_client_handles_partials(bool value) {
  _has_bits_[0] |= 0x00000040u;
  client_handles_partials_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.client_handles_partials)
}

// optional bool client_handles_heartbeats = 8;
inline bool ScanRequest::has_client_handles_heartbeats() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScanRequest::clear_client_handles_heartbeats() {
  client_handles_heartbeats_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ScanRequest::client_handles_heartbeats() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.client_handles_heartbeats)
  return client_handles_heartbeats_;
}
inline void ScanRequest::set_client_handles_heartbeats(bool value) {
  _has_bits_[0] |= 0x00000080u;
  client_handles_heartbeats_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.client_handles_heartbeats)
}

// optional bool track_scan_metrics = 9;
inline bool ScanRequest::has_track_scan_metrics() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScanRequest::clear_track_scan_metrics() {
  track_scan_metrics_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool ScanRequest::track_scan_metrics() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.track_scan_metrics)
  return track_scan_metrics_;
}
inline void ScanRequest::set_track_scan_metrics(bool value) {
  _has_bits_[0] |= 0x00000100u;
  track_scan_metrics_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.track_scan_metrics)
}

// optional bool renew = 10 [default = false];
inline bool ScanRequest::has_renew() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScanRequest::clear_renew() {
  renew_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool ScanRequest::renew() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.renew)
  return renew_;
}
inline void ScanRequest::set_renew(bool value) {
  _has_bits_[0] |= 0x00000200u;
  renew_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.renew)
}

// optional uint32 limit_of_rows = 11 [default = 0];
inline bool ScanRequest::has_limit_of_rows() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ScanRequest::clear_limit_of_rows() {
  limit_of_rows_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScanRequest::limit_of_rows() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanRequest.limit_of_rows)
  return limit_of_rows_;
}
inline void ScanRequest::set_limit_of_rows(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000400u;
  limit_of_rows_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanRequest.limit_of_rows)
}

// -------------------------------------------------------------------

// Cursor

// optional bytes row = 1;
inline bool Cursor::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Cursor::clear_row() {
  row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Cursor::row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Cursor.row)
  return row_.GetNoArena();
}
inline void Cursor::set_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Cursor.row)
}
inline void Cursor::set_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Cursor.row)
}
inline void Cursor::set_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Cursor.row)
}
inline void Cursor::set_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Cursor.row)
}
inline std::string* Cursor::mutable_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Cursor.row)
  return row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Cursor::release_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.Cursor.row)
  if (!has_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Cursor::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Cursor.row)
}

// -------------------------------------------------------------------

// ScanResponse

// repeated uint32 cells_per_result = 1;
inline int ScanResponse::cells_per_result_size() const {
  return cells_per_result_.size();
}
inline void ScanResponse::clear_cells_per_result() {
  cells_per_result_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScanResponse::cells_per_result(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.cells_per_result)
  return cells_per_result_.Get(index);
}
inline void ScanResponse::set_cells_per_result(int index, ::PROTOBUF_NAMESPACE_ID::uint32 value) {
  cells_per_result_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.cells_per_result)
}
inline void ScanResponse::add_cells_per_result(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  cells_per_result_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.ScanResponse.cells_per_result)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >&
ScanResponse::cells_per_result() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ScanResponse.cells_per_result)
  return cells_per_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint32 >*
ScanResponse::mutable_cells_per_result() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ScanResponse.cells_per_result)
  return &cells_per_result_;
}

// optional uint64 scanner_id = 2;
inline bool ScanResponse::has_scanner_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanResponse::clear_scanner_id() {
  scanner_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanResponse::scanner_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.scanner_id)
  return scanner_id_;
}
inline void ScanResponse::set_scanner_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  scanner_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.scanner_id)
}

// optional bool more_results = 3;
inline bool ScanResponse::has_more_results() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScanResponse::clear_more_results() {
  more_results_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ScanResponse::more_results() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.more_results)
  return more_results_;
}
inline void ScanResponse::set_more_results(bool value) {
  _has_bits_[0] |= 0x00000010u;
  more_results_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.more_results)
}

// optional uint32 ttl = 4;
inline bool ScanResponse::has_ttl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanResponse::clear_ttl() {
  ttl_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ScanResponse::ttl() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.ttl)
  return ttl_;
}
inline void ScanResponse::set_ttl(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  ttl_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.ttl)
}

// repeated .hbase.pb.Result results = 5;
inline int ScanResponse::results_size() const {
  return results_.size();
}
inline void ScanResponse::clear_results() {
  results_.Clear();
}
inline ::hbase::pb::Result* ScanResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ScanResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Result >*
ScanResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ScanResponse.results)
  return &results_;
}
inline const ::hbase::pb::Result& ScanResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.results)
  return results_.Get(index);
}
inline ::hbase::pb::Result* ScanResponse::add_results() {
  // @@protoc_insertion_point(field_add:hbase.pb.ScanResponse.results)
  return results_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Result >&
ScanResponse::results() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ScanResponse.results)
  return results_;
}

// optional bool stale = 6;
inline bool ScanResponse::has_stale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScanResponse::clear_stale() {
  stale_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool ScanResponse::stale() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.stale)
  return stale_;
}
inline void ScanResponse::set_stale(bool value) {
  _has_bits_[0] |= 0x00000020u;
  stale_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.stale)
}

// repeated bool partial_flag_per_result = 7;
inline int ScanResponse::partial_flag_per_result_size() const {
  return partial_flag_per_result_.size();
}
inline void ScanResponse::clear_partial_flag_per_result() {
  partial_flag_per_result_.Clear();
}
inline bool ScanResponse::partial_flag_per_result(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.partial_flag_per_result)
  return partial_flag_per_result_.Get(index);
}
inline void ScanResponse::set_partial_flag_per_result(int index, bool value) {
  partial_flag_per_result_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.partial_flag_per_result)
}
inline void ScanResponse::add_partial_flag_per_result(bool value) {
  partial_flag_per_result_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.ScanResponse.partial_flag_per_result)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
ScanResponse::partial_flag_per_result() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ScanResponse.partial_flag_per_result)
  return partial_flag_per_result_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
ScanResponse::mutable_partial_flag_per_result() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ScanResponse.partial_flag_per_result)
  return &partial_flag_per_result_;
}

// optional bool more_results_in_region = 8;
inline bool ScanResponse::has_more_results_in_region() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScanResponse::clear_more_results_in_region() {
  more_results_in_region_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool ScanResponse::more_results_in_region() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.more_results_in_region)
  return more_results_in_region_;
}
inline void ScanResponse::set_more_results_in_region(bool value) {
  _has_bits_[0] |= 0x00000040u;
  more_results_in_region_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.more_results_in_region)
}

// optional bool heartbeat_message = 9;
inline bool ScanResponse::has_heartbeat_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScanResponse::clear_heartbeat_message() {
  heartbeat_message_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool ScanResponse::heartbeat_message() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.heartbeat_message)
  return heartbeat_message_;
}
inline void ScanResponse::set_heartbeat_message(bool value) {
  _has_bits_[0] |= 0x00000080u;
  heartbeat_message_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.heartbeat_message)
}

// optional .hbase.pb.ScanMetrics scan_metrics = 10;
inline bool ScanResponse::has_scan_metrics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::ScanMetrics& ScanResponse::scan_metrics() const {
  const ::hbase::pb::ScanMetrics* p = scan_metrics_;
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.scan_metrics)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ScanMetrics*>(
      &::hbase::pb::_ScanMetrics_default_instance_);
}
inline ::hbase::pb::ScanMetrics* ScanResponse::release_scan_metrics() {
  // @@protoc_insertion_point(field_release:hbase.pb.ScanResponse.scan_metrics)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ScanMetrics* temp = scan_metrics_;
  scan_metrics_ = nullptr;
  return temp;
}
inline ::hbase::pb::ScanMetrics* ScanResponse::mutable_scan_metrics() {
  _has_bits_[0] |= 0x00000001u;
  if (scan_metrics_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ScanMetrics>(GetArenaNoVirtual());
    scan_metrics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ScanResponse.scan_metrics)
  return scan_metrics_;
}
inline void ScanResponse::set_allocated_scan_metrics(::hbase::pb::ScanMetrics* scan_metrics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(scan_metrics_);
  }
  if (scan_metrics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      scan_metrics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scan_metrics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  scan_metrics_ = scan_metrics;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ScanResponse.scan_metrics)
}

// optional uint64 mvcc_read_point = 11 [default = 0];
inline bool ScanResponse::has_mvcc_read_point() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScanResponse::clear_mvcc_read_point() {
  mvcc_read_point_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ScanResponse::mvcc_read_point() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.mvcc_read_point)
  return mvcc_read_point_;
}
inline void ScanResponse::set_mvcc_read_point(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  mvcc_read_point_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ScanResponse.mvcc_read_point)
}

// optional .hbase.pb.Cursor cursor = 12;
inline bool ScanResponse::has_cursor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanResponse::clear_cursor() {
  if (cursor_ != nullptr) cursor_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::Cursor& ScanResponse::cursor() const {
  const ::hbase::pb::Cursor* p = cursor_;
  // @@protoc_insertion_point(field_get:hbase.pb.ScanResponse.cursor)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Cursor*>(
      &::hbase::pb::_Cursor_default_instance_);
}
inline ::hbase::pb::Cursor* ScanResponse::release_cursor() {
  // @@protoc_insertion_point(field_release:hbase.pb.ScanResponse.cursor)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Cursor* temp = cursor_;
  cursor_ = nullptr;
  return temp;
}
inline ::hbase::pb::Cursor* ScanResponse::mutable_cursor() {
  _has_bits_[0] |= 0x00000002u;
  if (cursor_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Cursor>(GetArenaNoVirtual());
    cursor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ScanResponse.cursor)
  return cursor_;
}
inline void ScanResponse::set_allocated_cursor(::hbase::pb::Cursor* cursor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cursor_;
  }
  if (cursor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cursor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cursor, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cursor_ = cursor;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ScanResponse.cursor)
}

// -------------------------------------------------------------------

// BulkLoadHFileRequest_FamilyPath

// required bytes family = 1;
inline bool BulkLoadHFileRequest_FamilyPath::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BulkLoadHFileRequest_FamilyPath::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
  return family_.GetNoArena();
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
}
inline void BulkLoadHFileRequest_FamilyPath::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
}
inline std::string* BulkLoadHFileRequest_FamilyPath::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BulkLoadHFileRequest_FamilyPath::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BulkLoadHFileRequest_FamilyPath::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadHFileRequest.FamilyPath.family)
}

// required string path = 2;
inline bool BulkLoadHFileRequest_FamilyPath::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BulkLoadHFileRequest_FamilyPath::clear_path() {
  path_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BulkLoadHFileRequest_FamilyPath::path() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
  return path_.GetNoArena();
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  path_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
}
inline void BulkLoadHFileRequest_FamilyPath::set_path(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  path_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
}
inline std::string* BulkLoadHFileRequest_FamilyPath::mutable_path() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
  return path_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BulkLoadHFileRequest_FamilyPath::release_path() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
  if (!has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return path_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BulkLoadHFileRequest_FamilyPath::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  path_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadHFileRequest.FamilyPath.path)
}

// -------------------------------------------------------------------

// BulkLoadHFileRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool BulkLoadHFileRequest::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& BulkLoadHFileRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* BulkLoadHFileRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadHFileRequest.region)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* BulkLoadHFileRequest::mutable_region() {
  _has_bits_[0] |= 0x00000002u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.region)
  return region_;
}
inline void BulkLoadHFileRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadHFileRequest.region)
}

// repeated .hbase.pb.BulkLoadHFileRequest.FamilyPath family_path = 2;
inline int BulkLoadHFileRequest::family_path_size() const {
  return family_path_.size();
}
inline void BulkLoadHFileRequest::clear_family_path() {
  family_path_.Clear();
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* BulkLoadHFileRequest::mutable_family_path(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.family_path)
  return family_path_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >*
BulkLoadHFileRequest::mutable_family_path() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.BulkLoadHFileRequest.family_path)
  return &family_path_;
}
inline const ::hbase::pb::BulkLoadHFileRequest_FamilyPath& BulkLoadHFileRequest::family_path(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.family_path)
  return family_path_.Get(index);
}
inline ::hbase::pb::BulkLoadHFileRequest_FamilyPath* BulkLoadHFileRequest::add_family_path() {
  // @@protoc_insertion_point(field_add:hbase.pb.BulkLoadHFileRequest.family_path)
  return family_path_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BulkLoadHFileRequest_FamilyPath >&
BulkLoadHFileRequest::family_path() const {
  // @@protoc_insertion_point(field_list:hbase.pb.BulkLoadHFileRequest.family_path)
  return family_path_;
}

// optional bool assign_seq_num = 3;
inline bool BulkLoadHFileRequest::has_assign_seq_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BulkLoadHFileRequest::clear_assign_seq_num() {
  assign_seq_num_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool BulkLoadHFileRequest::assign_seq_num() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.assign_seq_num)
  return assign_seq_num_;
}
inline void BulkLoadHFileRequest::set_assign_seq_num(bool value) {
  _has_bits_[0] |= 0x00000008u;
  assign_seq_num_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileRequest.assign_seq_num)
}

// optional .hbase.pb.DelegationToken fs_token = 4;
inline bool BulkLoadHFileRequest::has_fs_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulkLoadHFileRequest::clear_fs_token() {
  if (fs_token_ != nullptr) fs_token_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::DelegationToken& BulkLoadHFileRequest::fs_token() const {
  const ::hbase::pb::DelegationToken* p = fs_token_;
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.fs_token)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::DelegationToken*>(
      &::hbase::pb::_DelegationToken_default_instance_);
}
inline ::hbase::pb::DelegationToken* BulkLoadHFileRequest::release_fs_token() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadHFileRequest.fs_token)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::DelegationToken* temp = fs_token_;
  fs_token_ = nullptr;
  return temp;
}
inline ::hbase::pb::DelegationToken* BulkLoadHFileRequest::mutable_fs_token() {
  _has_bits_[0] |= 0x00000004u;
  if (fs_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::DelegationToken>(GetArenaNoVirtual());
    fs_token_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.fs_token)
  return fs_token_;
}
inline void BulkLoadHFileRequest::set_allocated_fs_token(::hbase::pb::DelegationToken* fs_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fs_token_;
  }
  if (fs_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fs_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fs_token, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  fs_token_ = fs_token;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadHFileRequest.fs_token)
}

// optional string bulk_token = 5;
inline bool BulkLoadHFileRequest::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileRequest::clear_bulk_token() {
  bulk_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BulkLoadHFileRequest::bulk_token() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.bulk_token)
  return bulk_token_.GetNoArena();
}
inline void BulkLoadHFileRequest::set_bulk_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileRequest.bulk_token)
}
inline void BulkLoadHFileRequest::set_bulk_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BulkLoadHFileRequest.bulk_token)
}
inline void BulkLoadHFileRequest::set_bulk_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BulkLoadHFileRequest.bulk_token)
}
inline void BulkLoadHFileRequest::set_bulk_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BulkLoadHFileRequest.bulk_token)
}
inline std::string* BulkLoadHFileRequest::mutable_bulk_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadHFileRequest.bulk_token)
  return bulk_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BulkLoadHFileRequest::release_bulk_token() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadHFileRequest.bulk_token)
  if (!has_bulk_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bulk_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BulkLoadHFileRequest::set_allocated_bulk_token(std::string* bulk_token) {
  if (bulk_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bulk_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bulk_token);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadHFileRequest.bulk_token)
}

// optional bool copy_file = 6 [default = false];
inline bool BulkLoadHFileRequest::has_copy_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BulkLoadHFileRequest::clear_copy_file() {
  copy_file_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool BulkLoadHFileRequest::copy_file() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileRequest.copy_file)
  return copy_file_;
}
inline void BulkLoadHFileRequest::set_copy_file(bool value) {
  _has_bits_[0] |= 0x00000010u;
  copy_file_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileRequest.copy_file)
}

// -------------------------------------------------------------------

// BulkLoadHFileResponse

// required bool loaded = 1;
inline bool BulkLoadHFileResponse::has_loaded() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadHFileResponse::clear_loaded() {
  loaded_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BulkLoadHFileResponse::loaded() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadHFileResponse.loaded)
  return loaded_;
}
inline void BulkLoadHFileResponse::set_loaded(bool value) {
  _has_bits_[0] |= 0x00000001u;
  loaded_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadHFileResponse.loaded)
}

// -------------------------------------------------------------------

// DelegationToken

// optional bytes identifier = 1;
inline bool DelegationToken::has_identifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DelegationToken::clear_identifier() {
  identifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DelegationToken::identifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DelegationToken.identifier)
  return identifier_.GetNoArena();
}
inline void DelegationToken::set_identifier(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DelegationToken.identifier)
}
inline void DelegationToken::set_identifier(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DelegationToken.identifier)
}
inline void DelegationToken::set_identifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DelegationToken.identifier)
}
inline void DelegationToken::set_identifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  identifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DelegationToken.identifier)
}
inline std::string* DelegationToken::mutable_identifier() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DelegationToken.identifier)
  return identifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DelegationToken::release_identifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.DelegationToken.identifier)
  if (!has_identifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return identifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DelegationToken::set_allocated_identifier(std::string* identifier) {
  if (identifier != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  identifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), identifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DelegationToken.identifier)
}

// optional bytes password = 2;
inline bool DelegationToken::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DelegationToken::clear_password() {
  password_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DelegationToken::password() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DelegationToken.password)
  return password_.GetNoArena();
}
inline void DelegationToken::set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DelegationToken.password)
}
inline void DelegationToken::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DelegationToken.password)
}
inline void DelegationToken::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DelegationToken.password)
}
inline void DelegationToken::set_password(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  password_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DelegationToken.password)
}
inline std::string* DelegationToken::mutable_password() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DelegationToken.password)
  return password_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DelegationToken::release_password() {
  // @@protoc_insertion_point(field_release:hbase.pb.DelegationToken.password)
  if (!has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return password_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DelegationToken::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  password_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DelegationToken.password)
}

// optional string kind = 3;
inline bool DelegationToken::has_kind() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DelegationToken::clear_kind() {
  kind_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DelegationToken::kind() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DelegationToken.kind)
  return kind_.GetNoArena();
}
inline void DelegationToken::set_kind(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DelegationToken.kind)
}
inline void DelegationToken::set_kind(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  kind_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DelegationToken.kind)
}
inline void DelegationToken::set_kind(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DelegationToken.kind)
}
inline void DelegationToken::set_kind(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  kind_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DelegationToken.kind)
}
inline std::string* DelegationToken::mutable_kind() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DelegationToken.kind)
  return kind_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DelegationToken::release_kind() {
  // @@protoc_insertion_point(field_release:hbase.pb.DelegationToken.kind)
  if (!has_kind()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return kind_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DelegationToken::set_allocated_kind(std::string* kind) {
  if (kind != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  kind_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), kind);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DelegationToken.kind)
}

// optional string service = 4;
inline bool DelegationToken::has_service() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DelegationToken::clear_service() {
  service_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DelegationToken::service() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DelegationToken.service)
  return service_.GetNoArena();
}
inline void DelegationToken::set_service(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  service_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DelegationToken.service)
}
inline void DelegationToken::set_service(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  service_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DelegationToken.service)
}
inline void DelegationToken::set_service(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  service_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DelegationToken.service)
}
inline void DelegationToken::set_service(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  service_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DelegationToken.service)
}
inline std::string* DelegationToken::mutable_service() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DelegationToken.service)
  return service_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DelegationToken::release_service() {
  // @@protoc_insertion_point(field_release:hbase.pb.DelegationToken.service)
  if (!has_service()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return service_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DelegationToken::set_allocated_service(std::string* service) {
  if (service != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  service_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DelegationToken.service)
}

// -------------------------------------------------------------------

// PrepareBulkLoadRequest

// required .hbase.pb.TableName table_name = 1;
inline bool PrepareBulkLoadRequest::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::TableName& PrepareBulkLoadRequest::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.PrepareBulkLoadRequest.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* PrepareBulkLoadRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.PrepareBulkLoadRequest.table_name)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* PrepareBulkLoadRequest::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.PrepareBulkLoadRequest.table_name)
  return table_name_;
}
inline void PrepareBulkLoadRequest::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.PrepareBulkLoadRequest.table_name)
}

// optional .hbase.pb.RegionSpecifier region = 2;
inline bool PrepareBulkLoadRequest::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& PrepareBulkLoadRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.PrepareBulkLoadRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* PrepareBulkLoadRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.PrepareBulkLoadRequest.region)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* PrepareBulkLoadRequest::mutable_region() {
  _has_bits_[0] |= 0x00000002u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.PrepareBulkLoadRequest.region)
  return region_;
}
inline void PrepareBulkLoadRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.PrepareBulkLoadRequest.region)
}

// -------------------------------------------------------------------

// PrepareBulkLoadResponse

// required string bulk_token = 1;
inline bool PrepareBulkLoadResponse::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrepareBulkLoadResponse::clear_bulk_token() {
  bulk_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrepareBulkLoadResponse::bulk_token() const {
  // @@protoc_insertion_point(field_get:hbase.pb.PrepareBulkLoadResponse.bulk_token)
  return bulk_token_.GetNoArena();
}
inline void PrepareBulkLoadResponse::set_bulk_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.PrepareBulkLoadResponse.bulk_token)
}
inline void PrepareBulkLoadResponse::set_bulk_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.PrepareBulkLoadResponse.bulk_token)
}
inline void PrepareBulkLoadResponse::set_bulk_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.PrepareBulkLoadResponse.bulk_token)
}
inline void PrepareBulkLoadResponse::set_bulk_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.PrepareBulkLoadResponse.bulk_token)
}
inline std::string* PrepareBulkLoadResponse::mutable_bulk_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.PrepareBulkLoadResponse.bulk_token)
  return bulk_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PrepareBulkLoadResponse::release_bulk_token() {
  // @@protoc_insertion_point(field_release:hbase.pb.PrepareBulkLoadResponse.bulk_token)
  if (!has_bulk_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bulk_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PrepareBulkLoadResponse::set_allocated_bulk_token(std::string* bulk_token) {
  if (bulk_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bulk_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bulk_token);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.PrepareBulkLoadResponse.bulk_token)
}

// -------------------------------------------------------------------

// CleanupBulkLoadRequest

// required string bulk_token = 1;
inline bool CleanupBulkLoadRequest::has_bulk_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CleanupBulkLoadRequest::clear_bulk_token() {
  bulk_token_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CleanupBulkLoadRequest::bulk_token() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CleanupBulkLoadRequest.bulk_token)
  return bulk_token_.GetNoArena();
}
inline void CleanupBulkLoadRequest::set_bulk_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CleanupBulkLoadRequest.bulk_token)
}
inline void CleanupBulkLoadRequest::set_bulk_token(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CleanupBulkLoadRequest.bulk_token)
}
inline void CleanupBulkLoadRequest::set_bulk_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CleanupBulkLoadRequest.bulk_token)
}
inline void CleanupBulkLoadRequest::set_bulk_token(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bulk_token_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CleanupBulkLoadRequest.bulk_token)
}
inline std::string* CleanupBulkLoadRequest::mutable_bulk_token() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CleanupBulkLoadRequest.bulk_token)
  return bulk_token_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CleanupBulkLoadRequest::release_bulk_token() {
  // @@protoc_insertion_point(field_release:hbase.pb.CleanupBulkLoadRequest.bulk_token)
  if (!has_bulk_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bulk_token_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CleanupBulkLoadRequest::set_allocated_bulk_token(std::string* bulk_token) {
  if (bulk_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bulk_token_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bulk_token);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CleanupBulkLoadRequest.bulk_token)
}

// optional .hbase.pb.RegionSpecifier region = 2;
inline bool CleanupBulkLoadRequest::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& CleanupBulkLoadRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.CleanupBulkLoadRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* CleanupBulkLoadRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.CleanupBulkLoadRequest.region)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* CleanupBulkLoadRequest::mutable_region() {
  _has_bits_[0] |= 0x00000002u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CleanupBulkLoadRequest.region)
  return region_;
}
inline void CleanupBulkLoadRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CleanupBulkLoadRequest.region)
}

// -------------------------------------------------------------------

// CleanupBulkLoadResponse

// -------------------------------------------------------------------

// CoprocessorServiceCall

// required bytes row = 1;
inline bool CoprocessorServiceCall::has_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoprocessorServiceCall::clear_row() {
  row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CoprocessorServiceCall::row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceCall.row)
  return row_.GetNoArena();
}
inline void CoprocessorServiceCall::set_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CoprocessorServiceCall.row)
}
inline void CoprocessorServiceCall::set_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CoprocessorServiceCall.row)
}
inline void CoprocessorServiceCall::set_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CoprocessorServiceCall.row)
}
inline void CoprocessorServiceCall::set_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CoprocessorServiceCall.row)
}
inline std::string* CoprocessorServiceCall::mutable_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceCall.row)
  return row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoprocessorServiceCall::release_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceCall.row)
  if (!has_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoprocessorServiceCall::set_allocated_row(std::string* row) {
  if (row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceCall.row)
}

// required string service_name = 2;
inline bool CoprocessorServiceCall::has_service_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoprocessorServiceCall::clear_service_name() {
  service_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CoprocessorServiceCall::service_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceCall.service_name)
  return service_name_.GetNoArena();
}
inline void CoprocessorServiceCall::set_service_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CoprocessorServiceCall.service_name)
}
inline void CoprocessorServiceCall::set_service_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  service_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CoprocessorServiceCall.service_name)
}
inline void CoprocessorServiceCall::set_service_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CoprocessorServiceCall.service_name)
}
inline void CoprocessorServiceCall::set_service_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  service_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CoprocessorServiceCall.service_name)
}
inline std::string* CoprocessorServiceCall::mutable_service_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceCall.service_name)
  return service_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoprocessorServiceCall::release_service_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceCall.service_name)
  if (!has_service_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return service_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoprocessorServiceCall::set_allocated_service_name(std::string* service_name) {
  if (service_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  service_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), service_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceCall.service_name)
}

// required string method_name = 3;
inline bool CoprocessorServiceCall::has_method_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoprocessorServiceCall::clear_method_name() {
  method_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CoprocessorServiceCall::method_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceCall.method_name)
  return method_name_.GetNoArena();
}
inline void CoprocessorServiceCall::set_method_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  method_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CoprocessorServiceCall.method_name)
}
inline void CoprocessorServiceCall::set_method_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  method_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CoprocessorServiceCall.method_name)
}
inline void CoprocessorServiceCall::set_method_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  method_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CoprocessorServiceCall.method_name)
}
inline void CoprocessorServiceCall::set_method_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  method_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CoprocessorServiceCall.method_name)
}
inline std::string* CoprocessorServiceCall::mutable_method_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceCall.method_name)
  return method_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoprocessorServiceCall::release_method_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceCall.method_name)
  if (!has_method_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return method_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoprocessorServiceCall::set_allocated_method_name(std::string* method_name) {
  if (method_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  method_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), method_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceCall.method_name)
}

// required bytes request = 4;
inline bool CoprocessorServiceCall::has_request() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoprocessorServiceCall::clear_request() {
  request_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CoprocessorServiceCall::request() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceCall.request)
  return request_.GetNoArena();
}
inline void CoprocessorServiceCall::set_request(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CoprocessorServiceCall.request)
}
inline void CoprocessorServiceCall::set_request(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  request_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CoprocessorServiceCall.request)
}
inline void CoprocessorServiceCall::set_request(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CoprocessorServiceCall.request)
}
inline void CoprocessorServiceCall::set_request(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  request_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CoprocessorServiceCall.request)
}
inline std::string* CoprocessorServiceCall::mutable_request() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceCall.request)
  return request_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CoprocessorServiceCall::release_request() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceCall.request)
  if (!has_request()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return request_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CoprocessorServiceCall::set_allocated_request(std::string* request) {
  if (request != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  request_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceCall.request)
}

// -------------------------------------------------------------------

// CoprocessorServiceResult

// optional .hbase.pb.NameBytesPair value = 1;
inline bool CoprocessorServiceResult::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::NameBytesPair& CoprocessorServiceResult::value() const {
  const ::hbase::pb::NameBytesPair* p = value_;
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceResult.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::NameBytesPair*>(
      &::hbase::pb::_NameBytesPair_default_instance_);
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResult::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceResult.value)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::NameBytesPair* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResult::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::NameBytesPair>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceResult.value)
  return value_;
}
inline void CoprocessorServiceResult::set_allocated_value(::hbase::pb::NameBytesPair* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceResult.value)
}

// -------------------------------------------------------------------

// CoprocessorServiceRequest

// required .hbase.pb.RegionSpecifier region = 1;
inline bool CoprocessorServiceRequest::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& CoprocessorServiceRequest::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceRequest.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceRequest::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceRequest.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceRequest::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceRequest.region)
  return region_;
}
inline void CoprocessorServiceRequest::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceRequest.region)
}

// required .hbase.pb.CoprocessorServiceCall call = 2;
inline bool CoprocessorServiceRequest::has_call() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoprocessorServiceRequest::clear_call() {
  if (call_ != nullptr) call_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::CoprocessorServiceCall& CoprocessorServiceRequest::call() const {
  const ::hbase::pb::CoprocessorServiceCall* p = call_;
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceRequest.call)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CoprocessorServiceCall*>(
      &::hbase::pb::_CoprocessorServiceCall_default_instance_);
}
inline ::hbase::pb::CoprocessorServiceCall* CoprocessorServiceRequest::release_call() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceRequest.call)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::CoprocessorServiceCall* temp = call_;
  call_ = nullptr;
  return temp;
}
inline ::hbase::pb::CoprocessorServiceCall* CoprocessorServiceRequest::mutable_call() {
  _has_bits_[0] |= 0x00000002u;
  if (call_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CoprocessorServiceCall>(GetArenaNoVirtual());
    call_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceRequest.call)
  return call_;
}
inline void CoprocessorServiceRequest::set_allocated_call(::hbase::pb::CoprocessorServiceCall* call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete call_;
  }
  if (call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  call_ = call;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceRequest.call)
}

// -------------------------------------------------------------------

// CoprocessorServiceResponse

// required .hbase.pb.RegionSpecifier region = 1;
inline bool CoprocessorServiceResponse::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& CoprocessorServiceResponse::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceResponse.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceResponse::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceResponse.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* CoprocessorServiceResponse::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceResponse.region)
  return region_;
}
inline void CoprocessorServiceResponse::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceResponse.region)
}

// required .hbase.pb.NameBytesPair value = 2;
inline bool CoprocessorServiceResponse::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::NameBytesPair& CoprocessorServiceResponse::value() const {
  const ::hbase::pb::NameBytesPair* p = value_;
  // @@protoc_insertion_point(field_get:hbase.pb.CoprocessorServiceResponse.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::NameBytesPair*>(
      &::hbase::pb::_NameBytesPair_default_instance_);
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResponse::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.CoprocessorServiceResponse.value)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::NameBytesPair* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::hbase::pb::NameBytesPair* CoprocessorServiceResponse::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::NameBytesPair>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CoprocessorServiceResponse.value)
  return value_;
}
inline void CoprocessorServiceResponse::set_allocated_value(::hbase::pb::NameBytesPair* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CoprocessorServiceResponse.value)
}

// -------------------------------------------------------------------

// Action

// optional uint32 index = 1;
inline bool Action::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Action::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Action::index() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Action.index)
  return index_;
}
inline void Action::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  index_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Action.index)
}

// optional .hbase.pb.MutationProto mutation = 2;
inline bool Action::has_mutation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Action::clear_mutation() {
  if (mutation_ != nullptr) mutation_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::MutationProto& Action::mutation() const {
  const ::hbase::pb::MutationProto* p = mutation_;
  // @@protoc_insertion_point(field_get:hbase.pb.Action.mutation)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::MutationProto*>(
      &::hbase::pb::_MutationProto_default_instance_);
}
inline ::hbase::pb::MutationProto* Action::release_mutation() {
  // @@protoc_insertion_point(field_release:hbase.pb.Action.mutation)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::MutationProto* temp = mutation_;
  mutation_ = nullptr;
  return temp;
}
inline ::hbase::pb::MutationProto* Action::mutable_mutation() {
  _has_bits_[0] |= 0x00000001u;
  if (mutation_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::MutationProto>(GetArenaNoVirtual());
    mutation_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Action.mutation)
  return mutation_;
}
inline void Action::set_allocated_mutation(::hbase::pb::MutationProto* mutation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete mutation_;
  }
  if (mutation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      mutation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mutation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  mutation_ = mutation;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Action.mutation)
}

// optional .hbase.pb.Get get = 3;
inline bool Action::has_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Action::clear_get() {
  if (get_ != nullptr) get_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::Get& Action::get() const {
  const ::hbase::pb::Get* p = get_;
  // @@protoc_insertion_point(field_get:hbase.pb.Action.get)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Get*>(
      &::hbase::pb::_Get_default_instance_);
}
inline ::hbase::pb::Get* Action::release_get() {
  // @@protoc_insertion_point(field_release:hbase.pb.Action.get)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::Get* temp = get_;
  get_ = nullptr;
  return temp;
}
inline ::hbase::pb::Get* Action::mutable_get() {
  _has_bits_[0] |= 0x00000002u;
  if (get_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Get>(GetArenaNoVirtual());
    get_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Action.get)
  return get_;
}
inline void Action::set_allocated_get(::hbase::pb::Get* get) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete get_;
  }
  if (get) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      get = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  get_ = get;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Action.get)
}

// optional .hbase.pb.CoprocessorServiceCall service_call = 4;
inline bool Action::has_service_call() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Action::clear_service_call() {
  if (service_call_ != nullptr) service_call_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::CoprocessorServiceCall& Action::service_call() const {
  const ::hbase::pb::CoprocessorServiceCall* p = service_call_;
  // @@protoc_insertion_point(field_get:hbase.pb.Action.service_call)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CoprocessorServiceCall*>(
      &::hbase::pb::_CoprocessorServiceCall_default_instance_);
}
inline ::hbase::pb::CoprocessorServiceCall* Action::release_service_call() {
  // @@protoc_insertion_point(field_release:hbase.pb.Action.service_call)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::CoprocessorServiceCall* temp = service_call_;
  service_call_ = nullptr;
  return temp;
}
inline ::hbase::pb::CoprocessorServiceCall* Action::mutable_service_call() {
  _has_bits_[0] |= 0x00000004u;
  if (service_call_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CoprocessorServiceCall>(GetArenaNoVirtual());
    service_call_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Action.service_call)
  return service_call_;
}
inline void Action::set_allocated_service_call(::hbase::pb::CoprocessorServiceCall* service_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete service_call_;
  }
  if (service_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      service_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_call, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  service_call_ = service_call;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Action.service_call)
}

// -------------------------------------------------------------------

// RegionAction

// required .hbase.pb.RegionSpecifier region = 1;
inline bool RegionAction::has_region() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& RegionAction::region() const {
  const ::hbase::pb::RegionSpecifier* p = region_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionAction.region)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* RegionAction::release_region() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionAction.region)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* RegionAction::mutable_region() {
  _has_bits_[0] |= 0x00000001u;
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionAction.region)
  return region_;
}
inline void RegionAction::set_allocated_region(::hbase::pb::RegionSpecifier* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionAction.region)
}

// optional bool atomic = 2;
inline bool RegionAction::has_atomic() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionAction::clear_atomic() {
  atomic_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool RegionAction::atomic() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionAction.atomic)
  return atomic_;
}
inline void RegionAction::set_atomic(bool value) {
  _has_bits_[0] |= 0x00000002u;
  atomic_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionAction.atomic)
}

// repeated .hbase.pb.Action action = 3;
inline int RegionAction::action_size() const {
  return action_.size();
}
inline void RegionAction::clear_action() {
  action_.Clear();
}
inline ::hbase::pb::Action* RegionAction::mutable_action(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionAction.action)
  return action_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Action >*
RegionAction::mutable_action() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.RegionAction.action)
  return &action_;
}
inline const ::hbase::pb::Action& RegionAction::action(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionAction.action)
  return action_.Get(index);
}
inline ::hbase::pb::Action* RegionAction::add_action() {
  // @@protoc_insertion_point(field_add:hbase.pb.RegionAction.action)
  return action_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Action >&
RegionAction::action() const {
  // @@protoc_insertion_point(field_list:hbase.pb.RegionAction.action)
  return action_;
}

// -------------------------------------------------------------------

// RegionLoadStats

// optional int32 memStoreLoad = 1 [default = 0];
inline bool RegionLoadStats::has_memstoreload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionLoadStats::clear_memstoreload() {
  memstoreload_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionLoadStats::memstoreload() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoadStats.memStoreLoad)
  return memstoreload_;
}
inline void RegionLoadStats::set_memstoreload(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  memstoreload_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoadStats.memStoreLoad)
}

// optional int32 heapOccupancy = 2 [default = 0];
inline bool RegionLoadStats::has_heapoccupancy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionLoadStats::clear_heapoccupancy() {
  heapoccupancy_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionLoadStats::heapoccupancy() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoadStats.heapOccupancy)
  return heapoccupancy_;
}
inline void RegionLoadStats::set_heapoccupancy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  heapoccupancy_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoadStats.heapOccupancy)
}

// optional int32 compactionPressure = 3 [default = 0];
inline bool RegionLoadStats::has_compactionpressure() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionLoadStats::clear_compactionpressure() {
  compactionpressure_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionLoadStats::compactionpressure() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoadStats.compactionPressure)
  return compactionpressure_;
}
inline void RegionLoadStats::set_compactionpressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  compactionpressure_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoadStats.compactionPressure)
}

// -------------------------------------------------------------------

// MultiRegionLoadStats

// repeated .hbase.pb.RegionSpecifier region = 1;
inline int MultiRegionLoadStats::region_size() const {
  return region_.size();
}
inline ::hbase::pb::RegionSpecifier* MultiRegionLoadStats::mutable_region(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiRegionLoadStats.region)
  return region_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionSpecifier >*
MultiRegionLoadStats::mutable_region() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultiRegionLoadStats.region)
  return &region_;
}
inline const ::hbase::pb::RegionSpecifier& MultiRegionLoadStats::region(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRegionLoadStats.region)
  return region_.Get(index);
}
inline ::hbase::pb::RegionSpecifier* MultiRegionLoadStats::add_region() {
  // @@protoc_insertion_point(field_add:hbase.pb.MultiRegionLoadStats.region)
  return region_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionSpecifier >&
MultiRegionLoadStats::region() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultiRegionLoadStats.region)
  return region_;
}

// repeated .hbase.pb.RegionLoadStats stat = 2;
inline int MultiRegionLoadStats::stat_size() const {
  return stat_.size();
}
inline void MultiRegionLoadStats::clear_stat() {
  stat_.Clear();
}
inline ::hbase::pb::RegionLoadStats* MultiRegionLoadStats::mutable_stat(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiRegionLoadStats.stat)
  return stat_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoadStats >*
MultiRegionLoadStats::mutable_stat() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultiRegionLoadStats.stat)
  return &stat_;
}
inline const ::hbase::pb::RegionLoadStats& MultiRegionLoadStats::stat(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRegionLoadStats.stat)
  return stat_.Get(index);
}
inline ::hbase::pb::RegionLoadStats* MultiRegionLoadStats::add_stat() {
  // @@protoc_insertion_point(field_add:hbase.pb.MultiRegionLoadStats.stat)
  return stat_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoadStats >&
MultiRegionLoadStats::stat() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultiRegionLoadStats.stat)
  return stat_;
}

// -------------------------------------------------------------------

// ResultOrException

// optional uint32 index = 1;
inline bool ResultOrException::has_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultOrException::clear_index() {
  index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ResultOrException::index() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ResultOrException.index)
  return index_;
}
inline void ResultOrException::set_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  index_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ResultOrException.index)
}

// optional .hbase.pb.Result result = 2;
inline bool ResultOrException::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultOrException::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Result& ResultOrException::result() const {
  const ::hbase::pb::Result* p = result_;
  // @@protoc_insertion_point(field_get:hbase.pb.ResultOrException.result)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Result*>(
      &::hbase::pb::_Result_default_instance_);
}
inline ::hbase::pb::Result* ResultOrException::release_result() {
  // @@protoc_insertion_point(field_release:hbase.pb.ResultOrException.result)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Result* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::hbase::pb::Result* ResultOrException::mutable_result() {
  _has_bits_[0] |= 0x00000001u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Result>(GetArenaNoVirtual());
    result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ResultOrException.result)
  return result_;
}
inline void ResultOrException::set_allocated_result(::hbase::pb::Result* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ResultOrException.result)
}

// optional .hbase.pb.NameBytesPair exception = 3;
inline bool ResultOrException::has_exception() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::NameBytesPair& ResultOrException::exception() const {
  const ::hbase::pb::NameBytesPair* p = exception_;
  // @@protoc_insertion_point(field_get:hbase.pb.ResultOrException.exception)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::NameBytesPair*>(
      &::hbase::pb::_NameBytesPair_default_instance_);
}
inline ::hbase::pb::NameBytesPair* ResultOrException::release_exception() {
  // @@protoc_insertion_point(field_release:hbase.pb.ResultOrException.exception)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::NameBytesPair* temp = exception_;
  exception_ = nullptr;
  return temp;
}
inline ::hbase::pb::NameBytesPair* ResultOrException::mutable_exception() {
  _has_bits_[0] |= 0x00000002u;
  if (exception_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::NameBytesPair>(GetArenaNoVirtual());
    exception_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ResultOrException.exception)
  return exception_;
}
inline void ResultOrException::set_allocated_exception(::hbase::pb::NameBytesPair* exception) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(exception_);
  }
  if (exception) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      exception = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exception, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  exception_ = exception;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ResultOrException.exception)
}

// optional .hbase.pb.CoprocessorServiceResult service_result = 4;
inline bool ResultOrException::has_service_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultOrException::clear_service_result() {
  if (service_result_ != nullptr) service_result_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::CoprocessorServiceResult& ResultOrException::service_result() const {
  const ::hbase::pb::CoprocessorServiceResult* p = service_result_;
  // @@protoc_insertion_point(field_get:hbase.pb.ResultOrException.service_result)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CoprocessorServiceResult*>(
      &::hbase::pb::_CoprocessorServiceResult_default_instance_);
}
inline ::hbase::pb::CoprocessorServiceResult* ResultOrException::release_service_result() {
  // @@protoc_insertion_point(field_release:hbase.pb.ResultOrException.service_result)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::CoprocessorServiceResult* temp = service_result_;
  service_result_ = nullptr;
  return temp;
}
inline ::hbase::pb::CoprocessorServiceResult* ResultOrException::mutable_service_result() {
  _has_bits_[0] |= 0x00000004u;
  if (service_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CoprocessorServiceResult>(GetArenaNoVirtual());
    service_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ResultOrException.service_result)
  return service_result_;
}
inline void ResultOrException::set_allocated_service_result(::hbase::pb::CoprocessorServiceResult* service_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete service_result_;
  }
  if (service_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      service_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  service_result_ = service_result;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ResultOrException.service_result)
}

// optional .hbase.pb.RegionLoadStats loadStats = 5 [deprecated = true];
inline bool ResultOrException::has_loadstats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultOrException::clear_loadstats() {
  if (loadstats_ != nullptr) loadstats_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hbase::pb::RegionLoadStats& ResultOrException::loadstats() const {
  const ::hbase::pb::RegionLoadStats* p = loadstats_;
  // @@protoc_insertion_point(field_get:hbase.pb.ResultOrException.loadStats)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionLoadStats*>(
      &::hbase::pb::_RegionLoadStats_default_instance_);
}
inline ::hbase::pb::RegionLoadStats* ResultOrException::release_loadstats() {
  // @@protoc_insertion_point(field_release:hbase.pb.ResultOrException.loadStats)
  _has_bits_[0] &= ~0x00000008u;
  ::hbase::pb::RegionLoadStats* temp = loadstats_;
  loadstats_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionLoadStats* ResultOrException::mutable_loadstats() {
  _has_bits_[0] |= 0x00000008u;
  if (loadstats_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionLoadStats>(GetArenaNoVirtual());
    loadstats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ResultOrException.loadStats)
  return loadstats_;
}
inline void ResultOrException::set_allocated_loadstats(::hbase::pb::RegionLoadStats* loadstats) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete loadstats_;
  }
  if (loadstats) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      loadstats = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loadstats, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  loadstats_ = loadstats;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ResultOrException.loadStats)
}

// -------------------------------------------------------------------

// RegionActionResult

// repeated .hbase.pb.ResultOrException resultOrException = 1;
inline int RegionActionResult::resultorexception_size() const {
  return resultorexception_.size();
}
inline void RegionActionResult::clear_resultorexception() {
  resultorexception_.Clear();
}
inline ::hbase::pb::ResultOrException* RegionActionResult::mutable_resultorexception(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionActionResult.resultOrException)
  return resultorexception_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ResultOrException >*
RegionActionResult::mutable_resultorexception() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.RegionActionResult.resultOrException)
  return &resultorexception_;
}
inline const ::hbase::pb::ResultOrException& RegionActionResult::resultorexception(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionActionResult.resultOrException)
  return resultorexception_.Get(index);
}
inline ::hbase::pb::ResultOrException* RegionActionResult::add_resultorexception() {
  // @@protoc_insertion_point(field_add:hbase.pb.RegionActionResult.resultOrException)
  return resultorexception_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ResultOrException >&
RegionActionResult::resultorexception() const {
  // @@protoc_insertion_point(field_list:hbase.pb.RegionActionResult.resultOrException)
  return resultorexception_;
}

// optional .hbase.pb.NameBytesPair exception = 2;
inline bool RegionActionResult::has_exception() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::NameBytesPair& RegionActionResult::exception() const {
  const ::hbase::pb::NameBytesPair* p = exception_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionActionResult.exception)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::NameBytesPair*>(
      &::hbase::pb::_NameBytesPair_default_instance_);
}
inline ::hbase::pb::NameBytesPair* RegionActionResult::release_exception() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionActionResult.exception)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::NameBytesPair* temp = exception_;
  exception_ = nullptr;
  return temp;
}
inline ::hbase::pb::NameBytesPair* RegionActionResult::mutable_exception() {
  _has_bits_[0] |= 0x00000001u;
  if (exception_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::NameBytesPair>(GetArenaNoVirtual());
    exception_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionActionResult.exception)
  return exception_;
}
inline void RegionActionResult::set_allocated_exception(::hbase::pb::NameBytesPair* exception) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(exception_);
  }
  if (exception) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      exception = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exception, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  exception_ = exception;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionActionResult.exception)
}

// -------------------------------------------------------------------

// MultiRequest

// repeated .hbase.pb.RegionAction regionAction = 1;
inline int MultiRequest::regionaction_size() const {
  return regionaction_.size();
}
inline void MultiRequest::clear_regionaction() {
  regionaction_.Clear();
}
inline ::hbase::pb::RegionAction* MultiRequest::mutable_regionaction(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiRequest.regionAction)
  return regionaction_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionAction >*
MultiRequest::mutable_regionaction() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultiRequest.regionAction)
  return &regionaction_;
}
inline const ::hbase::pb::RegionAction& MultiRequest::regionaction(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRequest.regionAction)
  return regionaction_.Get(index);
}
inline ::hbase::pb::RegionAction* MultiRequest::add_regionaction() {
  // @@protoc_insertion_point(field_add:hbase.pb.MultiRequest.regionAction)
  return regionaction_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionAction >&
MultiRequest::regionaction() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultiRequest.regionAction)
  return regionaction_;
}

// optional uint64 nonceGroup = 2;
inline bool MultiRequest::has_noncegroup() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiRequest::clear_noncegroup() {
  noncegroup_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 MultiRequest::noncegroup() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRequest.nonceGroup)
  return noncegroup_;
}
inline void MultiRequest::set_noncegroup(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  noncegroup_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MultiRequest.nonceGroup)
}

// optional .hbase.pb.Condition condition = 3;
inline bool MultiRequest::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiRequest::clear_condition() {
  if (condition_ != nullptr) condition_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Condition& MultiRequest::condition() const {
  const ::hbase::pb::Condition* p = condition_;
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRequest.condition)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Condition*>(
      &::hbase::pb::_Condition_default_instance_);
}
inline ::hbase::pb::Condition* MultiRequest::release_condition() {
  // @@protoc_insertion_point(field_release:hbase.pb.MultiRequest.condition)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Condition* temp = condition_;
  condition_ = nullptr;
  return temp;
}
inline ::hbase::pb::Condition* MultiRequest::mutable_condition() {
  _has_bits_[0] |= 0x00000001u;
  if (condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Condition>(GetArenaNoVirtual());
    condition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiRequest.condition)
  return condition_;
}
inline void MultiRequest::set_allocated_condition(::hbase::pb::Condition* condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete condition_;
  }
  if (condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, condition, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  condition_ = condition;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MultiRequest.condition)
}

// -------------------------------------------------------------------

// MultiResponse

// repeated .hbase.pb.RegionActionResult regionActionResult = 1;
inline int MultiResponse::regionactionresult_size() const {
  return regionactionresult_.size();
}
inline void MultiResponse::clear_regionactionresult() {
  regionactionresult_.Clear();
}
inline ::hbase::pb::RegionActionResult* MultiResponse::mutable_regionactionresult(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiResponse.regionActionResult)
  return regionactionresult_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionActionResult >*
MultiResponse::mutable_regionactionresult() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultiResponse.regionActionResult)
  return &regionactionresult_;
}
inline const ::hbase::pb::RegionActionResult& MultiResponse::regionactionresult(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiResponse.regionActionResult)
  return regionactionresult_.Get(index);
}
inline ::hbase::pb::RegionActionResult* MultiResponse::add_regionactionresult() {
  // @@protoc_insertion_point(field_add:hbase.pb.MultiResponse.regionActionResult)
  return regionactionresult_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionActionResult >&
MultiResponse::regionactionresult() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultiResponse.regionActionResult)
  return regionactionresult_;
}

// optional bool processed = 2;
inline bool MultiResponse::has_processed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiResponse::clear_processed() {
  processed_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool MultiResponse::processed() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiResponse.processed)
  return processed_;
}
inline void MultiResponse::set_processed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  processed_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MultiResponse.processed)
}

// optional .hbase.pb.MultiRegionLoadStats regionStatistics = 3;
inline bool MultiResponse::has_regionstatistics() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiResponse::clear_regionstatistics() {
  if (regionstatistics_ != nullptr) regionstatistics_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::MultiRegionLoadStats& MultiResponse::regionstatistics() const {
  const ::hbase::pb::MultiRegionLoadStats* p = regionstatistics_;
  // @@protoc_insertion_point(field_get:hbase.pb.MultiResponse.regionStatistics)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::MultiRegionLoadStats*>(
      &::hbase::pb::_MultiRegionLoadStats_default_instance_);
}
inline ::hbase::pb::MultiRegionLoadStats* MultiResponse::release_regionstatistics() {
  // @@protoc_insertion_point(field_release:hbase.pb.MultiResponse.regionStatistics)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::MultiRegionLoadStats* temp = regionstatistics_;
  regionstatistics_ = nullptr;
  return temp;
}
inline ::hbase::pb::MultiRegionLoadStats* MultiResponse::mutable_regionstatistics() {
  _has_bits_[0] |= 0x00000001u;
  if (regionstatistics_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::MultiRegionLoadStats>(GetArenaNoVirtual());
    regionstatistics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiResponse.regionStatistics)
  return regionstatistics_;
}
inline void MultiResponse::set_allocated_regionstatistics(::hbase::pb::MultiRegionLoadStats* regionstatistics) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete regionstatistics_;
  }
  if (regionstatistics) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      regionstatistics = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, regionstatistics, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  regionstatistics_ = regionstatistics;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MultiResponse.regionStatistics)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::MutationProto_Durability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_Durability>() {
  return ::hbase::pb::MutationProto_Durability_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::MutationProto_MutationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_MutationType>() {
  return ::hbase::pb::MutationProto_MutationType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::MutationProto_DeleteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::MutationProto_DeleteType>() {
  return ::hbase::pb::MutationProto_DeleteType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::Scan_ReadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Scan_ReadType>() {
  return ::hbase::pb::Scan_ReadType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::Consistency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Consistency>() {
  return ::hbase::pb::Consistency_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Client_2eproto
