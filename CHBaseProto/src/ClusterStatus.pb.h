// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClusterStatus.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ClusterStatus_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ClusterStatus_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "ClusterId.pb.h"
#include "FS.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ClusterStatus_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ClusterStatus_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ClusterStatus_2eproto;
namespace hbase {
namespace pb {
class ClusterStatus;
class ClusterStatusDefaultTypeInternal;
extern ClusterStatusDefaultTypeInternal _ClusterStatus_default_instance_;
class LiveServerInfo;
class LiveServerInfoDefaultTypeInternal;
extern LiveServerInfoDefaultTypeInternal _LiveServerInfo_default_instance_;
class RegionInTransition;
class RegionInTransitionDefaultTypeInternal;
extern RegionInTransitionDefaultTypeInternal _RegionInTransition_default_instance_;
class RegionLoad;
class RegionLoadDefaultTypeInternal;
extern RegionLoadDefaultTypeInternal _RegionLoad_default_instance_;
class RegionState;
class RegionStateDefaultTypeInternal;
extern RegionStateDefaultTypeInternal _RegionState_default_instance_;
class RegionStoreSequenceIds;
class RegionStoreSequenceIdsDefaultTypeInternal;
extern RegionStoreSequenceIdsDefaultTypeInternal _RegionStoreSequenceIds_default_instance_;
class ReplicationLoadSink;
class ReplicationLoadSinkDefaultTypeInternal;
extern ReplicationLoadSinkDefaultTypeInternal _ReplicationLoadSink_default_instance_;
class ReplicationLoadSource;
class ReplicationLoadSourceDefaultTypeInternal;
extern ReplicationLoadSourceDefaultTypeInternal _ReplicationLoadSource_default_instance_;
class ServerLoad;
class ServerLoadDefaultTypeInternal;
extern ServerLoadDefaultTypeInternal _ServerLoad_default_instance_;
class StoreSequenceId;
class StoreSequenceIdDefaultTypeInternal;
extern StoreSequenceIdDefaultTypeInternal _StoreSequenceId_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::ClusterStatus* Arena::CreateMaybeMessage<::hbase::pb::ClusterStatus>(Arena*);
template<> ::hbase::pb::LiveServerInfo* Arena::CreateMaybeMessage<::hbase::pb::LiveServerInfo>(Arena*);
template<> ::hbase::pb::RegionInTransition* Arena::CreateMaybeMessage<::hbase::pb::RegionInTransition>(Arena*);
template<> ::hbase::pb::RegionLoad* Arena::CreateMaybeMessage<::hbase::pb::RegionLoad>(Arena*);
template<> ::hbase::pb::RegionState* Arena::CreateMaybeMessage<::hbase::pb::RegionState>(Arena*);
template<> ::hbase::pb::RegionStoreSequenceIds* Arena::CreateMaybeMessage<::hbase::pb::RegionStoreSequenceIds>(Arena*);
template<> ::hbase::pb::ReplicationLoadSink* Arena::CreateMaybeMessage<::hbase::pb::ReplicationLoadSink>(Arena*);
template<> ::hbase::pb::ReplicationLoadSource* Arena::CreateMaybeMessage<::hbase::pb::ReplicationLoadSource>(Arena*);
template<> ::hbase::pb::ServerLoad* Arena::CreateMaybeMessage<::hbase::pb::ServerLoad>(Arena*);
template<> ::hbase::pb::StoreSequenceId* Arena::CreateMaybeMessage<::hbase::pb::StoreSequenceId>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum RegionState_State : int {
  RegionState_State_OFFLINE = 0,
  RegionState_State_PENDING_OPEN = 1,
  RegionState_State_OPENING = 2,
  RegionState_State_OPEN = 3,
  RegionState_State_PENDING_CLOSE = 4,
  RegionState_State_CLOSING = 5,
  RegionState_State_CLOSED = 6,
  RegionState_State_SPLITTING = 7,
  RegionState_State_SPLIT = 8,
  RegionState_State_FAILED_OPEN = 9,
  RegionState_State_FAILED_CLOSE = 10,
  RegionState_State_MERGING = 11,
  RegionState_State_MERGED = 12,
  RegionState_State_SPLITTING_NEW = 13,
  RegionState_State_MERGING_NEW = 14
};
bool RegionState_State_IsValid(int value);
constexpr RegionState_State RegionState_State_State_MIN = RegionState_State_OFFLINE;
constexpr RegionState_State RegionState_State_State_MAX = RegionState_State_MERGING_NEW;
constexpr int RegionState_State_State_ARRAYSIZE = RegionState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionState_State_descriptor();
template<typename T>
inline const std::string& RegionState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionState_State_descriptor(), enum_t_value);
}
inline bool RegionState_State_Parse(
    const std::string& name, RegionState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionState_State>(
    RegionState_State_descriptor(), name, value);
}
enum Option : int {
  HBASE_VERSION = 0,
  CLUSTER_ID = 1,
  LIVE_SERVERS = 2,
  DEAD_SERVERS = 3,
  MASTER = 4,
  BACKUP_MASTERS = 5,
  MASTER_COPROCESSORS = 6,
  REGIONS_IN_TRANSITION = 7,
  BALANCER_ON = 8
};
bool Option_IsValid(int value);
constexpr Option Option_MIN = HBASE_VERSION;
constexpr Option Option_MAX = BALANCER_ON;
constexpr int Option_ARRAYSIZE = Option_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Option_descriptor();
template<typename T>
inline const std::string& Option_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Option>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Option_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Option_descriptor(), enum_t_value);
}
inline bool Option_Parse(
    const std::string& name, Option* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Option>(
    Option_descriptor(), name, value);
}
// ===================================================================

class RegionState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionState) */ {
 public:
  RegionState();
  virtual ~RegionState();

  RegionState(const RegionState& from);
  RegionState(RegionState&& from) noexcept
    : RegionState() {
    *this = ::std::move(from);
  }

  inline RegionState& operator=(const RegionState& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionState& operator=(RegionState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionState* internal_default_instance() {
    return reinterpret_cast<const RegionState*>(
               &_RegionState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RegionState& a, RegionState& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionState* New() const final {
    return CreateMaybeMessage<RegionState>(nullptr);
  }

  RegionState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionState& from);
  void MergeFrom(const RegionState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RegionState_State State;
  static constexpr State OFFLINE =
    RegionState_State_OFFLINE;
  static constexpr State PENDING_OPEN =
    RegionState_State_PENDING_OPEN;
  static constexpr State OPENING =
    RegionState_State_OPENING;
  static constexpr State OPEN =
    RegionState_State_OPEN;
  static constexpr State PENDING_CLOSE =
    RegionState_State_PENDING_CLOSE;
  static constexpr State CLOSING =
    RegionState_State_CLOSING;
  static constexpr State CLOSED =
    RegionState_State_CLOSED;
  static constexpr State SPLITTING =
    RegionState_State_SPLITTING;
  static constexpr State SPLIT =
    RegionState_State_SPLIT;
  static constexpr State FAILED_OPEN =
    RegionState_State_FAILED_OPEN;
  static constexpr State FAILED_CLOSE =
    RegionState_State_FAILED_CLOSE;
  static constexpr State MERGING =
    RegionState_State_MERGING;
  static constexpr State MERGED =
    RegionState_State_MERGED;
  static constexpr State SPLITTING_NEW =
    RegionState_State_SPLITTING_NEW;
  static constexpr State MERGING_NEW =
    RegionState_State_MERGING_NEW;
  static inline bool State_IsValid(int value) {
    return RegionState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    RegionState_State_State_MIN;
  static constexpr State State_MAX =
    RegionState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    RegionState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return RegionState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return RegionState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return RegionState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kRegionInfoFieldNumber = 1,
    kStampFieldNumber = 3,
    kStateFieldNumber = 2,
  };
  // required .hbase.pb.RegionInfo region_info = 1;
  bool has_region_info() const;
  void clear_region_info();
  const ::hbase::pb::RegionInfo& region_info() const;
  ::hbase::pb::RegionInfo* release_region_info();
  ::hbase::pb::RegionInfo* mutable_region_info();
  void set_allocated_region_info(::hbase::pb::RegionInfo* region_info);

  // optional uint64 stamp = 3;
  bool has_stamp() const;
  void clear_stamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 stamp() const;
  void set_stamp(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required .hbase.pb.RegionState.State state = 2;
  bool has_state() const;
  void clear_state();
  ::hbase::pb::RegionState_State state() const;
  void set_state(::hbase::pb::RegionState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionState)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionInfo* region_info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stamp_;
  int state_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class RegionInTransition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionInTransition) */ {
 public:
  RegionInTransition();
  virtual ~RegionInTransition();

  RegionInTransition(const RegionInTransition& from);
  RegionInTransition(RegionInTransition&& from) noexcept
    : RegionInTransition() {
    *this = ::std::move(from);
  }

  inline RegionInTransition& operator=(const RegionInTransition& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInTransition& operator=(RegionInTransition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionInTransition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionInTransition* internal_default_instance() {
    return reinterpret_cast<const RegionInTransition*>(
               &_RegionInTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RegionInTransition& a, RegionInTransition& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInTransition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionInTransition* New() const final {
    return CreateMaybeMessage<RegionInTransition>(nullptr);
  }

  RegionInTransition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionInTransition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionInTransition& from);
  void MergeFrom(const RegionInTransition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInTransition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionInTransition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSpecFieldNumber = 1,
    kRegionStateFieldNumber = 2,
  };
  // required .hbase.pb.RegionSpecifier spec = 1;
  bool has_spec() const;
  void clear_spec();
  const ::hbase::pb::RegionSpecifier& spec() const;
  ::hbase::pb::RegionSpecifier* release_spec();
  ::hbase::pb::RegionSpecifier* mutable_spec();
  void set_allocated_spec(::hbase::pb::RegionSpecifier* spec);

  // required .hbase.pb.RegionState region_state = 2;
  bool has_region_state() const;
  void clear_region_state();
  const ::hbase::pb::RegionState& region_state() const;
  ::hbase::pb::RegionState* release_region_state();
  ::hbase::pb::RegionState* mutable_region_state();
  void set_allocated_region_state(::hbase::pb::RegionState* region_state);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionInTransition)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::RegionSpecifier* spec_;
  ::hbase::pb::RegionState* region_state_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class StoreSequenceId :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.StoreSequenceId) */ {
 public:
  StoreSequenceId();
  virtual ~StoreSequenceId();

  StoreSequenceId(const StoreSequenceId& from);
  StoreSequenceId(StoreSequenceId&& from) noexcept
    : StoreSequenceId() {
    *this = ::std::move(from);
  }

  inline StoreSequenceId& operator=(const StoreSequenceId& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreSequenceId& operator=(StoreSequenceId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreSequenceId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreSequenceId* internal_default_instance() {
    return reinterpret_cast<const StoreSequenceId*>(
               &_StoreSequenceId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StoreSequenceId& a, StoreSequenceId& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreSequenceId* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreSequenceId* New() const final {
    return CreateMaybeMessage<StoreSequenceId>(nullptr);
  }

  StoreSequenceId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreSequenceId>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreSequenceId& from);
  void MergeFrom(const StoreSequenceId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreSequenceId* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.StoreSequenceId";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyNameFieldNumber = 1,
    kSequenceIdFieldNumber = 2,
  };
  // required bytes family_name = 1;
  bool has_family_name() const;
  void clear_family_name();
  const std::string& family_name() const;
  void set_family_name(const std::string& value);
  void set_family_name(std::string&& value);
  void set_family_name(const char* value);
  void set_family_name(const void* value, size_t size);
  std::string* mutable_family_name();
  std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);

  // required uint64 sequence_id = 2;
  bool has_sequence_id() const;
  void clear_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id() const;
  void set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.StoreSequenceId)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_id_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class RegionStoreSequenceIds :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionStoreSequenceIds) */ {
 public:
  RegionStoreSequenceIds();
  virtual ~RegionStoreSequenceIds();

  RegionStoreSequenceIds(const RegionStoreSequenceIds& from);
  RegionStoreSequenceIds(RegionStoreSequenceIds&& from) noexcept
    : RegionStoreSequenceIds() {
    *this = ::std::move(from);
  }

  inline RegionStoreSequenceIds& operator=(const RegionStoreSequenceIds& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionStoreSequenceIds& operator=(RegionStoreSequenceIds&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionStoreSequenceIds& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionStoreSequenceIds* internal_default_instance() {
    return reinterpret_cast<const RegionStoreSequenceIds*>(
               &_RegionStoreSequenceIds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RegionStoreSequenceIds& a, RegionStoreSequenceIds& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionStoreSequenceIds* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionStoreSequenceIds* New() const final {
    return CreateMaybeMessage<RegionStoreSequenceIds>(nullptr);
  }

  RegionStoreSequenceIds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionStoreSequenceIds>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionStoreSequenceIds& from);
  void MergeFrom(const RegionStoreSequenceIds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionStoreSequenceIds* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionStoreSequenceIds";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreSequenceIdFieldNumber = 2,
    kLastFlushedSequenceIdFieldNumber = 1,
  };
  // repeated .hbase.pb.StoreSequenceId store_sequence_id = 2;
  int store_sequence_id_size() const;
  void clear_store_sequence_id();
  ::hbase::pb::StoreSequenceId* mutable_store_sequence_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >*
      mutable_store_sequence_id();
  const ::hbase::pb::StoreSequenceId& store_sequence_id(int index) const;
  ::hbase::pb::StoreSequenceId* add_store_sequence_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >&
      store_sequence_id() const;

  // required uint64 last_flushed_sequence_id = 1;
  bool has_last_flushed_sequence_id() const;
  void clear_last_flushed_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flushed_sequence_id() const;
  void set_last_flushed_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionStoreSequenceIds)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId > store_sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_flushed_sequence_id_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class RegionLoad :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionLoad) */ {
 public:
  RegionLoad();
  virtual ~RegionLoad();

  RegionLoad(const RegionLoad& from);
  RegionLoad(RegionLoad&& from) noexcept
    : RegionLoad() {
    *this = ::std::move(from);
  }

  inline RegionLoad& operator=(const RegionLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionLoad& operator=(RegionLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionLoad* internal_default_instance() {
    return reinterpret_cast<const RegionLoad*>(
               &_RegionLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionLoad& a, RegionLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionLoad* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionLoad* New() const final {
    return CreateMaybeMessage<RegionLoad>(nullptr);
  }

  RegionLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionLoad>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionLoad& from);
  void MergeFrom(const RegionLoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionLoad";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreCompleteSequenceIdFieldNumber = 18,
    kRegionSpecifierFieldNumber = 1,
    kStoresFieldNumber = 2,
    kStorefilesFieldNumber = 3,
    kStoreUncompressedSizeMBFieldNumber = 4,
    kStorefileSizeMBFieldNumber = 5,
    kStorefileIndexSizeKBFieldNumber = 7,
    kReadRequestsCountFieldNumber = 8,
    kWriteRequestsCountFieldNumber = 9,
    kMemstoreSizeMBFieldNumber = 6,
    kRootIndexSizeKBFieldNumber = 12,
    kTotalCompactingKVsFieldNumber = 10,
    kCurrentCompactedKVsFieldNumber = 11,
    kTotalStaticIndexSizeKBFieldNumber = 13,
    kTotalStaticBloomSizeKBFieldNumber = 14,
    kCompleteSequenceIdFieldNumber = 15,
    kLastMajorCompactionTsFieldNumber = 17,
    kFilteredReadRequestsCountFieldNumber = 19,
    kCpRequestsCountFieldNumber = 20,
    kDataLocalityFieldNumber = 16,
  };
  // repeated .hbase.pb.StoreSequenceId store_complete_sequence_id = 18;
  int store_complete_sequence_id_size() const;
  void clear_store_complete_sequence_id();
  ::hbase::pb::StoreSequenceId* mutable_store_complete_sequence_id(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >*
      mutable_store_complete_sequence_id();
  const ::hbase::pb::StoreSequenceId& store_complete_sequence_id(int index) const;
  ::hbase::pb::StoreSequenceId* add_store_complete_sequence_id();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >&
      store_complete_sequence_id() const;

  // required .hbase.pb.RegionSpecifier region_specifier = 1;
  bool has_region_specifier() const;
  void clear_region_specifier();
  const ::hbase::pb::RegionSpecifier& region_specifier() const;
  ::hbase::pb::RegionSpecifier* release_region_specifier();
  ::hbase::pb::RegionSpecifier* mutable_region_specifier();
  void set_allocated_region_specifier(::hbase::pb::RegionSpecifier* region_specifier);

  // optional uint32 stores = 2;
  bool has_stores() const;
  void clear_stores();
  ::PROTOBUF_NAMESPACE_ID::uint32 stores() const;
  void set_stores(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 storefiles = 3;
  bool has_storefiles() const;
  void clear_storefiles();
  ::PROTOBUF_NAMESPACE_ID::uint32 storefiles() const;
  void set_storefiles(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 store_uncompressed_size_MB = 4;
  bool has_store_uncompressed_size_mb() const;
  void clear_store_uncompressed_size_mb();
  ::PROTOBUF_NAMESPACE_ID::uint32 store_uncompressed_size_mb() const;
  void set_store_uncompressed_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 storefile_size_MB = 5;
  bool has_storefile_size_mb() const;
  void clear_storefile_size_mb();
  ::PROTOBUF_NAMESPACE_ID::uint32 storefile_size_mb() const;
  void set_storefile_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 storefile_index_size_KB = 7;
  bool has_storefile_index_size_kb() const;
  void clear_storefile_index_size_kb();
  ::PROTOBUF_NAMESPACE_ID::uint64 storefile_index_size_kb() const;
  void set_storefile_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 read_requests_count = 8;
  bool has_read_requests_count() const;
  void clear_read_requests_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 read_requests_count() const;
  void set_read_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 write_requests_count = 9;
  bool has_write_requests_count() const;
  void clear_write_requests_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 write_requests_count() const;
  void set_write_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 memstore_size_MB = 6;
  bool has_memstore_size_mb() const;
  void clear_memstore_size_mb();
  ::PROTOBUF_NAMESPACE_ID::uint32 memstore_size_mb() const;
  void set_memstore_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 root_index_size_KB = 12;
  bool has_root_index_size_kb() const;
  void clear_root_index_size_kb();
  ::PROTOBUF_NAMESPACE_ID::uint32 root_index_size_kb() const;
  void set_root_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 total_compacting_KVs = 10;
  bool has_total_compacting_kvs() const;
  void clear_total_compacting_kvs();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_compacting_kvs() const;
  void set_total_compacting_kvs(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 current_compacted_KVs = 11;
  bool has_current_compacted_kvs() const;
  void clear_current_compacted_kvs();
  ::PROTOBUF_NAMESPACE_ID::uint64 current_compacted_kvs() const;
  void set_current_compacted_kvs(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 total_static_index_size_KB = 13;
  bool has_total_static_index_size_kb() const;
  void clear_total_static_index_size_kb();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_static_index_size_kb() const;
  void set_total_static_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 total_static_bloom_size_KB = 14;
  bool has_total_static_bloom_size_kb() const;
  void clear_total_static_bloom_size_kb();
  ::PROTOBUF_NAMESPACE_ID::uint32 total_static_bloom_size_kb() const;
  void set_total_static_bloom_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 complete_sequence_id = 15;
  bool has_complete_sequence_id() const;
  void clear_complete_sequence_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 complete_sequence_id() const;
  void set_complete_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 last_major_compaction_ts = 17 [default = 0];
  bool has_last_major_compaction_ts() const;
  void clear_last_major_compaction_ts();
  ::PROTOBUF_NAMESPACE_ID::uint64 last_major_compaction_ts() const;
  void set_last_major_compaction_ts(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 filtered_read_requests_count = 19;
  bool has_filtered_read_requests_count() const;
  void clear_filtered_read_requests_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 filtered_read_requests_count() const;
  void set_filtered_read_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 cp_requests_count = 20;
  bool has_cp_requests_count() const;
  void clear_cp_requests_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 cp_requests_count() const;
  void set_cp_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional float data_locality = 16;
  bool has_data_locality() const;
  void clear_data_locality();
  float data_locality() const;
  void set_data_locality(float value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionLoad)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId > store_complete_sequence_id_;
  ::hbase::pb::RegionSpecifier* region_specifier_;
  ::PROTOBUF_NAMESPACE_ID::uint32 stores_;
  ::PROTOBUF_NAMESPACE_ID::uint32 storefiles_;
  ::PROTOBUF_NAMESPACE_ID::uint32 store_uncompressed_size_mb_;
  ::PROTOBUF_NAMESPACE_ID::uint32 storefile_size_mb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 storefile_index_size_kb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 read_requests_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 write_requests_count_;
  ::PROTOBUF_NAMESPACE_ID::uint32 memstore_size_mb_;
  ::PROTOBUF_NAMESPACE_ID::uint32 root_index_size_kb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_compacting_kvs_;
  ::PROTOBUF_NAMESPACE_ID::uint64 current_compacted_kvs_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_static_index_size_kb_;
  ::PROTOBUF_NAMESPACE_ID::uint32 total_static_bloom_size_kb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 complete_sequence_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 last_major_compaction_ts_;
  ::PROTOBUF_NAMESPACE_ID::uint64 filtered_read_requests_count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 cp_requests_count_;
  float data_locality_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class ReplicationLoadSink :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ReplicationLoadSink) */ {
 public:
  ReplicationLoadSink();
  virtual ~ReplicationLoadSink();

  ReplicationLoadSink(const ReplicationLoadSink& from);
  ReplicationLoadSink(ReplicationLoadSink&& from) noexcept
    : ReplicationLoadSink() {
    *this = ::std::move(from);
  }

  inline ReplicationLoadSink& operator=(const ReplicationLoadSink& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationLoadSink& operator=(ReplicationLoadSink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplicationLoadSink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplicationLoadSink* internal_default_instance() {
    return reinterpret_cast<const ReplicationLoadSink*>(
               &_ReplicationLoadSink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ReplicationLoadSink& a, ReplicationLoadSink& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationLoadSink* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationLoadSink* New() const final {
    return CreateMaybeMessage<ReplicationLoadSink>(nullptr);
  }

  ReplicationLoadSink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationLoadSink>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplicationLoadSink& from);
  void MergeFrom(const ReplicationLoadSink& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationLoadSink* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ReplicationLoadSink";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgeOfLastAppliedOpFieldNumber = 1,
    kTimeStampsOfLastAppliedOpFieldNumber = 2,
  };
  // required uint64 ageOfLastAppliedOp = 1;
  bool has_ageoflastappliedop() const;
  void clear_ageoflastappliedop();
  ::PROTOBUF_NAMESPACE_ID::uint64 ageoflastappliedop() const;
  void set_ageoflastappliedop(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 timeStampsOfLastAppliedOp = 2;
  bool has_timestampsoflastappliedop() const;
  void clear_timestampsoflastappliedop();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampsoflastappliedop() const;
  void set_timestampsoflastappliedop(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationLoadSink)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ageoflastappliedop_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampsoflastappliedop_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class ReplicationLoadSource :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ReplicationLoadSource) */ {
 public:
  ReplicationLoadSource();
  virtual ~ReplicationLoadSource();

  ReplicationLoadSource(const ReplicationLoadSource& from);
  ReplicationLoadSource(ReplicationLoadSource&& from) noexcept
    : ReplicationLoadSource() {
    *this = ::std::move(from);
  }

  inline ReplicationLoadSource& operator=(const ReplicationLoadSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationLoadSource& operator=(ReplicationLoadSource&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplicationLoadSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplicationLoadSource* internal_default_instance() {
    return reinterpret_cast<const ReplicationLoadSource*>(
               &_ReplicationLoadSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReplicationLoadSource& a, ReplicationLoadSource& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationLoadSource* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationLoadSource* New() const final {
    return CreateMaybeMessage<ReplicationLoadSource>(nullptr);
  }

  ReplicationLoadSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationLoadSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplicationLoadSource& from);
  void MergeFrom(const ReplicationLoadSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationLoadSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ReplicationLoadSource";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerIDFieldNumber = 1,
    kAgeOfLastShippedOpFieldNumber = 2,
    kTimeStampOfLastShippedOpFieldNumber = 4,
    kReplicationLagFieldNumber = 5,
    kSizeOfLogQueueFieldNumber = 3,
  };
  // required string peerID = 1;
  bool has_peerid() const;
  void clear_peerid();
  const std::string& peerid() const;
  void set_peerid(const std::string& value);
  void set_peerid(std::string&& value);
  void set_peerid(const char* value);
  void set_peerid(const char* value, size_t size);
  std::string* mutable_peerid();
  std::string* release_peerid();
  void set_allocated_peerid(std::string* peerid);

  // required uint64 ageOfLastShippedOp = 2;
  bool has_ageoflastshippedop() const;
  void clear_ageoflastshippedop();
  ::PROTOBUF_NAMESPACE_ID::uint64 ageoflastshippedop() const;
  void set_ageoflastshippedop(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 timeStampOfLastShippedOp = 4;
  bool has_timestampoflastshippedop() const;
  void clear_timestampoflastshippedop();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampoflastshippedop() const;
  void set_timestampoflastshippedop(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 replicationLag = 5;
  bool has_replicationlag() const;
  void clear_replicationlag();
  ::PROTOBUF_NAMESPACE_ID::uint64 replicationlag() const;
  void set_replicationlag(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint32 sizeOfLogQueue = 3;
  bool has_sizeoflogqueue() const;
  void clear_sizeoflogqueue();
  ::PROTOBUF_NAMESPACE_ID::uint32 sizeoflogqueue() const;
  void set_sizeoflogqueue(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationLoadSource)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peerid_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ageoflastshippedop_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestampoflastshippedop_;
  ::PROTOBUF_NAMESPACE_ID::uint64 replicationlag_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sizeoflogqueue_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class ServerLoad :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ServerLoad) */ {
 public:
  ServerLoad();
  virtual ~ServerLoad();

  ServerLoad(const ServerLoad& from);
  ServerLoad(ServerLoad&& from) noexcept
    : ServerLoad() {
    *this = ::std::move(from);
  }

  inline ServerLoad& operator=(const ServerLoad& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerLoad& operator=(ServerLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerLoad* internal_default_instance() {
    return reinterpret_cast<const ServerLoad*>(
               &_ServerLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ServerLoad& a, ServerLoad& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerLoad* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerLoad* New() const final {
    return CreateMaybeMessage<ServerLoad>(nullptr);
  }

  ServerLoad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerLoad>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerLoad& from);
  void MergeFrom(const ServerLoad& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerLoad* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ServerLoad";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionLoadsFieldNumber = 5,
    kCoprocessorsFieldNumber = 6,
    kReplLoadSourceFieldNumber = 10,
    kReplLoadSinkFieldNumber = 11,
    kNumberOfRequestsFieldNumber = 1,
    kTotalNumberOfRequestsFieldNumber = 2,
    kUsedHeapMBFieldNumber = 3,
    kMaxHeapMBFieldNumber = 4,
    kReportStartTimeFieldNumber = 7,
    kReportEndTimeFieldNumber = 8,
    kInfoServerPortFieldNumber = 9,
  };
  // repeated .hbase.pb.RegionLoad region_loads = 5;
  int region_loads_size() const;
  void clear_region_loads();
  ::hbase::pb::RegionLoad* mutable_region_loads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoad >*
      mutable_region_loads();
  const ::hbase::pb::RegionLoad& region_loads(int index) const;
  ::hbase::pb::RegionLoad* add_region_loads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoad >&
      region_loads() const;

  // repeated .hbase.pb.Coprocessor coprocessors = 6;
  int coprocessors_size() const;
  void clear_coprocessors();
  ::hbase::pb::Coprocessor* mutable_coprocessors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >*
      mutable_coprocessors();
  const ::hbase::pb::Coprocessor& coprocessors(int index) const;
  ::hbase::pb::Coprocessor* add_coprocessors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >&
      coprocessors() const;

  // repeated .hbase.pb.ReplicationLoadSource replLoadSource = 10;
  int replloadsource_size() const;
  void clear_replloadsource();
  ::hbase::pb::ReplicationLoadSource* mutable_replloadsource(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ReplicationLoadSource >*
      mutable_replloadsource();
  const ::hbase::pb::ReplicationLoadSource& replloadsource(int index) const;
  ::hbase::pb::ReplicationLoadSource* add_replloadsource();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ReplicationLoadSource >&
      replloadsource() const;

  // optional .hbase.pb.ReplicationLoadSink replLoadSink = 11;
  bool has_replloadsink() const;
  void clear_replloadsink();
  const ::hbase::pb::ReplicationLoadSink& replloadsink() const;
  ::hbase::pb::ReplicationLoadSink* release_replloadsink();
  ::hbase::pb::ReplicationLoadSink* mutable_replloadsink();
  void set_allocated_replloadsink(::hbase::pb::ReplicationLoadSink* replloadsink);

  // optional uint64 number_of_requests = 1;
  bool has_number_of_requests() const;
  void clear_number_of_requests();
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_requests() const;
  void set_number_of_requests(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 total_number_of_requests = 2;
  bool has_total_number_of_requests() const;
  void clear_total_number_of_requests();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_number_of_requests() const;
  void set_total_number_of_requests(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 used_heap_MB = 3;
  bool has_used_heap_mb() const;
  void clear_used_heap_mb();
  ::PROTOBUF_NAMESPACE_ID::uint32 used_heap_mb() const;
  void set_used_heap_mb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 max_heap_MB = 4;
  bool has_max_heap_mb() const;
  void clear_max_heap_mb();
  ::PROTOBUF_NAMESPACE_ID::uint32 max_heap_mb() const;
  void set_max_heap_mb(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 report_start_time = 7;
  bool has_report_start_time() const;
  void clear_report_start_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 report_start_time() const;
  void set_report_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 report_end_time = 8;
  bool has_report_end_time() const;
  void clear_report_end_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 report_end_time() const;
  void set_report_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 info_server_port = 9;
  bool has_info_server_port() const;
  void clear_info_server_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 info_server_port() const;
  void set_info_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ServerLoad)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoad > region_loads_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor > coprocessors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ReplicationLoadSource > replloadsource_;
  ::hbase::pb::ReplicationLoadSink* replloadsink_;
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_requests_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_number_of_requests_;
  ::PROTOBUF_NAMESPACE_ID::uint32 used_heap_mb_;
  ::PROTOBUF_NAMESPACE_ID::uint32 max_heap_mb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 report_start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 report_end_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 info_server_port_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class LiveServerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.LiveServerInfo) */ {
 public:
  LiveServerInfo();
  virtual ~LiveServerInfo();

  LiveServerInfo(const LiveServerInfo& from);
  LiveServerInfo(LiveServerInfo&& from) noexcept
    : LiveServerInfo() {
    *this = ::std::move(from);
  }

  inline LiveServerInfo& operator=(const LiveServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiveServerInfo& operator=(LiveServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LiveServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LiveServerInfo* internal_default_instance() {
    return reinterpret_cast<const LiveServerInfo*>(
               &_LiveServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(LiveServerInfo& a, LiveServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(LiveServerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LiveServerInfo* New() const final {
    return CreateMaybeMessage<LiveServerInfo>(nullptr);
  }

  LiveServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LiveServerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LiveServerInfo& from);
  void MergeFrom(const LiveServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiveServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.LiveServerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
    kServerLoadFieldNumber = 2,
  };
  // required .hbase.pb.ServerName server = 1;
  bool has_server() const;
  void clear_server();
  const ::hbase::pb::ServerName& server() const;
  ::hbase::pb::ServerName* release_server();
  ::hbase::pb::ServerName* mutable_server();
  void set_allocated_server(::hbase::pb::ServerName* server);

  // required .hbase.pb.ServerLoad server_load = 2;
  bool has_server_load() const;
  void clear_server_load();
  const ::hbase::pb::ServerLoad& server_load() const;
  ::hbase::pb::ServerLoad* release_server_load();
  ::hbase::pb::ServerLoad* mutable_server_load();
  void set_allocated_server_load(::hbase::pb::ServerLoad* server_load);

  // @@protoc_insertion_point(class_scope:hbase.pb.LiveServerInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::ServerName* server_;
  ::hbase::pb::ServerLoad* server_load_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// -------------------------------------------------------------------

class ClusterStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ClusterStatus) */ {
 public:
  ClusterStatus();
  virtual ~ClusterStatus();

  ClusterStatus(const ClusterStatus& from);
  ClusterStatus(ClusterStatus&& from) noexcept
    : ClusterStatus() {
    *this = ::std::move(from);
  }

  inline ClusterStatus& operator=(const ClusterStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusterStatus& operator=(ClusterStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClusterStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterStatus* internal_default_instance() {
    return reinterpret_cast<const ClusterStatus*>(
               &_ClusterStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ClusterStatus& a, ClusterStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusterStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClusterStatus* New() const final {
    return CreateMaybeMessage<ClusterStatus>(nullptr);
  }

  ClusterStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClusterStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClusterStatus& from);
  void MergeFrom(const ClusterStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ClusterStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ClusterStatus_2eproto);
    return ::descriptor_table_ClusterStatus_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiveServersFieldNumber = 2,
    kDeadServersFieldNumber = 3,
    kRegionsInTransitionFieldNumber = 4,
    kMasterCoprocessorsFieldNumber = 6,
    kBackupMastersFieldNumber = 8,
    kHbaseVersionFieldNumber = 1,
    kClusterIdFieldNumber = 5,
    kMasterFieldNumber = 7,
    kBalancerOnFieldNumber = 9,
  };
  // repeated .hbase.pb.LiveServerInfo live_servers = 2;
  int live_servers_size() const;
  void clear_live_servers();
  ::hbase::pb::LiveServerInfo* mutable_live_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::LiveServerInfo >*
      mutable_live_servers();
  const ::hbase::pb::LiveServerInfo& live_servers(int index) const;
  ::hbase::pb::LiveServerInfo* add_live_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::LiveServerInfo >&
      live_servers() const;

  // repeated .hbase.pb.ServerName dead_servers = 3;
  int dead_servers_size() const;
  void clear_dead_servers();
  ::hbase::pb::ServerName* mutable_dead_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
      mutable_dead_servers();
  const ::hbase::pb::ServerName& dead_servers(int index) const;
  ::hbase::pb::ServerName* add_dead_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
      dead_servers() const;

  // repeated .hbase.pb.RegionInTransition regions_in_transition = 4;
  int regions_in_transition_size() const;
  void clear_regions_in_transition();
  ::hbase::pb::RegionInTransition* mutable_regions_in_transition(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionInTransition >*
      mutable_regions_in_transition();
  const ::hbase::pb::RegionInTransition& regions_in_transition(int index) const;
  ::hbase::pb::RegionInTransition* add_regions_in_transition();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionInTransition >&
      regions_in_transition() const;

  // repeated .hbase.pb.Coprocessor master_coprocessors = 6;
  int master_coprocessors_size() const;
  void clear_master_coprocessors();
  ::hbase::pb::Coprocessor* mutable_master_coprocessors(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >*
      mutable_master_coprocessors();
  const ::hbase::pb::Coprocessor& master_coprocessors(int index) const;
  ::hbase::pb::Coprocessor* add_master_coprocessors();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >&
      master_coprocessors() const;

  // repeated .hbase.pb.ServerName backup_masters = 8;
  int backup_masters_size() const;
  void clear_backup_masters();
  ::hbase::pb::ServerName* mutable_backup_masters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
      mutable_backup_masters();
  const ::hbase::pb::ServerName& backup_masters(int index) const;
  ::hbase::pb::ServerName* add_backup_masters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
      backup_masters() const;

  // optional .hbase.pb.HBaseVersionFileContent hbase_version = 1;
  bool has_hbase_version() const;
  void clear_hbase_version();
  const ::hbase::pb::HBaseVersionFileContent& hbase_version() const;
  ::hbase::pb::HBaseVersionFileContent* release_hbase_version();
  ::hbase::pb::HBaseVersionFileContent* mutable_hbase_version();
  void set_allocated_hbase_version(::hbase::pb::HBaseVersionFileContent* hbase_version);

  // optional .hbase.pb.ClusterId cluster_id = 5;
  bool has_cluster_id() const;
  void clear_cluster_id();
  const ::hbase::pb::ClusterId& cluster_id() const;
  ::hbase::pb::ClusterId* release_cluster_id();
  ::hbase::pb::ClusterId* mutable_cluster_id();
  void set_allocated_cluster_id(::hbase::pb::ClusterId* cluster_id);

  // optional .hbase.pb.ServerName master = 7;
  bool has_master() const;
  void clear_master();
  const ::hbase::pb::ServerName& master() const;
  ::hbase::pb::ServerName* release_master();
  ::hbase::pb::ServerName* mutable_master();
  void set_allocated_master(::hbase::pb::ServerName* master);

  // optional bool balancer_on = 9;
  bool has_balancer_on() const;
  void clear_balancer_on();
  bool balancer_on() const;
  void set_balancer_on(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ClusterStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::LiveServerInfo > live_servers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName > dead_servers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionInTransition > regions_in_transition_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor > master_coprocessors_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName > backup_masters_;
  ::hbase::pb::HBaseVersionFileContent* hbase_version_;
  ::hbase::pb::ClusterId* cluster_id_;
  ::hbase::pb::ServerName* master_;
  bool balancer_on_;
  friend struct ::TableStruct_ClusterStatus_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RegionState

// required .hbase.pb.RegionInfo region_info = 1;
inline bool RegionState::has_region_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionInfo& RegionState::region_info() const {
  const ::hbase::pb::RegionInfo* p = region_info_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionState.region_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionInfo*>(
      &::hbase::pb::_RegionInfo_default_instance_);
}
inline ::hbase::pb::RegionInfo* RegionState::release_region_info() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionState.region_info)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionInfo* temp = region_info_;
  region_info_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionInfo* RegionState::mutable_region_info() {
  _has_bits_[0] |= 0x00000001u;
  if (region_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionInfo>(GetArenaNoVirtual());
    region_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionState.region_info)
  return region_info_;
}
inline void RegionState::set_allocated_region_info(::hbase::pb::RegionInfo* region_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_info_);
  }
  if (region_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_info_ = region_info;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionState.region_info)
}

// required .hbase.pb.RegionState.State state = 2;
inline bool RegionState::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hbase::pb::RegionState_State RegionState::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionState.state)
  return static_cast< ::hbase::pb::RegionState_State >(state_);
}
inline void RegionState::set_state(::hbase::pb::RegionState_State value) {
  assert(::hbase::pb::RegionState_State_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionState.state)
}

// optional uint64 stamp = 3;
inline bool RegionState::has_stamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionState::clear_stamp() {
  stamp_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionState::stamp() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionState.stamp)
  return stamp_;
}
inline void RegionState::set_stamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  stamp_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionState.stamp)
}

// -------------------------------------------------------------------

// RegionInTransition

// required .hbase.pb.RegionSpecifier spec = 1;
inline bool RegionInTransition::has_spec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& RegionInTransition::spec() const {
  const ::hbase::pb::RegionSpecifier* p = spec_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInTransition.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* RegionInTransition::release_spec() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionInTransition.spec)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* RegionInTransition::mutable_spec() {
  _has_bits_[0] |= 0x00000001u;
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionInTransition.spec)
  return spec_;
}
inline void RegionInTransition::set_allocated_spec(::hbase::pb::RegionSpecifier* spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(spec_);
  }
  if (spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionInTransition.spec)
}

// required .hbase.pb.RegionState region_state = 2;
inline bool RegionInTransition::has_region_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionInTransition::clear_region_state() {
  if (region_state_ != nullptr) region_state_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::RegionState& RegionInTransition::region_state() const {
  const ::hbase::pb::RegionState* p = region_state_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInTransition.region_state)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionState*>(
      &::hbase::pb::_RegionState_default_instance_);
}
inline ::hbase::pb::RegionState* RegionInTransition::release_region_state() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionInTransition.region_state)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::RegionState* temp = region_state_;
  region_state_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionState* RegionInTransition::mutable_region_state() {
  _has_bits_[0] |= 0x00000002u;
  if (region_state_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionState>(GetArenaNoVirtual());
    region_state_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionInTransition.region_state)
  return region_state_;
}
inline void RegionInTransition::set_allocated_region_state(::hbase::pb::RegionState* region_state) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete region_state_;
  }
  if (region_state) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region_state = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_state, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_state_ = region_state;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionInTransition.region_state)
}

// -------------------------------------------------------------------

// StoreSequenceId

// required bytes family_name = 1;
inline bool StoreSequenceId::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreSequenceId::clear_family_name() {
  family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreSequenceId::family_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreSequenceId.family_name)
  return family_name_.GetNoArena();
}
inline void StoreSequenceId::set_family_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.StoreSequenceId.family_name)
}
inline void StoreSequenceId::set_family_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.StoreSequenceId.family_name)
}
inline void StoreSequenceId::set_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.StoreSequenceId.family_name)
}
inline void StoreSequenceId::set_family_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.StoreSequenceId.family_name)
}
inline std::string* StoreSequenceId::mutable_family_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.StoreSequenceId.family_name)
  return family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StoreSequenceId::release_family_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.StoreSequenceId.family_name)
  if (!has_family_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StoreSequenceId::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.StoreSequenceId.family_name)
}

// required uint64 sequence_id = 2;
inline bool StoreSequenceId::has_sequence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreSequenceId::clear_sequence_id() {
  sequence_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreSequenceId::sequence_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreSequenceId.sequence_id)
  return sequence_id_;
}
inline void StoreSequenceId::set_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  sequence_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.StoreSequenceId.sequence_id)
}

// -------------------------------------------------------------------

// RegionStoreSequenceIds

// required uint64 last_flushed_sequence_id = 1;
inline bool RegionStoreSequenceIds::has_last_flushed_sequence_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionStoreSequenceIds::clear_last_flushed_sequence_id() {
  last_flushed_sequence_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionStoreSequenceIds::last_flushed_sequence_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionStoreSequenceIds.last_flushed_sequence_id)
  return last_flushed_sequence_id_;
}
inline void RegionStoreSequenceIds::set_last_flushed_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  last_flushed_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionStoreSequenceIds.last_flushed_sequence_id)
}

// repeated .hbase.pb.StoreSequenceId store_sequence_id = 2;
inline int RegionStoreSequenceIds::store_sequence_id_size() const {
  return store_sequence_id_.size();
}
inline void RegionStoreSequenceIds::clear_store_sequence_id() {
  store_sequence_id_.Clear();
}
inline ::hbase::pb::StoreSequenceId* RegionStoreSequenceIds::mutable_store_sequence_id(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionStoreSequenceIds.store_sequence_id)
  return store_sequence_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >*
RegionStoreSequenceIds::mutable_store_sequence_id() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.RegionStoreSequenceIds.store_sequence_id)
  return &store_sequence_id_;
}
inline const ::hbase::pb::StoreSequenceId& RegionStoreSequenceIds::store_sequence_id(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionStoreSequenceIds.store_sequence_id)
  return store_sequence_id_.Get(index);
}
inline ::hbase::pb::StoreSequenceId* RegionStoreSequenceIds::add_store_sequence_id() {
  // @@protoc_insertion_point(field_add:hbase.pb.RegionStoreSequenceIds.store_sequence_id)
  return store_sequence_id_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >&
RegionStoreSequenceIds::store_sequence_id() const {
  // @@protoc_insertion_point(field_list:hbase.pb.RegionStoreSequenceIds.store_sequence_id)
  return store_sequence_id_;
}

// -------------------------------------------------------------------

// RegionLoad

// required .hbase.pb.RegionSpecifier region_specifier = 1;
inline bool RegionLoad::has_region_specifier() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::RegionSpecifier& RegionLoad::region_specifier() const {
  const ::hbase::pb::RegionSpecifier* p = region_specifier_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.region_specifier)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::RegionSpecifier*>(
      &::hbase::pb::_RegionSpecifier_default_instance_);
}
inline ::hbase::pb::RegionSpecifier* RegionLoad::release_region_specifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionLoad.region_specifier)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::RegionSpecifier* temp = region_specifier_;
  region_specifier_ = nullptr;
  return temp;
}
inline ::hbase::pb::RegionSpecifier* RegionLoad::mutable_region_specifier() {
  _has_bits_[0] |= 0x00000001u;
  if (region_specifier_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::RegionSpecifier>(GetArenaNoVirtual());
    region_specifier_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionLoad.region_specifier)
  return region_specifier_;
}
inline void RegionLoad::set_allocated_region_specifier(::hbase::pb::RegionSpecifier* region_specifier) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_specifier_);
  }
  if (region_specifier) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      region_specifier = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region_specifier, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  region_specifier_ = region_specifier;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionLoad.region_specifier)
}

// optional uint32 stores = 2;
inline bool RegionLoad::has_stores() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionLoad::clear_stores() {
  stores_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::stores() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.stores)
  return stores_;
}
inline void RegionLoad::set_stores(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  stores_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.stores)
}

// optional uint32 storefiles = 3;
inline bool RegionLoad::has_storefiles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionLoad::clear_storefiles() {
  storefiles_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::storefiles() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.storefiles)
  return storefiles_;
}
inline void RegionLoad::set_storefiles(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  storefiles_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.storefiles)
}

// optional uint32 store_uncompressed_size_MB = 4;
inline bool RegionLoad::has_store_uncompressed_size_mb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionLoad::clear_store_uncompressed_size_mb() {
  store_uncompressed_size_mb_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::store_uncompressed_size_mb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.store_uncompressed_size_MB)
  return store_uncompressed_size_mb_;
}
inline void RegionLoad::set_store_uncompressed_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  store_uncompressed_size_mb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.store_uncompressed_size_MB)
}

// optional uint32 storefile_size_MB = 5;
inline bool RegionLoad::has_storefile_size_mb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionLoad::clear_storefile_size_mb() {
  storefile_size_mb_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::storefile_size_mb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.storefile_size_MB)
  return storefile_size_mb_;
}
inline void RegionLoad::set_storefile_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  storefile_size_mb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.storefile_size_MB)
}

// optional uint32 memstore_size_MB = 6;
inline bool RegionLoad::has_memstore_size_mb() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RegionLoad::clear_memstore_size_mb() {
  memstore_size_mb_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::memstore_size_mb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.memstore_size_MB)
  return memstore_size_mb_;
}
inline void RegionLoad::set_memstore_size_mb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  memstore_size_mb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.memstore_size_MB)
}

// optional uint64 storefile_index_size_KB = 7;
inline bool RegionLoad::has_storefile_index_size_kb() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionLoad::clear_storefile_index_size_kb() {
  storefile_index_size_kb_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::storefile_index_size_kb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.storefile_index_size_KB)
  return storefile_index_size_kb_;
}
inline void RegionLoad::set_storefile_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  storefile_index_size_kb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.storefile_index_size_KB)
}

// optional uint64 read_requests_count = 8;
inline bool RegionLoad::has_read_requests_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionLoad::clear_read_requests_count() {
  read_requests_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::read_requests_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.read_requests_count)
  return read_requests_count_;
}
inline void RegionLoad::set_read_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  read_requests_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.read_requests_count)
}

// optional uint64 write_requests_count = 9;
inline bool RegionLoad::has_write_requests_count() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RegionLoad::clear_write_requests_count() {
  write_requests_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::write_requests_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.write_requests_count)
  return write_requests_count_;
}
inline void RegionLoad::set_write_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  write_requests_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.write_requests_count)
}

// optional uint64 total_compacting_KVs = 10;
inline bool RegionLoad::has_total_compacting_kvs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RegionLoad::clear_total_compacting_kvs() {
  total_compacting_kvs_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000400u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::total_compacting_kvs() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.total_compacting_KVs)
  return total_compacting_kvs_;
}
inline void RegionLoad::set_total_compacting_kvs(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000400u;
  total_compacting_kvs_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.total_compacting_KVs)
}

// optional uint64 current_compacted_KVs = 11;
inline bool RegionLoad::has_current_compacted_kvs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RegionLoad::clear_current_compacted_kvs() {
  current_compacted_kvs_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000800u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::current_compacted_kvs() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.current_compacted_KVs)
  return current_compacted_kvs_;
}
inline void RegionLoad::set_current_compacted_kvs(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000800u;
  current_compacted_kvs_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.current_compacted_KVs)
}

// optional uint32 root_index_size_KB = 12;
inline bool RegionLoad::has_root_index_size_kb() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RegionLoad::clear_root_index_size_kb() {
  root_index_size_kb_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::root_index_size_kb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.root_index_size_KB)
  return root_index_size_kb_;
}
inline void RegionLoad::set_root_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000200u;
  root_index_size_kb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.root_index_size_KB)
}

// optional uint32 total_static_index_size_KB = 13;
inline bool RegionLoad::has_total_static_index_size_kb() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RegionLoad::clear_total_static_index_size_kb() {
  total_static_index_size_kb_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::total_static_index_size_kb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.total_static_index_size_KB)
  return total_static_index_size_kb_;
}
inline void RegionLoad::set_total_static_index_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00001000u;
  total_static_index_size_kb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.total_static_index_size_KB)
}

// optional uint32 total_static_bloom_size_KB = 14;
inline bool RegionLoad::has_total_static_bloom_size_kb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RegionLoad::clear_total_static_bloom_size_kb() {
  total_static_bloom_size_kb_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 RegionLoad::total_static_bloom_size_kb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.total_static_bloom_size_KB)
  return total_static_bloom_size_kb_;
}
inline void RegionLoad::set_total_static_bloom_size_kb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00002000u;
  total_static_bloom_size_kb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.total_static_bloom_size_KB)
}

// optional uint64 complete_sequence_id = 15;
inline bool RegionLoad::has_complete_sequence_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RegionLoad::clear_complete_sequence_id() {
  complete_sequence_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00004000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::complete_sequence_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.complete_sequence_id)
  return complete_sequence_id_;
}
inline void RegionLoad::set_complete_sequence_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00004000u;
  complete_sequence_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.complete_sequence_id)
}

// optional float data_locality = 16;
inline bool RegionLoad::has_data_locality() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RegionLoad::clear_data_locality() {
  data_locality_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline float RegionLoad::data_locality() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.data_locality)
  return data_locality_;
}
inline void RegionLoad::set_data_locality(float value) {
  _has_bits_[0] |= 0x00040000u;
  data_locality_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.data_locality)
}

// optional uint64 last_major_compaction_ts = 17 [default = 0];
inline bool RegionLoad::has_last_major_compaction_ts() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RegionLoad::clear_last_major_compaction_ts() {
  last_major_compaction_ts_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00008000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::last_major_compaction_ts() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.last_major_compaction_ts)
  return last_major_compaction_ts_;
}
inline void RegionLoad::set_last_major_compaction_ts(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00008000u;
  last_major_compaction_ts_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.last_major_compaction_ts)
}

// repeated .hbase.pb.StoreSequenceId store_complete_sequence_id = 18;
inline int RegionLoad::store_complete_sequence_id_size() const {
  return store_complete_sequence_id_.size();
}
inline void RegionLoad::clear_store_complete_sequence_id() {
  store_complete_sequence_id_.Clear();
}
inline ::hbase::pb::StoreSequenceId* RegionLoad::mutable_store_complete_sequence_id(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionLoad.store_complete_sequence_id)
  return store_complete_sequence_id_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >*
RegionLoad::mutable_store_complete_sequence_id() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.RegionLoad.store_complete_sequence_id)
  return &store_complete_sequence_id_;
}
inline const ::hbase::pb::StoreSequenceId& RegionLoad::store_complete_sequence_id(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.store_complete_sequence_id)
  return store_complete_sequence_id_.Get(index);
}
inline ::hbase::pb::StoreSequenceId* RegionLoad::add_store_complete_sequence_id() {
  // @@protoc_insertion_point(field_add:hbase.pb.RegionLoad.store_complete_sequence_id)
  return store_complete_sequence_id_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreSequenceId >&
RegionLoad::store_complete_sequence_id() const {
  // @@protoc_insertion_point(field_list:hbase.pb.RegionLoad.store_complete_sequence_id)
  return store_complete_sequence_id_;
}

// optional uint64 filtered_read_requests_count = 19;
inline bool RegionLoad::has_filtered_read_requests_count() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RegionLoad::clear_filtered_read_requests_count() {
  filtered_read_requests_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00010000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::filtered_read_requests_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.filtered_read_requests_count)
  return filtered_read_requests_count_;
}
inline void RegionLoad::set_filtered_read_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00010000u;
  filtered_read_requests_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.filtered_read_requests_count)
}

// optional uint64 cp_requests_count = 20;
inline bool RegionLoad::has_cp_requests_count() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RegionLoad::clear_cp_requests_count() {
  cp_requests_count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00020000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionLoad::cp_requests_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionLoad.cp_requests_count)
  return cp_requests_count_;
}
inline void RegionLoad::set_cp_requests_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00020000u;
  cp_requests_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionLoad.cp_requests_count)
}

// -------------------------------------------------------------------

// ReplicationLoadSink

// required uint64 ageOfLastAppliedOp = 1;
inline bool ReplicationLoadSink::has_ageoflastappliedop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationLoadSink::clear_ageoflastappliedop() {
  ageoflastappliedop_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplicationLoadSink::ageoflastappliedop() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSink.ageOfLastAppliedOp)
  return ageoflastappliedop_;
}
inline void ReplicationLoadSink::set_ageoflastappliedop(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  ageoflastappliedop_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSink.ageOfLastAppliedOp)
}

// required uint64 timeStampsOfLastAppliedOp = 2;
inline bool ReplicationLoadSink::has_timestampsoflastappliedop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplicationLoadSink::clear_timestampsoflastappliedop() {
  timestampsoflastappliedop_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplicationLoadSink::timestampsoflastappliedop() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSink.timeStampsOfLastAppliedOp)
  return timestampsoflastappliedop_;
}
inline void ReplicationLoadSink::set_timestampsoflastappliedop(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  timestampsoflastappliedop_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSink.timeStampsOfLastAppliedOp)
}

// -------------------------------------------------------------------

// ReplicationLoadSource

// required string peerID = 1;
inline bool ReplicationLoadSource::has_peerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationLoadSource::clear_peerid() {
  peerid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplicationLoadSource::peerid() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSource.peerID)
  return peerid_.GetNoArena();
}
inline void ReplicationLoadSource::set_peerid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peerid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSource.peerID)
}
inline void ReplicationLoadSource::set_peerid(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  peerid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ReplicationLoadSource.peerID)
}
inline void ReplicationLoadSource::set_peerid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  peerid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ReplicationLoadSource.peerID)
}
inline void ReplicationLoadSource::set_peerid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  peerid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ReplicationLoadSource.peerID)
}
inline std::string* ReplicationLoadSource::mutable_peerid() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationLoadSource.peerID)
  return peerid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ReplicationLoadSource::release_peerid() {
  // @@protoc_insertion_point(field_release:hbase.pb.ReplicationLoadSource.peerID)
  if (!has_peerid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return peerid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ReplicationLoadSource::set_allocated_peerid(std::string* peerid) {
  if (peerid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peerid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peerid);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ReplicationLoadSource.peerID)
}

// required uint64 ageOfLastShippedOp = 2;
inline bool ReplicationLoadSource::has_ageoflastshippedop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplicationLoadSource::clear_ageoflastshippedop() {
  ageoflastshippedop_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplicationLoadSource::ageoflastshippedop() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSource.ageOfLastShippedOp)
  return ageoflastshippedop_;
}
inline void ReplicationLoadSource::set_ageoflastshippedop(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ageoflastshippedop_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSource.ageOfLastShippedOp)
}

// required uint32 sizeOfLogQueue = 3;
inline bool ReplicationLoadSource::has_sizeoflogqueue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReplicationLoadSource::clear_sizeoflogqueue() {
  sizeoflogqueue_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ReplicationLoadSource::sizeoflogqueue() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSource.sizeOfLogQueue)
  return sizeoflogqueue_;
}
inline void ReplicationLoadSource::set_sizeoflogqueue(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  sizeoflogqueue_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSource.sizeOfLogQueue)
}

// required uint64 timeStampOfLastShippedOp = 4;
inline bool ReplicationLoadSource::has_timestampoflastshippedop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplicationLoadSource::clear_timestampoflastshippedop() {
  timestampoflastshippedop_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplicationLoadSource::timestampoflastshippedop() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSource.timeStampOfLastShippedOp)
  return timestampoflastshippedop_;
}
inline void ReplicationLoadSource::set_timestampoflastshippedop(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  timestampoflastshippedop_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSource.timeStampOfLastShippedOp)
}

// required uint64 replicationLag = 5;
inline bool ReplicationLoadSource::has_replicationlag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplicationLoadSource::clear_replicationlag() {
  replicationlag_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ReplicationLoadSource::replicationlag() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationLoadSource.replicationLag)
  return replicationlag_;
}
inline void ReplicationLoadSource::set_replicationlag(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  replicationlag_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationLoadSource.replicationLag)
}

// -------------------------------------------------------------------

// ServerLoad

// optional uint64 number_of_requests = 1;
inline bool ServerLoad::has_number_of_requests() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerLoad::clear_number_of_requests() {
  number_of_requests_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerLoad::number_of_requests() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.number_of_requests)
  return number_of_requests_;
}
inline void ServerLoad::set_number_of_requests(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  number_of_requests_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.number_of_requests)
}

// optional uint64 total_number_of_requests = 2;
inline bool ServerLoad::has_total_number_of_requests() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerLoad::clear_total_number_of_requests() {
  total_number_of_requests_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerLoad::total_number_of_requests() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.total_number_of_requests)
  return total_number_of_requests_;
}
inline void ServerLoad::set_total_number_of_requests(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  total_number_of_requests_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.total_number_of_requests)
}

// optional uint32 used_heap_MB = 3;
inline bool ServerLoad::has_used_heap_mb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerLoad::clear_used_heap_mb() {
  used_heap_mb_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerLoad::used_heap_mb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.used_heap_MB)
  return used_heap_mb_;
}
inline void ServerLoad::set_used_heap_mb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  used_heap_mb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.used_heap_MB)
}

// optional uint32 max_heap_MB = 4;
inline bool ServerLoad::has_max_heap_mb() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ServerLoad::clear_max_heap_mb() {
  max_heap_mb_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerLoad::max_heap_mb() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.max_heap_MB)
  return max_heap_mb_;
}
inline void ServerLoad::set_max_heap_mb(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  max_heap_mb_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.max_heap_MB)
}

// repeated .hbase.pb.RegionLoad region_loads = 5;
inline int ServerLoad::region_loads_size() const {
  return region_loads_.size();
}
inline void ServerLoad::clear_region_loads() {
  region_loads_.Clear();
}
inline ::hbase::pb::RegionLoad* ServerLoad::mutable_region_loads(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ServerLoad.region_loads)
  return region_loads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoad >*
ServerLoad::mutable_region_loads() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ServerLoad.region_loads)
  return &region_loads_;
}
inline const ::hbase::pb::RegionLoad& ServerLoad::region_loads(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.region_loads)
  return region_loads_.Get(index);
}
inline ::hbase::pb::RegionLoad* ServerLoad::add_region_loads() {
  // @@protoc_insertion_point(field_add:hbase.pb.ServerLoad.region_loads)
  return region_loads_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionLoad >&
ServerLoad::region_loads() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ServerLoad.region_loads)
  return region_loads_;
}

// repeated .hbase.pb.Coprocessor coprocessors = 6;
inline int ServerLoad::coprocessors_size() const {
  return coprocessors_.size();
}
inline ::hbase::pb::Coprocessor* ServerLoad::mutable_coprocessors(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ServerLoad.coprocessors)
  return coprocessors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >*
ServerLoad::mutable_coprocessors() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ServerLoad.coprocessors)
  return &coprocessors_;
}
inline const ::hbase::pb::Coprocessor& ServerLoad::coprocessors(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.coprocessors)
  return coprocessors_.Get(index);
}
inline ::hbase::pb::Coprocessor* ServerLoad::add_coprocessors() {
  // @@protoc_insertion_point(field_add:hbase.pb.ServerLoad.coprocessors)
  return coprocessors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >&
ServerLoad::coprocessors() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ServerLoad.coprocessors)
  return coprocessors_;
}

// optional uint64 report_start_time = 7;
inline bool ServerLoad::has_report_start_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerLoad::clear_report_start_time() {
  report_start_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerLoad::report_start_time() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.report_start_time)
  return report_start_time_;
}
inline void ServerLoad::set_report_start_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  report_start_time_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.report_start_time)
}

// optional uint64 report_end_time = 8;
inline bool ServerLoad::has_report_end_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ServerLoad::clear_report_end_time() {
  report_end_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerLoad::report_end_time() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.report_end_time)
  return report_end_time_;
}
inline void ServerLoad::set_report_end_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  report_end_time_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.report_end_time)
}

// optional uint32 info_server_port = 9;
inline bool ServerLoad::has_info_server_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ServerLoad::clear_info_server_port() {
  info_server_port_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerLoad::info_server_port() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.info_server_port)
  return info_server_port_;
}
inline void ServerLoad::set_info_server_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  info_server_port_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerLoad.info_server_port)
}

// repeated .hbase.pb.ReplicationLoadSource replLoadSource = 10;
inline int ServerLoad::replloadsource_size() const {
  return replloadsource_.size();
}
inline void ServerLoad::clear_replloadsource() {
  replloadsource_.Clear();
}
inline ::hbase::pb::ReplicationLoadSource* ServerLoad::mutable_replloadsource(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ServerLoad.replLoadSource)
  return replloadsource_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ReplicationLoadSource >*
ServerLoad::mutable_replloadsource() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ServerLoad.replLoadSource)
  return &replloadsource_;
}
inline const ::hbase::pb::ReplicationLoadSource& ServerLoad::replloadsource(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.replLoadSource)
  return replloadsource_.Get(index);
}
inline ::hbase::pb::ReplicationLoadSource* ServerLoad::add_replloadsource() {
  // @@protoc_insertion_point(field_add:hbase.pb.ServerLoad.replLoadSource)
  return replloadsource_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ReplicationLoadSource >&
ServerLoad::replloadsource() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ServerLoad.replLoadSource)
  return replloadsource_;
}

// optional .hbase.pb.ReplicationLoadSink replLoadSink = 11;
inline bool ServerLoad::has_replloadsink() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerLoad::clear_replloadsink() {
  if (replloadsink_ != nullptr) replloadsink_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::ReplicationLoadSink& ServerLoad::replloadsink() const {
  const ::hbase::pb::ReplicationLoadSink* p = replloadsink_;
  // @@protoc_insertion_point(field_get:hbase.pb.ServerLoad.replLoadSink)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ReplicationLoadSink*>(
      &::hbase::pb::_ReplicationLoadSink_default_instance_);
}
inline ::hbase::pb::ReplicationLoadSink* ServerLoad::release_replloadsink() {
  // @@protoc_insertion_point(field_release:hbase.pb.ServerLoad.replLoadSink)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ReplicationLoadSink* temp = replloadsink_;
  replloadsink_ = nullptr;
  return temp;
}
inline ::hbase::pb::ReplicationLoadSink* ServerLoad::mutable_replloadsink() {
  _has_bits_[0] |= 0x00000001u;
  if (replloadsink_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ReplicationLoadSink>(GetArenaNoVirtual());
    replloadsink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ServerLoad.replLoadSink)
  return replloadsink_;
}
inline void ServerLoad::set_allocated_replloadsink(::hbase::pb::ReplicationLoadSink* replloadsink) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete replloadsink_;
  }
  if (replloadsink) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      replloadsink = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replloadsink, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  replloadsink_ = replloadsink;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ServerLoad.replLoadSink)
}

// -------------------------------------------------------------------

// LiveServerInfo

// required .hbase.pb.ServerName server = 1;
inline bool LiveServerInfo::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::ServerName& LiveServerInfo::server() const {
  const ::hbase::pb::ServerName* p = server_;
  // @@protoc_insertion_point(field_get:hbase.pb.LiveServerInfo.server)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* LiveServerInfo::release_server() {
  // @@protoc_insertion_point(field_release:hbase.pb.LiveServerInfo.server)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ServerName* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* LiveServerInfo::mutable_server() {
  _has_bits_[0] |= 0x00000001u;
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.LiveServerInfo.server)
  return server_;
}
inline void LiveServerInfo::set_allocated_server(::hbase::pb::ServerName* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.LiveServerInfo.server)
}

// required .hbase.pb.ServerLoad server_load = 2;
inline bool LiveServerInfo::has_server_load() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LiveServerInfo::clear_server_load() {
  if (server_load_ != nullptr) server_load_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::ServerLoad& LiveServerInfo::server_load() const {
  const ::hbase::pb::ServerLoad* p = server_load_;
  // @@protoc_insertion_point(field_get:hbase.pb.LiveServerInfo.server_load)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerLoad*>(
      &::hbase::pb::_ServerLoad_default_instance_);
}
inline ::hbase::pb::ServerLoad* LiveServerInfo::release_server_load() {
  // @@protoc_insertion_point(field_release:hbase.pb.LiveServerInfo.server_load)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::ServerLoad* temp = server_load_;
  server_load_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerLoad* LiveServerInfo::mutable_server_load() {
  _has_bits_[0] |= 0x00000002u;
  if (server_load_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerLoad>(GetArenaNoVirtual());
    server_load_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.LiveServerInfo.server_load)
  return server_load_;
}
inline void LiveServerInfo::set_allocated_server_load(::hbase::pb::ServerLoad* server_load) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete server_load_;
  }
  if (server_load) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server_load = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_load, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  server_load_ = server_load;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.LiveServerInfo.server_load)
}

// -------------------------------------------------------------------

// ClusterStatus

// optional .hbase.pb.HBaseVersionFileContent hbase_version = 1;
inline bool ClusterStatus::has_hbase_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::HBaseVersionFileContent& ClusterStatus::hbase_version() const {
  const ::hbase::pb::HBaseVersionFileContent* p = hbase_version_;
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.hbase_version)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::HBaseVersionFileContent*>(
      &::hbase::pb::_HBaseVersionFileContent_default_instance_);
}
inline ::hbase::pb::HBaseVersionFileContent* ClusterStatus::release_hbase_version() {
  // @@protoc_insertion_point(field_release:hbase.pb.ClusterStatus.hbase_version)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::HBaseVersionFileContent* temp = hbase_version_;
  hbase_version_ = nullptr;
  return temp;
}
inline ::hbase::pb::HBaseVersionFileContent* ClusterStatus::mutable_hbase_version() {
  _has_bits_[0] |= 0x00000001u;
  if (hbase_version_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::HBaseVersionFileContent>(GetArenaNoVirtual());
    hbase_version_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.hbase_version)
  return hbase_version_;
}
inline void ClusterStatus::set_allocated_hbase_version(::hbase::pb::HBaseVersionFileContent* hbase_version) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hbase_version_);
  }
  if (hbase_version) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      hbase_version = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hbase_version, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hbase_version_ = hbase_version;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ClusterStatus.hbase_version)
}

// repeated .hbase.pb.LiveServerInfo live_servers = 2;
inline int ClusterStatus::live_servers_size() const {
  return live_servers_.size();
}
inline void ClusterStatus::clear_live_servers() {
  live_servers_.Clear();
}
inline ::hbase::pb::LiveServerInfo* ClusterStatus::mutable_live_servers(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.live_servers)
  return live_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::LiveServerInfo >*
ClusterStatus::mutable_live_servers() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ClusterStatus.live_servers)
  return &live_servers_;
}
inline const ::hbase::pb::LiveServerInfo& ClusterStatus::live_servers(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.live_servers)
  return live_servers_.Get(index);
}
inline ::hbase::pb::LiveServerInfo* ClusterStatus::add_live_servers() {
  // @@protoc_insertion_point(field_add:hbase.pb.ClusterStatus.live_servers)
  return live_servers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::LiveServerInfo >&
ClusterStatus::live_servers() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ClusterStatus.live_servers)
  return live_servers_;
}

// repeated .hbase.pb.ServerName dead_servers = 3;
inline int ClusterStatus::dead_servers_size() const {
  return dead_servers_.size();
}
inline ::hbase::pb::ServerName* ClusterStatus::mutable_dead_servers(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.dead_servers)
  return dead_servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
ClusterStatus::mutable_dead_servers() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ClusterStatus.dead_servers)
  return &dead_servers_;
}
inline const ::hbase::pb::ServerName& ClusterStatus::dead_servers(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.dead_servers)
  return dead_servers_.Get(index);
}
inline ::hbase::pb::ServerName* ClusterStatus::add_dead_servers() {
  // @@protoc_insertion_point(field_add:hbase.pb.ClusterStatus.dead_servers)
  return dead_servers_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
ClusterStatus::dead_servers() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ClusterStatus.dead_servers)
  return dead_servers_;
}

// repeated .hbase.pb.RegionInTransition regions_in_transition = 4;
inline int ClusterStatus::regions_in_transition_size() const {
  return regions_in_transition_.size();
}
inline void ClusterStatus::clear_regions_in_transition() {
  regions_in_transition_.Clear();
}
inline ::hbase::pb::RegionInTransition* ClusterStatus::mutable_regions_in_transition(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.regions_in_transition)
  return regions_in_transition_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionInTransition >*
ClusterStatus::mutable_regions_in_transition() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ClusterStatus.regions_in_transition)
  return &regions_in_transition_;
}
inline const ::hbase::pb::RegionInTransition& ClusterStatus::regions_in_transition(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.regions_in_transition)
  return regions_in_transition_.Get(index);
}
inline ::hbase::pb::RegionInTransition* ClusterStatus::add_regions_in_transition() {
  // @@protoc_insertion_point(field_add:hbase.pb.ClusterStatus.regions_in_transition)
  return regions_in_transition_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RegionInTransition >&
ClusterStatus::regions_in_transition() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ClusterStatus.regions_in_transition)
  return regions_in_transition_;
}

// optional .hbase.pb.ClusterId cluster_id = 5;
inline bool ClusterStatus::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::ClusterId& ClusterStatus::cluster_id() const {
  const ::hbase::pb::ClusterId* p = cluster_id_;
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.cluster_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ClusterId*>(
      &::hbase::pb::_ClusterId_default_instance_);
}
inline ::hbase::pb::ClusterId* ClusterStatus::release_cluster_id() {
  // @@protoc_insertion_point(field_release:hbase.pb.ClusterStatus.cluster_id)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::ClusterId* temp = cluster_id_;
  cluster_id_ = nullptr;
  return temp;
}
inline ::hbase::pb::ClusterId* ClusterStatus::mutable_cluster_id() {
  _has_bits_[0] |= 0x00000002u;
  if (cluster_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ClusterId>(GetArenaNoVirtual());
    cluster_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.cluster_id)
  return cluster_id_;
}
inline void ClusterStatus::set_allocated_cluster_id(::hbase::pb::ClusterId* cluster_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_id_);
  }
  if (cluster_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cluster_id_ = cluster_id;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ClusterStatus.cluster_id)
}

// repeated .hbase.pb.Coprocessor master_coprocessors = 6;
inline int ClusterStatus::master_coprocessors_size() const {
  return master_coprocessors_.size();
}
inline ::hbase::pb::Coprocessor* ClusterStatus::mutable_master_coprocessors(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.master_coprocessors)
  return master_coprocessors_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >*
ClusterStatus::mutable_master_coprocessors() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ClusterStatus.master_coprocessors)
  return &master_coprocessors_;
}
inline const ::hbase::pb::Coprocessor& ClusterStatus::master_coprocessors(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.master_coprocessors)
  return master_coprocessors_.Get(index);
}
inline ::hbase::pb::Coprocessor* ClusterStatus::add_master_coprocessors() {
  // @@protoc_insertion_point(field_add:hbase.pb.ClusterStatus.master_coprocessors)
  return master_coprocessors_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Coprocessor >&
ClusterStatus::master_coprocessors() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ClusterStatus.master_coprocessors)
  return master_coprocessors_;
}

// optional .hbase.pb.ServerName master = 7;
inline bool ClusterStatus::has_master() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::ServerName& ClusterStatus::master() const {
  const ::hbase::pb::ServerName* p = master_;
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.master)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* ClusterStatus::release_master() {
  // @@protoc_insertion_point(field_release:hbase.pb.ClusterStatus.master)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::ServerName* temp = master_;
  master_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* ClusterStatus::mutable_master() {
  _has_bits_[0] |= 0x00000004u;
  if (master_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    master_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.master)
  return master_;
}
inline void ClusterStatus::set_allocated_master(::hbase::pb::ServerName* master) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_);
  }
  if (master) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  master_ = master;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ClusterStatus.master)
}

// repeated .hbase.pb.ServerName backup_masters = 8;
inline int ClusterStatus::backup_masters_size() const {
  return backup_masters_.size();
}
inline ::hbase::pb::ServerName* ClusterStatus::mutable_backup_masters(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterStatus.backup_masters)
  return backup_masters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
ClusterStatus::mutable_backup_masters() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ClusterStatus.backup_masters)
  return &backup_masters_;
}
inline const ::hbase::pb::ServerName& ClusterStatus::backup_masters(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.backup_masters)
  return backup_masters_.Get(index);
}
inline ::hbase::pb::ServerName* ClusterStatus::add_backup_masters() {
  // @@protoc_insertion_point(field_add:hbase.pb.ClusterStatus.backup_masters)
  return backup_masters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
ClusterStatus::backup_masters() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ClusterStatus.backup_masters)
  return backup_masters_;
}

// optional bool balancer_on = 9;
inline bool ClusterStatus::has_balancer_on() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClusterStatus::clear_balancer_on() {
  balancer_on_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClusterStatus::balancer_on() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterStatus.balancer_on)
  return balancer_on_;
}
inline void ClusterStatus::set_balancer_on(bool value) {
  _has_bits_[0] |= 0x00000008u;
  balancer_on_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ClusterStatus.balancer_on)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::RegionState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::RegionState_State>() {
  return ::hbase::pb::RegionState_State_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::Option> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::Option>() {
  return ::hbase::pb::Option_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ClusterStatus_2eproto
