// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Filter.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Filter_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Filter_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "Comparator.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Filter_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Filter_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[31]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Filter_2eproto;
namespace hbase {
namespace pb {
class ColumnCountGetFilter;
class ColumnCountGetFilterDefaultTypeInternal;
extern ColumnCountGetFilterDefaultTypeInternal _ColumnCountGetFilter_default_instance_;
class ColumnPaginationFilter;
class ColumnPaginationFilterDefaultTypeInternal;
extern ColumnPaginationFilterDefaultTypeInternal _ColumnPaginationFilter_default_instance_;
class ColumnPrefixFilter;
class ColumnPrefixFilterDefaultTypeInternal;
extern ColumnPrefixFilterDefaultTypeInternal _ColumnPrefixFilter_default_instance_;
class ColumnRangeFilter;
class ColumnRangeFilterDefaultTypeInternal;
extern ColumnRangeFilterDefaultTypeInternal _ColumnRangeFilter_default_instance_;
class ColumnValueFilter;
class ColumnValueFilterDefaultTypeInternal;
extern ColumnValueFilterDefaultTypeInternal _ColumnValueFilter_default_instance_;
class CompareFilter;
class CompareFilterDefaultTypeInternal;
extern CompareFilterDefaultTypeInternal _CompareFilter_default_instance_;
class DependentColumnFilter;
class DependentColumnFilterDefaultTypeInternal;
extern DependentColumnFilterDefaultTypeInternal _DependentColumnFilter_default_instance_;
class FamilyFilter;
class FamilyFilterDefaultTypeInternal;
extern FamilyFilterDefaultTypeInternal _FamilyFilter_default_instance_;
class Filter;
class FilterDefaultTypeInternal;
extern FilterDefaultTypeInternal _Filter_default_instance_;
class FilterAllFilter;
class FilterAllFilterDefaultTypeInternal;
extern FilterAllFilterDefaultTypeInternal _FilterAllFilter_default_instance_;
class FilterList;
class FilterListDefaultTypeInternal;
extern FilterListDefaultTypeInternal _FilterList_default_instance_;
class FilterWrapper;
class FilterWrapperDefaultTypeInternal;
extern FilterWrapperDefaultTypeInternal _FilterWrapper_default_instance_;
class FirstKeyOnlyFilter;
class FirstKeyOnlyFilterDefaultTypeInternal;
extern FirstKeyOnlyFilterDefaultTypeInternal _FirstKeyOnlyFilter_default_instance_;
class FirstKeyValueMatchingQualifiersFilter;
class FirstKeyValueMatchingQualifiersFilterDefaultTypeInternal;
extern FirstKeyValueMatchingQualifiersFilterDefaultTypeInternal _FirstKeyValueMatchingQualifiersFilter_default_instance_;
class FuzzyRowFilter;
class FuzzyRowFilterDefaultTypeInternal;
extern FuzzyRowFilterDefaultTypeInternal _FuzzyRowFilter_default_instance_;
class InclusiveStopFilter;
class InclusiveStopFilterDefaultTypeInternal;
extern InclusiveStopFilterDefaultTypeInternal _InclusiveStopFilter_default_instance_;
class KeyOnlyFilter;
class KeyOnlyFilterDefaultTypeInternal;
extern KeyOnlyFilterDefaultTypeInternal _KeyOnlyFilter_default_instance_;
class MultiRowRangeFilter;
class MultiRowRangeFilterDefaultTypeInternal;
extern MultiRowRangeFilterDefaultTypeInternal _MultiRowRangeFilter_default_instance_;
class MultipleColumnPrefixFilter;
class MultipleColumnPrefixFilterDefaultTypeInternal;
extern MultipleColumnPrefixFilterDefaultTypeInternal _MultipleColumnPrefixFilter_default_instance_;
class PageFilter;
class PageFilterDefaultTypeInternal;
extern PageFilterDefaultTypeInternal _PageFilter_default_instance_;
class PrefixFilter;
class PrefixFilterDefaultTypeInternal;
extern PrefixFilterDefaultTypeInternal _PrefixFilter_default_instance_;
class QualifierFilter;
class QualifierFilterDefaultTypeInternal;
extern QualifierFilterDefaultTypeInternal _QualifierFilter_default_instance_;
class RandomRowFilter;
class RandomRowFilterDefaultTypeInternal;
extern RandomRowFilterDefaultTypeInternal _RandomRowFilter_default_instance_;
class RowFilter;
class RowFilterDefaultTypeInternal;
extern RowFilterDefaultTypeInternal _RowFilter_default_instance_;
class RowRange;
class RowRangeDefaultTypeInternal;
extern RowRangeDefaultTypeInternal _RowRange_default_instance_;
class SingleColumnValueExcludeFilter;
class SingleColumnValueExcludeFilterDefaultTypeInternal;
extern SingleColumnValueExcludeFilterDefaultTypeInternal _SingleColumnValueExcludeFilter_default_instance_;
class SingleColumnValueFilter;
class SingleColumnValueFilterDefaultTypeInternal;
extern SingleColumnValueFilterDefaultTypeInternal _SingleColumnValueFilter_default_instance_;
class SkipFilter;
class SkipFilterDefaultTypeInternal;
extern SkipFilterDefaultTypeInternal _SkipFilter_default_instance_;
class TimestampsFilter;
class TimestampsFilterDefaultTypeInternal;
extern TimestampsFilterDefaultTypeInternal _TimestampsFilter_default_instance_;
class ValueFilter;
class ValueFilterDefaultTypeInternal;
extern ValueFilterDefaultTypeInternal _ValueFilter_default_instance_;
class WhileMatchFilter;
class WhileMatchFilterDefaultTypeInternal;
extern WhileMatchFilterDefaultTypeInternal _WhileMatchFilter_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::ColumnCountGetFilter* Arena::CreateMaybeMessage<::hbase::pb::ColumnCountGetFilter>(Arena*);
template<> ::hbase::pb::ColumnPaginationFilter* Arena::CreateMaybeMessage<::hbase::pb::ColumnPaginationFilter>(Arena*);
template<> ::hbase::pb::ColumnPrefixFilter* Arena::CreateMaybeMessage<::hbase::pb::ColumnPrefixFilter>(Arena*);
template<> ::hbase::pb::ColumnRangeFilter* Arena::CreateMaybeMessage<::hbase::pb::ColumnRangeFilter>(Arena*);
template<> ::hbase::pb::ColumnValueFilter* Arena::CreateMaybeMessage<::hbase::pb::ColumnValueFilter>(Arena*);
template<> ::hbase::pb::CompareFilter* Arena::CreateMaybeMessage<::hbase::pb::CompareFilter>(Arena*);
template<> ::hbase::pb::DependentColumnFilter* Arena::CreateMaybeMessage<::hbase::pb::DependentColumnFilter>(Arena*);
template<> ::hbase::pb::FamilyFilter* Arena::CreateMaybeMessage<::hbase::pb::FamilyFilter>(Arena*);
template<> ::hbase::pb::Filter* Arena::CreateMaybeMessage<::hbase::pb::Filter>(Arena*);
template<> ::hbase::pb::FilterAllFilter* Arena::CreateMaybeMessage<::hbase::pb::FilterAllFilter>(Arena*);
template<> ::hbase::pb::FilterList* Arena::CreateMaybeMessage<::hbase::pb::FilterList>(Arena*);
template<> ::hbase::pb::FilterWrapper* Arena::CreateMaybeMessage<::hbase::pb::FilterWrapper>(Arena*);
template<> ::hbase::pb::FirstKeyOnlyFilter* Arena::CreateMaybeMessage<::hbase::pb::FirstKeyOnlyFilter>(Arena*);
template<> ::hbase::pb::FirstKeyValueMatchingQualifiersFilter* Arena::CreateMaybeMessage<::hbase::pb::FirstKeyValueMatchingQualifiersFilter>(Arena*);
template<> ::hbase::pb::FuzzyRowFilter* Arena::CreateMaybeMessage<::hbase::pb::FuzzyRowFilter>(Arena*);
template<> ::hbase::pb::InclusiveStopFilter* Arena::CreateMaybeMessage<::hbase::pb::InclusiveStopFilter>(Arena*);
template<> ::hbase::pb::KeyOnlyFilter* Arena::CreateMaybeMessage<::hbase::pb::KeyOnlyFilter>(Arena*);
template<> ::hbase::pb::MultiRowRangeFilter* Arena::CreateMaybeMessage<::hbase::pb::MultiRowRangeFilter>(Arena*);
template<> ::hbase::pb::MultipleColumnPrefixFilter* Arena::CreateMaybeMessage<::hbase::pb::MultipleColumnPrefixFilter>(Arena*);
template<> ::hbase::pb::PageFilter* Arena::CreateMaybeMessage<::hbase::pb::PageFilter>(Arena*);
template<> ::hbase::pb::PrefixFilter* Arena::CreateMaybeMessage<::hbase::pb::PrefixFilter>(Arena*);
template<> ::hbase::pb::QualifierFilter* Arena::CreateMaybeMessage<::hbase::pb::QualifierFilter>(Arena*);
template<> ::hbase::pb::RandomRowFilter* Arena::CreateMaybeMessage<::hbase::pb::RandomRowFilter>(Arena*);
template<> ::hbase::pb::RowFilter* Arena::CreateMaybeMessage<::hbase::pb::RowFilter>(Arena*);
template<> ::hbase::pb::RowRange* Arena::CreateMaybeMessage<::hbase::pb::RowRange>(Arena*);
template<> ::hbase::pb::SingleColumnValueExcludeFilter* Arena::CreateMaybeMessage<::hbase::pb::SingleColumnValueExcludeFilter>(Arena*);
template<> ::hbase::pb::SingleColumnValueFilter* Arena::CreateMaybeMessage<::hbase::pb::SingleColumnValueFilter>(Arena*);
template<> ::hbase::pb::SkipFilter* Arena::CreateMaybeMessage<::hbase::pb::SkipFilter>(Arena*);
template<> ::hbase::pb::TimestampsFilter* Arena::CreateMaybeMessage<::hbase::pb::TimestampsFilter>(Arena*);
template<> ::hbase::pb::ValueFilter* Arena::CreateMaybeMessage<::hbase::pb::ValueFilter>(Arena*);
template<> ::hbase::pb::WhileMatchFilter* Arena::CreateMaybeMessage<::hbase::pb::WhileMatchFilter>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum FilterList_Operator : int {
  FilterList_Operator_MUST_PASS_ALL = 1,
  FilterList_Operator_MUST_PASS_ONE = 2
};
bool FilterList_Operator_IsValid(int value);
constexpr FilterList_Operator FilterList_Operator_Operator_MIN = FilterList_Operator_MUST_PASS_ALL;
constexpr FilterList_Operator FilterList_Operator_Operator_MAX = FilterList_Operator_MUST_PASS_ONE;
constexpr int FilterList_Operator_Operator_ARRAYSIZE = FilterList_Operator_Operator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FilterList_Operator_descriptor();
template<typename T>
inline const std::string& FilterList_Operator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FilterList_Operator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FilterList_Operator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FilterList_Operator_descriptor(), enum_t_value);
}
inline bool FilterList_Operator_Parse(
    const std::string& name, FilterList_Operator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FilterList_Operator>(
    FilterList_Operator_descriptor(), name, value);
}
// ===================================================================

class Filter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Filter) */ {
 public:
  Filter();
  virtual ~Filter();

  Filter(const Filter& from);
  Filter(Filter&& from) noexcept
    : Filter() {
    *this = ::std::move(from);
  }

  inline Filter& operator=(const Filter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Filter& operator=(Filter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Filter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Filter* internal_default_instance() {
    return reinterpret_cast<const Filter*>(
               &_Filter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Filter& a, Filter& b) {
    a.Swap(&b);
  }
  inline void Swap(Filter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Filter* New() const final {
    return CreateMaybeMessage<Filter>(nullptr);
  }

  Filter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Filter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Filter& from);
  void MergeFrom(const Filter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Filter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Filter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kSerializedFilterFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional bytes serialized_filter = 2;
  bool has_serialized_filter() const;
  void clear_serialized_filter();
  const std::string& serialized_filter() const;
  void set_serialized_filter(const std::string& value);
  void set_serialized_filter(std::string&& value);
  void set_serialized_filter(const char* value);
  void set_serialized_filter(const void* value, size_t size);
  std::string* mutable_serialized_filter();
  std::string* release_serialized_filter();
  void set_allocated_serialized_filter(std::string* serialized_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.Filter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ColumnCountGetFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnCountGetFilter) */ {
 public:
  ColumnCountGetFilter();
  virtual ~ColumnCountGetFilter();

  ColumnCountGetFilter(const ColumnCountGetFilter& from);
  ColumnCountGetFilter(ColumnCountGetFilter&& from) noexcept
    : ColumnCountGetFilter() {
    *this = ::std::move(from);
  }

  inline ColumnCountGetFilter& operator=(const ColumnCountGetFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnCountGetFilter& operator=(ColumnCountGetFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnCountGetFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnCountGetFilter* internal_default_instance() {
    return reinterpret_cast<const ColumnCountGetFilter*>(
               &_ColumnCountGetFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ColumnCountGetFilter& a, ColumnCountGetFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnCountGetFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnCountGetFilter* New() const final {
    return CreateMaybeMessage<ColumnCountGetFilter>(nullptr);
  }

  ColumnCountGetFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnCountGetFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnCountGetFilter& from);
  void MergeFrom(const ColumnCountGetFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnCountGetFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnCountGetFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLimitFieldNumber = 1,
  };
  // required int32 limit = 1;
  bool has_limit() const;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnCountGetFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ColumnPaginationFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnPaginationFilter) */ {
 public:
  ColumnPaginationFilter();
  virtual ~ColumnPaginationFilter();

  ColumnPaginationFilter(const ColumnPaginationFilter& from);
  ColumnPaginationFilter(ColumnPaginationFilter&& from) noexcept
    : ColumnPaginationFilter() {
    *this = ::std::move(from);
  }

  inline ColumnPaginationFilter& operator=(const ColumnPaginationFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnPaginationFilter& operator=(ColumnPaginationFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnPaginationFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnPaginationFilter* internal_default_instance() {
    return reinterpret_cast<const ColumnPaginationFilter*>(
               &_ColumnPaginationFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ColumnPaginationFilter& a, ColumnPaginationFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnPaginationFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnPaginationFilter* New() const final {
    return CreateMaybeMessage<ColumnPaginationFilter>(nullptr);
  }

  ColumnPaginationFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnPaginationFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnPaginationFilter& from);
  void MergeFrom(const ColumnPaginationFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnPaginationFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnPaginationFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnOffsetFieldNumber = 3,
    kLimitFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // optional bytes column_offset = 3;
  bool has_column_offset() const;
  void clear_column_offset();
  const std::string& column_offset() const;
  void set_column_offset(const std::string& value);
  void set_column_offset(std::string&& value);
  void set_column_offset(const char* value);
  void set_column_offset(const void* value, size_t size);
  std::string* mutable_column_offset();
  std::string* release_column_offset();
  void set_allocated_column_offset(std::string* column_offset);

  // required int32 limit = 1;
  bool has_limit() const;
  void clear_limit();
  ::PROTOBUF_NAMESPACE_ID::int32 limit() const;
  void set_limit(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional int32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::int32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnPaginationFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_offset_;
  ::PROTOBUF_NAMESPACE_ID::int32 limit_;
  ::PROTOBUF_NAMESPACE_ID::int32 offset_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ColumnPrefixFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnPrefixFilter) */ {
 public:
  ColumnPrefixFilter();
  virtual ~ColumnPrefixFilter();

  ColumnPrefixFilter(const ColumnPrefixFilter& from);
  ColumnPrefixFilter(ColumnPrefixFilter&& from) noexcept
    : ColumnPrefixFilter() {
    *this = ::std::move(from);
  }

  inline ColumnPrefixFilter& operator=(const ColumnPrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnPrefixFilter& operator=(ColumnPrefixFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnPrefixFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnPrefixFilter* internal_default_instance() {
    return reinterpret_cast<const ColumnPrefixFilter*>(
               &_ColumnPrefixFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ColumnPrefixFilter& a, ColumnPrefixFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnPrefixFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnPrefixFilter* New() const final {
    return CreateMaybeMessage<ColumnPrefixFilter>(nullptr);
  }

  ColumnPrefixFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnPrefixFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnPrefixFilter& from);
  void MergeFrom(const ColumnPrefixFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnPrefixFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnPrefixFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
  };
  // required bytes prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  const std::string& prefix() const;
  void set_prefix(const std::string& value);
  void set_prefix(std::string&& value);
  void set_prefix(const char* value);
  void set_prefix(const void* value, size_t size);
  std::string* mutable_prefix();
  std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnPrefixFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ColumnRangeFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnRangeFilter) */ {
 public:
  ColumnRangeFilter();
  virtual ~ColumnRangeFilter();

  ColumnRangeFilter(const ColumnRangeFilter& from);
  ColumnRangeFilter(ColumnRangeFilter&& from) noexcept
    : ColumnRangeFilter() {
    *this = ::std::move(from);
  }

  inline ColumnRangeFilter& operator=(const ColumnRangeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnRangeFilter& operator=(ColumnRangeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnRangeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnRangeFilter* internal_default_instance() {
    return reinterpret_cast<const ColumnRangeFilter*>(
               &_ColumnRangeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ColumnRangeFilter& a, ColumnRangeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnRangeFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnRangeFilter* New() const final {
    return CreateMaybeMessage<ColumnRangeFilter>(nullptr);
  }

  ColumnRangeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnRangeFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnRangeFilter& from);
  void MergeFrom(const ColumnRangeFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnRangeFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnRangeFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinColumnFieldNumber = 1,
    kMaxColumnFieldNumber = 3,
    kMinColumnInclusiveFieldNumber = 2,
    kMaxColumnInclusiveFieldNumber = 4,
  };
  // optional bytes min_column = 1;
  bool has_min_column() const;
  void clear_min_column();
  const std::string& min_column() const;
  void set_min_column(const std::string& value);
  void set_min_column(std::string&& value);
  void set_min_column(const char* value);
  void set_min_column(const void* value, size_t size);
  std::string* mutable_min_column();
  std::string* release_min_column();
  void set_allocated_min_column(std::string* min_column);

  // optional bytes max_column = 3;
  bool has_max_column() const;
  void clear_max_column();
  const std::string& max_column() const;
  void set_max_column(const std::string& value);
  void set_max_column(std::string&& value);
  void set_max_column(const char* value);
  void set_max_column(const void* value, size_t size);
  std::string* mutable_max_column();
  std::string* release_max_column();
  void set_allocated_max_column(std::string* max_column);

  // optional bool min_column_inclusive = 2;
  bool has_min_column_inclusive() const;
  void clear_min_column_inclusive();
  bool min_column_inclusive() const;
  void set_min_column_inclusive(bool value);

  // optional bool max_column_inclusive = 4;
  bool has_max_column_inclusive() const;
  void clear_max_column_inclusive();
  bool max_column_inclusive() const;
  void set_max_column_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnRangeFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr min_column_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr max_column_;
  bool min_column_inclusive_;
  bool max_column_inclusive_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class CompareFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CompareFilter) */ {
 public:
  CompareFilter();
  virtual ~CompareFilter();

  CompareFilter(const CompareFilter& from);
  CompareFilter(CompareFilter&& from) noexcept
    : CompareFilter() {
    *this = ::std::move(from);
  }

  inline CompareFilter& operator=(const CompareFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompareFilter& operator=(CompareFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompareFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompareFilter* internal_default_instance() {
    return reinterpret_cast<const CompareFilter*>(
               &_CompareFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CompareFilter& a, CompareFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(CompareFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompareFilter* New() const final {
    return CreateMaybeMessage<CompareFilter>(nullptr);
  }

  CompareFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompareFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompareFilter& from);
  void MergeFrom(const CompareFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompareFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CompareFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComparatorFieldNumber = 2,
    kCompareOpFieldNumber = 1,
  };
  // optional .hbase.pb.Comparator comparator = 2;
  bool has_comparator() const;
  void clear_comparator();
  const ::hbase::pb::Comparator& comparator() const;
  ::hbase::pb::Comparator* release_comparator();
  ::hbase::pb::Comparator* mutable_comparator();
  void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // required .hbase.pb.CompareType compare_op = 1;
  bool has_compare_op() const;
  void clear_compare_op();
  ::hbase::pb::CompareType compare_op() const;
  void set_compare_op(::hbase::pb::CompareType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.CompareFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Comparator* comparator_;
  int compare_op_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class DependentColumnFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.DependentColumnFilter) */ {
 public:
  DependentColumnFilter();
  virtual ~DependentColumnFilter();

  DependentColumnFilter(const DependentColumnFilter& from);
  DependentColumnFilter(DependentColumnFilter&& from) noexcept
    : DependentColumnFilter() {
    *this = ::std::move(from);
  }

  inline DependentColumnFilter& operator=(const DependentColumnFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline DependentColumnFilter& operator=(DependentColumnFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DependentColumnFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DependentColumnFilter* internal_default_instance() {
    return reinterpret_cast<const DependentColumnFilter*>(
               &_DependentColumnFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DependentColumnFilter& a, DependentColumnFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(DependentColumnFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DependentColumnFilter* New() const final {
    return CreateMaybeMessage<DependentColumnFilter>(nullptr);
  }

  DependentColumnFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DependentColumnFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DependentColumnFilter& from);
  void MergeFrom(const DependentColumnFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DependentColumnFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.DependentColumnFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFamilyFieldNumber = 2,
    kColumnQualifierFieldNumber = 3,
    kCompareFilterFieldNumber = 1,
    kDropDependentColumnFieldNumber = 4,
  };
  // optional bytes column_family = 2;
  bool has_column_family() const;
  void clear_column_family();
  const std::string& column_family() const;
  void set_column_family(const std::string& value);
  void set_column_family(std::string&& value);
  void set_column_family(const char* value);
  void set_column_family(const void* value, size_t size);
  std::string* mutable_column_family();
  std::string* release_column_family();
  void set_allocated_column_family(std::string* column_family);

  // optional bytes column_qualifier = 3;
  bool has_column_qualifier() const;
  void clear_column_qualifier();
  const std::string& column_qualifier() const;
  void set_column_qualifier(const std::string& value);
  void set_column_qualifier(std::string&& value);
  void set_column_qualifier(const char* value);
  void set_column_qualifier(const void* value, size_t size);
  std::string* mutable_column_qualifier();
  std::string* release_column_qualifier();
  void set_allocated_column_qualifier(std::string* column_qualifier);

  // required .hbase.pb.CompareFilter compare_filter = 1;
  bool has_compare_filter() const;
  void clear_compare_filter();
  const ::hbase::pb::CompareFilter& compare_filter() const;
  ::hbase::pb::CompareFilter* release_compare_filter();
  ::hbase::pb::CompareFilter* mutable_compare_filter();
  void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // optional bool drop_dependent_column = 4;
  bool has_drop_dependent_column() const;
  void clear_drop_dependent_column();
  bool drop_dependent_column() const;
  void set_drop_dependent_column(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DependentColumnFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_qualifier_;
  ::hbase::pb::CompareFilter* compare_filter_;
  bool drop_dependent_column_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FamilyFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FamilyFilter) */ {
 public:
  FamilyFilter();
  virtual ~FamilyFilter();

  FamilyFilter(const FamilyFilter& from);
  FamilyFilter(FamilyFilter&& from) noexcept
    : FamilyFilter() {
    *this = ::std::move(from);
  }

  inline FamilyFilter& operator=(const FamilyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FamilyFilter& operator=(FamilyFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FamilyFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FamilyFilter* internal_default_instance() {
    return reinterpret_cast<const FamilyFilter*>(
               &_FamilyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FamilyFilter& a, FamilyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FamilyFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FamilyFilter* New() const final {
    return CreateMaybeMessage<FamilyFilter>(nullptr);
  }

  FamilyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FamilyFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FamilyFilter& from);
  void MergeFrom(const FamilyFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FamilyFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FamilyFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompareFilterFieldNumber = 1,
  };
  // required .hbase.pb.CompareFilter compare_filter = 1;
  bool has_compare_filter() const;
  void clear_compare_filter();
  const ::hbase::pb::CompareFilter& compare_filter() const;
  ::hbase::pb::CompareFilter* release_compare_filter();
  ::hbase::pb::CompareFilter* mutable_compare_filter();
  void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.FamilyFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::CompareFilter* compare_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FilterList :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FilterList) */ {
 public:
  FilterList();
  virtual ~FilterList();

  FilterList(const FilterList& from);
  FilterList(FilterList&& from) noexcept
    : FilterList() {
    *this = ::std::move(from);
  }

  inline FilterList& operator=(const FilterList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterList& operator=(FilterList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FilterList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterList* internal_default_instance() {
    return reinterpret_cast<const FilterList*>(
               &_FilterList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FilterList& a, FilterList& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterList* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilterList* New() const final {
    return CreateMaybeMessage<FilterList>(nullptr);
  }

  FilterList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilterList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FilterList& from);
  void MergeFrom(const FilterList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FilterList";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FilterList_Operator Operator;
  static constexpr Operator MUST_PASS_ALL =
    FilterList_Operator_MUST_PASS_ALL;
  static constexpr Operator MUST_PASS_ONE =
    FilterList_Operator_MUST_PASS_ONE;
  static inline bool Operator_IsValid(int value) {
    return FilterList_Operator_IsValid(value);
  }
  static constexpr Operator Operator_MIN =
    FilterList_Operator_Operator_MIN;
  static constexpr Operator Operator_MAX =
    FilterList_Operator_Operator_MAX;
  static constexpr int Operator_ARRAYSIZE =
    FilterList_Operator_Operator_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Operator_descriptor() {
    return FilterList_Operator_descriptor();
  }
  template<typename T>
  static inline const std::string& Operator_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operator>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operator_Name.");
    return FilterList_Operator_Name(enum_t_value);
  }
  static inline bool Operator_Parse(const std::string& name,
      Operator* value) {
    return FilterList_Operator_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFiltersFieldNumber = 2,
    kOperatorFieldNumber = 1,
  };
  // repeated .hbase.pb.Filter filters = 2;
  int filters_size() const;
  void clear_filters();
  ::hbase::pb::Filter* mutable_filters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Filter >*
      mutable_filters();
  const ::hbase::pb::Filter& filters(int index) const;
  ::hbase::pb::Filter* add_filters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Filter >&
      filters() const;

  // required .hbase.pb.FilterList.Operator operator = 1;
  bool has_operator_() const;
  void clear_operator_();
  ::hbase::pb::FilterList_Operator operator_() const;
  void set_operator_(::hbase::pb::FilterList_Operator value);

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterList)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Filter > filters_;
  int operator__;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FilterWrapper :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FilterWrapper) */ {
 public:
  FilterWrapper();
  virtual ~FilterWrapper();

  FilterWrapper(const FilterWrapper& from);
  FilterWrapper(FilterWrapper&& from) noexcept
    : FilterWrapper() {
    *this = ::std::move(from);
  }

  inline FilterWrapper& operator=(const FilterWrapper& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterWrapper& operator=(FilterWrapper&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FilterWrapper& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterWrapper* internal_default_instance() {
    return reinterpret_cast<const FilterWrapper*>(
               &_FilterWrapper_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(FilterWrapper& a, FilterWrapper& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterWrapper* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilterWrapper* New() const final {
    return CreateMaybeMessage<FilterWrapper>(nullptr);
  }

  FilterWrapper* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilterWrapper>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FilterWrapper& from);
  void MergeFrom(const FilterWrapper& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterWrapper* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FilterWrapper";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // required .hbase.pb.Filter filter = 1;
  bool has_filter() const;
  void clear_filter();
  const ::hbase::pb::Filter& filter() const;
  ::hbase::pb::Filter* release_filter();
  ::hbase::pb::Filter* mutable_filter();
  void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterWrapper)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Filter* filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FirstKeyOnlyFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FirstKeyOnlyFilter) */ {
 public:
  FirstKeyOnlyFilter();
  virtual ~FirstKeyOnlyFilter();

  FirstKeyOnlyFilter(const FirstKeyOnlyFilter& from);
  FirstKeyOnlyFilter(FirstKeyOnlyFilter&& from) noexcept
    : FirstKeyOnlyFilter() {
    *this = ::std::move(from);
  }

  inline FirstKeyOnlyFilter& operator=(const FirstKeyOnlyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirstKeyOnlyFilter& operator=(FirstKeyOnlyFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FirstKeyOnlyFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirstKeyOnlyFilter* internal_default_instance() {
    return reinterpret_cast<const FirstKeyOnlyFilter*>(
               &_FirstKeyOnlyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FirstKeyOnlyFilter& a, FirstKeyOnlyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FirstKeyOnlyFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirstKeyOnlyFilter* New() const final {
    return CreateMaybeMessage<FirstKeyOnlyFilter>(nullptr);
  }

  FirstKeyOnlyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirstKeyOnlyFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FirstKeyOnlyFilter& from);
  void MergeFrom(const FirstKeyOnlyFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirstKeyOnlyFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FirstKeyOnlyFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.FirstKeyOnlyFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FirstKeyValueMatchingQualifiersFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FirstKeyValueMatchingQualifiersFilter) */ {
 public:
  FirstKeyValueMatchingQualifiersFilter();
  virtual ~FirstKeyValueMatchingQualifiersFilter();

  FirstKeyValueMatchingQualifiersFilter(const FirstKeyValueMatchingQualifiersFilter& from);
  FirstKeyValueMatchingQualifiersFilter(FirstKeyValueMatchingQualifiersFilter&& from) noexcept
    : FirstKeyValueMatchingQualifiersFilter() {
    *this = ::std::move(from);
  }

  inline FirstKeyValueMatchingQualifiersFilter& operator=(const FirstKeyValueMatchingQualifiersFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FirstKeyValueMatchingQualifiersFilter& operator=(FirstKeyValueMatchingQualifiersFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FirstKeyValueMatchingQualifiersFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FirstKeyValueMatchingQualifiersFilter* internal_default_instance() {
    return reinterpret_cast<const FirstKeyValueMatchingQualifiersFilter*>(
               &_FirstKeyValueMatchingQualifiersFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(FirstKeyValueMatchingQualifiersFilter& a, FirstKeyValueMatchingQualifiersFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FirstKeyValueMatchingQualifiersFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FirstKeyValueMatchingQualifiersFilter* New() const final {
    return CreateMaybeMessage<FirstKeyValueMatchingQualifiersFilter>(nullptr);
  }

  FirstKeyValueMatchingQualifiersFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FirstKeyValueMatchingQualifiersFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FirstKeyValueMatchingQualifiersFilter& from);
  void MergeFrom(const FirstKeyValueMatchingQualifiersFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FirstKeyValueMatchingQualifiersFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FirstKeyValueMatchingQualifiersFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQualifiersFieldNumber = 1,
  };
  // repeated bytes qualifiers = 1;
  int qualifiers_size() const;
  void clear_qualifiers();
  const std::string& qualifiers(int index) const;
  std::string* mutable_qualifiers(int index);
  void set_qualifiers(int index, const std::string& value);
  void set_qualifiers(int index, std::string&& value);
  void set_qualifiers(int index, const char* value);
  void set_qualifiers(int index, const void* value, size_t size);
  std::string* add_qualifiers();
  void add_qualifiers(const std::string& value);
  void add_qualifiers(std::string&& value);
  void add_qualifiers(const char* value);
  void add_qualifiers(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& qualifiers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_qualifiers();

  // @@protoc_insertion_point(class_scope:hbase.pb.FirstKeyValueMatchingQualifiersFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> qualifiers_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FuzzyRowFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FuzzyRowFilter) */ {
 public:
  FuzzyRowFilter();
  virtual ~FuzzyRowFilter();

  FuzzyRowFilter(const FuzzyRowFilter& from);
  FuzzyRowFilter(FuzzyRowFilter&& from) noexcept
    : FuzzyRowFilter() {
    *this = ::std::move(from);
  }

  inline FuzzyRowFilter& operator=(const FuzzyRowFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FuzzyRowFilter& operator=(FuzzyRowFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FuzzyRowFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FuzzyRowFilter* internal_default_instance() {
    return reinterpret_cast<const FuzzyRowFilter*>(
               &_FuzzyRowFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FuzzyRowFilter& a, FuzzyRowFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FuzzyRowFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FuzzyRowFilter* New() const final {
    return CreateMaybeMessage<FuzzyRowFilter>(nullptr);
  }

  FuzzyRowFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FuzzyRowFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FuzzyRowFilter& from);
  void MergeFrom(const FuzzyRowFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FuzzyRowFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FuzzyRowFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuzzyKeysDataFieldNumber = 1,
  };
  // repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
  int fuzzy_keys_data_size() const;
  void clear_fuzzy_keys_data();
  ::hbase::pb::BytesBytesPair* mutable_fuzzy_keys_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_fuzzy_keys_data();
  const ::hbase::pb::BytesBytesPair& fuzzy_keys_data(int index) const;
  ::hbase::pb::BytesBytesPair* add_fuzzy_keys_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      fuzzy_keys_data() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.FuzzyRowFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair > fuzzy_keys_data_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class InclusiveStopFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.InclusiveStopFilter) */ {
 public:
  InclusiveStopFilter();
  virtual ~InclusiveStopFilter();

  InclusiveStopFilter(const InclusiveStopFilter& from);
  InclusiveStopFilter(InclusiveStopFilter&& from) noexcept
    : InclusiveStopFilter() {
    *this = ::std::move(from);
  }

  inline InclusiveStopFilter& operator=(const InclusiveStopFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline InclusiveStopFilter& operator=(InclusiveStopFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const InclusiveStopFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InclusiveStopFilter* internal_default_instance() {
    return reinterpret_cast<const InclusiveStopFilter*>(
               &_InclusiveStopFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(InclusiveStopFilter& a, InclusiveStopFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(InclusiveStopFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline InclusiveStopFilter* New() const final {
    return CreateMaybeMessage<InclusiveStopFilter>(nullptr);
  }

  InclusiveStopFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<InclusiveStopFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const InclusiveStopFilter& from);
  void MergeFrom(const InclusiveStopFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InclusiveStopFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.InclusiveStopFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStopRowKeyFieldNumber = 1,
  };
  // optional bytes stop_row_key = 1;
  bool has_stop_row_key() const;
  void clear_stop_row_key();
  const std::string& stop_row_key() const;
  void set_stop_row_key(const std::string& value);
  void set_stop_row_key(std::string&& value);
  void set_stop_row_key(const char* value);
  void set_stop_row_key(const void* value, size_t size);
  std::string* mutable_stop_row_key();
  std::string* release_stop_row_key();
  void set_allocated_stop_row_key(std::string* stop_row_key);

  // @@protoc_insertion_point(class_scope:hbase.pb.InclusiveStopFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_row_key_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class KeyOnlyFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.KeyOnlyFilter) */ {
 public:
  KeyOnlyFilter();
  virtual ~KeyOnlyFilter();

  KeyOnlyFilter(const KeyOnlyFilter& from);
  KeyOnlyFilter(KeyOnlyFilter&& from) noexcept
    : KeyOnlyFilter() {
    *this = ::std::move(from);
  }

  inline KeyOnlyFilter& operator=(const KeyOnlyFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyOnlyFilter& operator=(KeyOnlyFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const KeyOnlyFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyOnlyFilter* internal_default_instance() {
    return reinterpret_cast<const KeyOnlyFilter*>(
               &_KeyOnlyFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(KeyOnlyFilter& a, KeyOnlyFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyOnlyFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline KeyOnlyFilter* New() const final {
    return CreateMaybeMessage<KeyOnlyFilter>(nullptr);
  }

  KeyOnlyFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<KeyOnlyFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const KeyOnlyFilter& from);
  void MergeFrom(const KeyOnlyFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyOnlyFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.KeyOnlyFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLenAsValFieldNumber = 1,
  };
  // required bool len_as_val = 1;
  bool has_len_as_val() const;
  void clear_len_as_val();
  bool len_as_val() const;
  void set_len_as_val(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.KeyOnlyFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool len_as_val_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class MultipleColumnPrefixFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MultipleColumnPrefixFilter) */ {
 public:
  MultipleColumnPrefixFilter();
  virtual ~MultipleColumnPrefixFilter();

  MultipleColumnPrefixFilter(const MultipleColumnPrefixFilter& from);
  MultipleColumnPrefixFilter(MultipleColumnPrefixFilter&& from) noexcept
    : MultipleColumnPrefixFilter() {
    *this = ::std::move(from);
  }

  inline MultipleColumnPrefixFilter& operator=(const MultipleColumnPrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultipleColumnPrefixFilter& operator=(MultipleColumnPrefixFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultipleColumnPrefixFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultipleColumnPrefixFilter* internal_default_instance() {
    return reinterpret_cast<const MultipleColumnPrefixFilter*>(
               &_MultipleColumnPrefixFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(MultipleColumnPrefixFilter& a, MultipleColumnPrefixFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(MultipleColumnPrefixFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultipleColumnPrefixFilter* New() const final {
    return CreateMaybeMessage<MultipleColumnPrefixFilter>(nullptr);
  }

  MultipleColumnPrefixFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultipleColumnPrefixFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultipleColumnPrefixFilter& from);
  void MergeFrom(const MultipleColumnPrefixFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultipleColumnPrefixFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MultipleColumnPrefixFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSortedPrefixesFieldNumber = 1,
  };
  // repeated bytes sorted_prefixes = 1;
  int sorted_prefixes_size() const;
  void clear_sorted_prefixes();
  const std::string& sorted_prefixes(int index) const;
  std::string* mutable_sorted_prefixes(int index);
  void set_sorted_prefixes(int index, const std::string& value);
  void set_sorted_prefixes(int index, std::string&& value);
  void set_sorted_prefixes(int index, const char* value);
  void set_sorted_prefixes(int index, const void* value, size_t size);
  std::string* add_sorted_prefixes();
  void add_sorted_prefixes(const std::string& value);
  void add_sorted_prefixes(std::string&& value);
  void add_sorted_prefixes(const char* value);
  void add_sorted_prefixes(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sorted_prefixes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sorted_prefixes();

  // @@protoc_insertion_point(class_scope:hbase.pb.MultipleColumnPrefixFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sorted_prefixes_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class PageFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.PageFilter) */ {
 public:
  PageFilter();
  virtual ~PageFilter();

  PageFilter(const PageFilter& from);
  PageFilter(PageFilter&& from) noexcept
    : PageFilter() {
    *this = ::std::move(from);
  }

  inline PageFilter& operator=(const PageFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageFilter& operator=(PageFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PageFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PageFilter* internal_default_instance() {
    return reinterpret_cast<const PageFilter*>(
               &_PageFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(PageFilter& a, PageFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(PageFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PageFilter* New() const final {
    return CreateMaybeMessage<PageFilter>(nullptr);
  }

  PageFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PageFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PageFilter& from);
  void MergeFrom(const PageFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PageFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.PageFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageSizeFieldNumber = 1,
  };
  // required int64 page_size = 1;
  bool has_page_size() const;
  void clear_page_size();
  ::PROTOBUF_NAMESPACE_ID::int64 page_size() const;
  void set_page_size(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.PageFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 page_size_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class PrefixFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.PrefixFilter) */ {
 public:
  PrefixFilter();
  virtual ~PrefixFilter();

  PrefixFilter(const PrefixFilter& from);
  PrefixFilter(PrefixFilter&& from) noexcept
    : PrefixFilter() {
    *this = ::std::move(from);
  }

  inline PrefixFilter& operator=(const PrefixFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrefixFilter& operator=(PrefixFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PrefixFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PrefixFilter* internal_default_instance() {
    return reinterpret_cast<const PrefixFilter*>(
               &_PrefixFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(PrefixFilter& a, PrefixFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(PrefixFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PrefixFilter* New() const final {
    return CreateMaybeMessage<PrefixFilter>(nullptr);
  }

  PrefixFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PrefixFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PrefixFilter& from);
  void MergeFrom(const PrefixFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrefixFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.PrefixFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefixFieldNumber = 1,
  };
  // optional bytes prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  const std::string& prefix() const;
  void set_prefix(const std::string& value);
  void set_prefix(std::string&& value);
  void set_prefix(const char* value);
  void set_prefix(const void* value, size_t size);
  std::string* mutable_prefix();
  std::string* release_prefix();
  void set_allocated_prefix(std::string* prefix);

  // @@protoc_insertion_point(class_scope:hbase.pb.PrefixFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prefix_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class QualifierFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.QualifierFilter) */ {
 public:
  QualifierFilter();
  virtual ~QualifierFilter();

  QualifierFilter(const QualifierFilter& from);
  QualifierFilter(QualifierFilter&& from) noexcept
    : QualifierFilter() {
    *this = ::std::move(from);
  }

  inline QualifierFilter& operator=(const QualifierFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline QualifierFilter& operator=(QualifierFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QualifierFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QualifierFilter* internal_default_instance() {
    return reinterpret_cast<const QualifierFilter*>(
               &_QualifierFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(QualifierFilter& a, QualifierFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(QualifierFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QualifierFilter* New() const final {
    return CreateMaybeMessage<QualifierFilter>(nullptr);
  }

  QualifierFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QualifierFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QualifierFilter& from);
  void MergeFrom(const QualifierFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QualifierFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.QualifierFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompareFilterFieldNumber = 1,
  };
  // required .hbase.pb.CompareFilter compare_filter = 1;
  bool has_compare_filter() const;
  void clear_compare_filter();
  const ::hbase::pb::CompareFilter& compare_filter() const;
  ::hbase::pb::CompareFilter* release_compare_filter();
  ::hbase::pb::CompareFilter* mutable_compare_filter();
  void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.QualifierFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::CompareFilter* compare_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class RandomRowFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RandomRowFilter) */ {
 public:
  RandomRowFilter();
  virtual ~RandomRowFilter();

  RandomRowFilter(const RandomRowFilter& from);
  RandomRowFilter(RandomRowFilter&& from) noexcept
    : RandomRowFilter() {
    *this = ::std::move(from);
  }

  inline RandomRowFilter& operator=(const RandomRowFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RandomRowFilter& operator=(RandomRowFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RandomRowFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RandomRowFilter* internal_default_instance() {
    return reinterpret_cast<const RandomRowFilter*>(
               &_RandomRowFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(RandomRowFilter& a, RandomRowFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RandomRowFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RandomRowFilter* New() const final {
    return CreateMaybeMessage<RandomRowFilter>(nullptr);
  }

  RandomRowFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RandomRowFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RandomRowFilter& from);
  void MergeFrom(const RandomRowFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RandomRowFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RandomRowFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChanceFieldNumber = 1,
  };
  // required float chance = 1;
  bool has_chance() const;
  void clear_chance();
  float chance() const;
  void set_chance(float value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RandomRowFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float chance_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class RowFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RowFilter) */ {
 public:
  RowFilter();
  virtual ~RowFilter();

  RowFilter(const RowFilter& from);
  RowFilter(RowFilter&& from) noexcept
    : RowFilter() {
    *this = ::std::move(from);
  }

  inline RowFilter& operator=(const RowFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowFilter& operator=(RowFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RowFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RowFilter* internal_default_instance() {
    return reinterpret_cast<const RowFilter*>(
               &_RowFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(RowFilter& a, RowFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(RowFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RowFilter* New() const final {
    return CreateMaybeMessage<RowFilter>(nullptr);
  }

  RowFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RowFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RowFilter& from);
  void MergeFrom(const RowFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RowFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompareFilterFieldNumber = 1,
  };
  // required .hbase.pb.CompareFilter compare_filter = 1;
  bool has_compare_filter() const;
  void clear_compare_filter();
  const ::hbase::pb::CompareFilter& compare_filter() const;
  ::hbase::pb::CompareFilter* release_compare_filter();
  ::hbase::pb::CompareFilter* mutable_compare_filter();
  void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.RowFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::CompareFilter* compare_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class SingleColumnValueExcludeFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SingleColumnValueExcludeFilter) */ {
 public:
  SingleColumnValueExcludeFilter();
  virtual ~SingleColumnValueExcludeFilter();

  SingleColumnValueExcludeFilter(const SingleColumnValueExcludeFilter& from);
  SingleColumnValueExcludeFilter(SingleColumnValueExcludeFilter&& from) noexcept
    : SingleColumnValueExcludeFilter() {
    *this = ::std::move(from);
  }

  inline SingleColumnValueExcludeFilter& operator=(const SingleColumnValueExcludeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleColumnValueExcludeFilter& operator=(SingleColumnValueExcludeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SingleColumnValueExcludeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleColumnValueExcludeFilter* internal_default_instance() {
    return reinterpret_cast<const SingleColumnValueExcludeFilter*>(
               &_SingleColumnValueExcludeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(SingleColumnValueExcludeFilter& a, SingleColumnValueExcludeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleColumnValueExcludeFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleColumnValueExcludeFilter* New() const final {
    return CreateMaybeMessage<SingleColumnValueExcludeFilter>(nullptr);
  }

  SingleColumnValueExcludeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleColumnValueExcludeFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SingleColumnValueExcludeFilter& from);
  void MergeFrom(const SingleColumnValueExcludeFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleColumnValueExcludeFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SingleColumnValueExcludeFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSingleColumnValueFilterFieldNumber = 1,
  };
  // required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
  bool has_single_column_value_filter() const;
  void clear_single_column_value_filter();
  const ::hbase::pb::SingleColumnValueFilter& single_column_value_filter() const;
  ::hbase::pb::SingleColumnValueFilter* release_single_column_value_filter();
  ::hbase::pb::SingleColumnValueFilter* mutable_single_column_value_filter();
  void set_allocated_single_column_value_filter(::hbase::pb::SingleColumnValueFilter* single_column_value_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.SingleColumnValueExcludeFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::SingleColumnValueFilter* single_column_value_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class SingleColumnValueFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SingleColumnValueFilter) */ {
 public:
  SingleColumnValueFilter();
  virtual ~SingleColumnValueFilter();

  SingleColumnValueFilter(const SingleColumnValueFilter& from);
  SingleColumnValueFilter(SingleColumnValueFilter&& from) noexcept
    : SingleColumnValueFilter() {
    *this = ::std::move(from);
  }

  inline SingleColumnValueFilter& operator=(const SingleColumnValueFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SingleColumnValueFilter& operator=(SingleColumnValueFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SingleColumnValueFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleColumnValueFilter* internal_default_instance() {
    return reinterpret_cast<const SingleColumnValueFilter*>(
               &_SingleColumnValueFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(SingleColumnValueFilter& a, SingleColumnValueFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SingleColumnValueFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SingleColumnValueFilter* New() const final {
    return CreateMaybeMessage<SingleColumnValueFilter>(nullptr);
  }

  SingleColumnValueFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SingleColumnValueFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SingleColumnValueFilter& from);
  void MergeFrom(const SingleColumnValueFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleColumnValueFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SingleColumnValueFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFamilyFieldNumber = 1,
    kColumnQualifierFieldNumber = 2,
    kComparatorFieldNumber = 4,
    kCompareOpFieldNumber = 3,
    kFilterIfMissingFieldNumber = 5,
    kLatestVersionOnlyFieldNumber = 6,
  };
  // optional bytes column_family = 1;
  bool has_column_family() const;
  void clear_column_family();
  const std::string& column_family() const;
  void set_column_family(const std::string& value);
  void set_column_family(std::string&& value);
  void set_column_family(const char* value);
  void set_column_family(const void* value, size_t size);
  std::string* mutable_column_family();
  std::string* release_column_family();
  void set_allocated_column_family(std::string* column_family);

  // optional bytes column_qualifier = 2;
  bool has_column_qualifier() const;
  void clear_column_qualifier();
  const std::string& column_qualifier() const;
  void set_column_qualifier(const std::string& value);
  void set_column_qualifier(std::string&& value);
  void set_column_qualifier(const char* value);
  void set_column_qualifier(const void* value, size_t size);
  std::string* mutable_column_qualifier();
  std::string* release_column_qualifier();
  void set_allocated_column_qualifier(std::string* column_qualifier);

  // required .hbase.pb.Comparator comparator = 4;
  bool has_comparator() const;
  void clear_comparator();
  const ::hbase::pb::Comparator& comparator() const;
  ::hbase::pb::Comparator* release_comparator();
  ::hbase::pb::Comparator* mutable_comparator();
  void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // required .hbase.pb.CompareType compare_op = 3;
  bool has_compare_op() const;
  void clear_compare_op();
  ::hbase::pb::CompareType compare_op() const;
  void set_compare_op(::hbase::pb::CompareType value);

  // optional bool filter_if_missing = 5;
  bool has_filter_if_missing() const;
  void clear_filter_if_missing();
  bool filter_if_missing() const;
  void set_filter_if_missing(bool value);

  // optional bool latest_version_only = 6;
  bool has_latest_version_only() const;
  void clear_latest_version_only();
  bool latest_version_only() const;
  void set_latest_version_only(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SingleColumnValueFilter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_qualifier_;
  ::hbase::pb::Comparator* comparator_;
  int compare_op_;
  bool filter_if_missing_;
  bool latest_version_only_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class SkipFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SkipFilter) */ {
 public:
  SkipFilter();
  virtual ~SkipFilter();

  SkipFilter(const SkipFilter& from);
  SkipFilter(SkipFilter&& from) noexcept
    : SkipFilter() {
    *this = ::std::move(from);
  }

  inline SkipFilter& operator=(const SkipFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline SkipFilter& operator=(SkipFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SkipFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SkipFilter* internal_default_instance() {
    return reinterpret_cast<const SkipFilter*>(
               &_SkipFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(SkipFilter& a, SkipFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(SkipFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SkipFilter* New() const final {
    return CreateMaybeMessage<SkipFilter>(nullptr);
  }

  SkipFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SkipFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SkipFilter& from);
  void MergeFrom(const SkipFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SkipFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SkipFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // required .hbase.pb.Filter filter = 1;
  bool has_filter() const;
  void clear_filter();
  const ::hbase::pb::Filter& filter() const;
  ::hbase::pb::Filter* release_filter();
  ::hbase::pb::Filter* mutable_filter();
  void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.SkipFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Filter* filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class TimestampsFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TimestampsFilter) */ {
 public:
  TimestampsFilter();
  virtual ~TimestampsFilter();

  TimestampsFilter(const TimestampsFilter& from);
  TimestampsFilter(TimestampsFilter&& from) noexcept
    : TimestampsFilter() {
    *this = ::std::move(from);
  }

  inline TimestampsFilter& operator=(const TimestampsFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimestampsFilter& operator=(TimestampsFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimestampsFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimestampsFilter* internal_default_instance() {
    return reinterpret_cast<const TimestampsFilter*>(
               &_TimestampsFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TimestampsFilter& a, TimestampsFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(TimestampsFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimestampsFilter* New() const final {
    return CreateMaybeMessage<TimestampsFilter>(nullptr);
  }

  TimestampsFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimestampsFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimestampsFilter& from);
  void MergeFrom(const TimestampsFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimestampsFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TimestampsFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampsFieldNumber = 1,
    kCanHintFieldNumber = 2,
  };
  // repeated int64 timestamps = 1 [packed = true];
  int timestamps_size() const;
  void clear_timestamps();
  ::PROTOBUF_NAMESPACE_ID::int64 timestamps(int index) const;
  void set_timestamps(int index, ::PROTOBUF_NAMESPACE_ID::int64 value);
  void add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
      timestamps() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
      mutable_timestamps();

  // optional bool can_hint = 2;
  bool has_can_hint() const;
  void clear_can_hint();
  bool can_hint() const;
  void set_can_hint(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TimestampsFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 > timestamps_;
  mutable std::atomic<int> _timestamps_cached_byte_size_;
  bool can_hint_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ValueFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ValueFilter) */ {
 public:
  ValueFilter();
  virtual ~ValueFilter();

  ValueFilter(const ValueFilter& from);
  ValueFilter(ValueFilter&& from) noexcept
    : ValueFilter() {
    *this = ::std::move(from);
  }

  inline ValueFilter& operator=(const ValueFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValueFilter& operator=(ValueFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValueFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValueFilter* internal_default_instance() {
    return reinterpret_cast<const ValueFilter*>(
               &_ValueFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ValueFilter& a, ValueFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ValueFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValueFilter* New() const final {
    return CreateMaybeMessage<ValueFilter>(nullptr);
  }

  ValueFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValueFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValueFilter& from);
  void MergeFrom(const ValueFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValueFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ValueFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompareFilterFieldNumber = 1,
  };
  // required .hbase.pb.CompareFilter compare_filter = 1;
  bool has_compare_filter() const;
  void clear_compare_filter();
  const ::hbase::pb::CompareFilter& compare_filter() const;
  ::hbase::pb::CompareFilter* release_compare_filter();
  ::hbase::pb::CompareFilter* mutable_compare_filter();
  void set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.ValueFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::CompareFilter* compare_filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class WhileMatchFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.WhileMatchFilter) */ {
 public:
  WhileMatchFilter();
  virtual ~WhileMatchFilter();

  WhileMatchFilter(const WhileMatchFilter& from);
  WhileMatchFilter(WhileMatchFilter&& from) noexcept
    : WhileMatchFilter() {
    *this = ::std::move(from);
  }

  inline WhileMatchFilter& operator=(const WhileMatchFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline WhileMatchFilter& operator=(WhileMatchFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WhileMatchFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WhileMatchFilter* internal_default_instance() {
    return reinterpret_cast<const WhileMatchFilter*>(
               &_WhileMatchFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(WhileMatchFilter& a, WhileMatchFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(WhileMatchFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WhileMatchFilter* New() const final {
    return CreateMaybeMessage<WhileMatchFilter>(nullptr);
  }

  WhileMatchFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WhileMatchFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WhileMatchFilter& from);
  void MergeFrom(const WhileMatchFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WhileMatchFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.WhileMatchFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterFieldNumber = 1,
  };
  // required .hbase.pb.Filter filter = 1;
  bool has_filter() const;
  void clear_filter();
  const ::hbase::pb::Filter& filter() const;
  ::hbase::pb::Filter* release_filter();
  ::hbase::pb::Filter* mutable_filter();
  void set_allocated_filter(::hbase::pb::Filter* filter);

  // @@protoc_insertion_point(class_scope:hbase.pb.WhileMatchFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Filter* filter_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class FilterAllFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FilterAllFilter) */ {
 public:
  FilterAllFilter();
  virtual ~FilterAllFilter();

  FilterAllFilter(const FilterAllFilter& from);
  FilterAllFilter(FilterAllFilter&& from) noexcept
    : FilterAllFilter() {
    *this = ::std::move(from);
  }

  inline FilterAllFilter& operator=(const FilterAllFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline FilterAllFilter& operator=(FilterAllFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FilterAllFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterAllFilter* internal_default_instance() {
    return reinterpret_cast<const FilterAllFilter*>(
               &_FilterAllFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(FilterAllFilter& a, FilterAllFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(FilterAllFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FilterAllFilter* New() const final {
    return CreateMaybeMessage<FilterAllFilter>(nullptr);
  }

  FilterAllFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FilterAllFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FilterAllFilter& from);
  void MergeFrom(const FilterAllFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterAllFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FilterAllFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.FilterAllFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class RowRange :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RowRange) */ {
 public:
  RowRange();
  virtual ~RowRange();

  RowRange(const RowRange& from);
  RowRange(RowRange&& from) noexcept
    : RowRange() {
    *this = ::std::move(from);
  }

  inline RowRange& operator=(const RowRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RowRange& operator=(RowRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RowRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RowRange* internal_default_instance() {
    return reinterpret_cast<const RowRange*>(
               &_RowRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(RowRange& a, RowRange& b) {
    a.Swap(&b);
  }
  inline void Swap(RowRange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RowRange* New() const final {
    return CreateMaybeMessage<RowRange>(nullptr);
  }

  RowRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RowRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RowRange& from);
  void MergeFrom(const RowRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RowRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RowRange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartRowFieldNumber = 1,
    kStopRowFieldNumber = 3,
    kStartRowInclusiveFieldNumber = 2,
    kStopRowInclusiveFieldNumber = 4,
  };
  // optional bytes start_row = 1;
  bool has_start_row() const;
  void clear_start_row();
  const std::string& start_row() const;
  void set_start_row(const std::string& value);
  void set_start_row(std::string&& value);
  void set_start_row(const char* value);
  void set_start_row(const void* value, size_t size);
  std::string* mutable_start_row();
  std::string* release_start_row();
  void set_allocated_start_row(std::string* start_row);

  // optional bytes stop_row = 3;
  bool has_stop_row() const;
  void clear_stop_row();
  const std::string& stop_row() const;
  void set_stop_row(const std::string& value);
  void set_stop_row(std::string&& value);
  void set_stop_row(const char* value);
  void set_stop_row(const void* value, size_t size);
  std::string* mutable_stop_row();
  std::string* release_stop_row();
  void set_allocated_stop_row(std::string* stop_row);

  // optional bool start_row_inclusive = 2;
  bool has_start_row_inclusive() const;
  void clear_start_row_inclusive();
  bool start_row_inclusive() const;
  void set_start_row_inclusive(bool value);

  // optional bool stop_row_inclusive = 4;
  bool has_stop_row_inclusive() const;
  void clear_stop_row_inclusive();
  bool stop_row_inclusive() const;
  void set_stop_row_inclusive(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RowRange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_row_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stop_row_;
  bool start_row_inclusive_;
  bool stop_row_inclusive_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class MultiRowRangeFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MultiRowRangeFilter) */ {
 public:
  MultiRowRangeFilter();
  virtual ~MultiRowRangeFilter();

  MultiRowRangeFilter(const MultiRowRangeFilter& from);
  MultiRowRangeFilter(MultiRowRangeFilter&& from) noexcept
    : MultiRowRangeFilter() {
    *this = ::std::move(from);
  }

  inline MultiRowRangeFilter& operator=(const MultiRowRangeFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiRowRangeFilter& operator=(MultiRowRangeFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MultiRowRangeFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiRowRangeFilter* internal_default_instance() {
    return reinterpret_cast<const MultiRowRangeFilter*>(
               &_MultiRowRangeFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(MultiRowRangeFilter& a, MultiRowRangeFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiRowRangeFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MultiRowRangeFilter* New() const final {
    return CreateMaybeMessage<MultiRowRangeFilter>(nullptr);
  }

  MultiRowRangeFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MultiRowRangeFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MultiRowRangeFilter& from);
  void MergeFrom(const MultiRowRangeFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiRowRangeFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MultiRowRangeFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowRangeListFieldNumber = 1,
  };
  // repeated .hbase.pb.RowRange row_range_list = 1;
  int row_range_list_size() const;
  void clear_row_range_list();
  ::hbase::pb::RowRange* mutable_row_range_list(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RowRange >*
      mutable_row_range_list();
  const ::hbase::pb::RowRange& row_range_list(int index) const;
  ::hbase::pb::RowRange* add_row_range_list();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RowRange >&
      row_range_list() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.MultiRowRangeFilter)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RowRange > row_range_list_;
  friend struct ::TableStruct_Filter_2eproto;
};
// -------------------------------------------------------------------

class ColumnValueFilter :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnValueFilter) */ {
 public:
  ColumnValueFilter();
  virtual ~ColumnValueFilter();

  ColumnValueFilter(const ColumnValueFilter& from);
  ColumnValueFilter(ColumnValueFilter&& from) noexcept
    : ColumnValueFilter() {
    *this = ::std::move(from);
  }

  inline ColumnValueFilter& operator=(const ColumnValueFilter& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnValueFilter& operator=(ColumnValueFilter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnValueFilter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnValueFilter* internal_default_instance() {
    return reinterpret_cast<const ColumnValueFilter*>(
               &_ColumnValueFilter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ColumnValueFilter& a, ColumnValueFilter& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnValueFilter* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnValueFilter* New() const final {
    return CreateMaybeMessage<ColumnValueFilter>(nullptr);
  }

  ColumnValueFilter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnValueFilter>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnValueFilter& from);
  void MergeFrom(const ColumnValueFilter& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnValueFilter* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnValueFilter";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Filter_2eproto);
    return ::descriptor_table_Filter_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kQualifierFieldNumber = 2,
    kComparatorFieldNumber = 4,
    kCompareOpFieldNumber = 3,
  };
  // required bytes family = 1;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // required bytes qualifier = 2;
  bool has_qualifier() const;
  void clear_qualifier();
  const std::string& qualifier() const;
  void set_qualifier(const std::string& value);
  void set_qualifier(std::string&& value);
  void set_qualifier(const char* value);
  void set_qualifier(const void* value, size_t size);
  std::string* mutable_qualifier();
  std::string* release_qualifier();
  void set_allocated_qualifier(std::string* qualifier);

  // required .hbase.pb.Comparator comparator = 4;
  bool has_comparator() const;
  void clear_comparator();
  const ::hbase::pb::Comparator& comparator() const;
  ::hbase::pb::Comparator* release_comparator();
  ::hbase::pb::Comparator* mutable_comparator();
  void set_allocated_comparator(::hbase::pb::Comparator* comparator);

  // required .hbase.pb.CompareType compare_op = 3;
  bool has_compare_op() const;
  void clear_compare_op();
  ::hbase::pb::CompareType compare_op() const;
  void set_compare_op(::hbase::pb::CompareType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnValueFilter)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualifier_;
  ::hbase::pb::Comparator* comparator_;
  int compare_op_;
  friend struct ::TableStruct_Filter_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Filter

// required string name = 1;
inline bool Filter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Filter::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Filter::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Filter.name)
  return name_.GetNoArena();
}
inline void Filter::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Filter.name)
}
inline void Filter::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Filter.name)
}
inline void Filter::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Filter.name)
}
inline void Filter::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Filter.name)
}
inline std::string* Filter::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Filter.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Filter::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.Filter.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Filter::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Filter.name)
}

// optional bytes serialized_filter = 2;
inline bool Filter::has_serialized_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Filter::clear_serialized_filter() {
  serialized_filter_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Filter::serialized_filter() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Filter.serialized_filter)
  return serialized_filter_.GetNoArena();
}
inline void Filter::set_serialized_filter(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_filter_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Filter.serialized_filter)
}
inline void Filter::set_serialized_filter(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  serialized_filter_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Filter.serialized_filter)
}
inline void Filter::set_serialized_filter(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  serialized_filter_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Filter.serialized_filter)
}
inline void Filter::set_serialized_filter(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  serialized_filter_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Filter.serialized_filter)
}
inline std::string* Filter::mutable_serialized_filter() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Filter.serialized_filter)
  return serialized_filter_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Filter::release_serialized_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.Filter.serialized_filter)
  if (!has_serialized_filter()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return serialized_filter_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Filter::set_allocated_serialized_filter(std::string* serialized_filter) {
  if (serialized_filter != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  serialized_filter_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serialized_filter);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Filter.serialized_filter)
}

// -------------------------------------------------------------------

// ColumnCountGetFilter

// required int32 limit = 1;
inline bool ColumnCountGetFilter::has_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnCountGetFilter::clear_limit() {
  limit_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnCountGetFilter::limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnCountGetFilter.limit)
  return limit_;
}
inline void ColumnCountGetFilter::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnCountGetFilter.limit)
}

// -------------------------------------------------------------------

// ColumnPaginationFilter

// required int32 limit = 1;
inline bool ColumnPaginationFilter::has_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnPaginationFilter::clear_limit() {
  limit_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnPaginationFilter::limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnPaginationFilter.limit)
  return limit_;
}
inline void ColumnPaginationFilter::set_limit(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnPaginationFilter.limit)
}

// optional int32 offset = 2;
inline bool ColumnPaginationFilter::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnPaginationFilter::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ColumnPaginationFilter::offset() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnPaginationFilter.offset)
  return offset_;
}
inline void ColumnPaginationFilter::set_offset(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnPaginationFilter.offset)
}

// optional bytes column_offset = 3;
inline bool ColumnPaginationFilter::has_column_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnPaginationFilter::clear_column_offset() {
  column_offset_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnPaginationFilter::column_offset() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnPaginationFilter.column_offset)
  return column_offset_.GetNoArena();
}
inline void ColumnPaginationFilter::set_column_offset(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  column_offset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnPaginationFilter.column_offset)
}
inline void ColumnPaginationFilter::set_column_offset(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  column_offset_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnPaginationFilter.column_offset)
}
inline void ColumnPaginationFilter::set_column_offset(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  column_offset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnPaginationFilter.column_offset)
}
inline void ColumnPaginationFilter::set_column_offset(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  column_offset_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnPaginationFilter.column_offset)
}
inline std::string* ColumnPaginationFilter::mutable_column_offset() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnPaginationFilter.column_offset)
  return column_offset_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnPaginationFilter::release_column_offset() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnPaginationFilter.column_offset)
  if (!has_column_offset()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return column_offset_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnPaginationFilter::set_allocated_column_offset(std::string* column_offset) {
  if (column_offset != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  column_offset_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_offset);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnPaginationFilter.column_offset)
}

// -------------------------------------------------------------------

// ColumnPrefixFilter

// required bytes prefix = 1;
inline bool ColumnPrefixFilter::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnPrefixFilter::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnPrefixFilter::prefix() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnPrefixFilter.prefix)
  return prefix_.GetNoArena();
}
inline void ColumnPrefixFilter::set_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnPrefixFilter.prefix)
}
inline void ColumnPrefixFilter::set_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnPrefixFilter.prefix)
}
inline void ColumnPrefixFilter::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnPrefixFilter.prefix)
}
inline void ColumnPrefixFilter::set_prefix(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnPrefixFilter.prefix)
}
inline std::string* ColumnPrefixFilter::mutable_prefix() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnPrefixFilter.prefix)
  return prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnPrefixFilter::release_prefix() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnPrefixFilter.prefix)
  if (!has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnPrefixFilter::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnPrefixFilter.prefix)
}

// -------------------------------------------------------------------

// ColumnRangeFilter

// optional bytes min_column = 1;
inline bool ColumnRangeFilter::has_min_column() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnRangeFilter::clear_min_column() {
  min_column_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnRangeFilter::min_column() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnRangeFilter.min_column)
  return min_column_.GetNoArena();
}
inline void ColumnRangeFilter::set_min_column(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  min_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnRangeFilter.min_column)
}
inline void ColumnRangeFilter::set_min_column(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  min_column_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnRangeFilter.min_column)
}
inline void ColumnRangeFilter::set_min_column(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  min_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnRangeFilter.min_column)
}
inline void ColumnRangeFilter::set_min_column(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  min_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnRangeFilter.min_column)
}
inline std::string* ColumnRangeFilter::mutable_min_column() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnRangeFilter.min_column)
  return min_column_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnRangeFilter::release_min_column() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnRangeFilter.min_column)
  if (!has_min_column()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return min_column_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnRangeFilter::set_allocated_min_column(std::string* min_column) {
  if (min_column != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  min_column_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), min_column);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnRangeFilter.min_column)
}

// optional bool min_column_inclusive = 2;
inline bool ColumnRangeFilter::has_min_column_inclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnRangeFilter::clear_min_column_inclusive() {
  min_column_inclusive_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ColumnRangeFilter::min_column_inclusive() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnRangeFilter.min_column_inclusive)
  return min_column_inclusive_;
}
inline void ColumnRangeFilter::set_min_column_inclusive(bool value) {
  _has_bits_[0] |= 0x00000004u;
  min_column_inclusive_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnRangeFilter.min_column_inclusive)
}

// optional bytes max_column = 3;
inline bool ColumnRangeFilter::has_max_column() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnRangeFilter::clear_max_column() {
  max_column_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnRangeFilter::max_column() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnRangeFilter.max_column)
  return max_column_.GetNoArena();
}
inline void ColumnRangeFilter::set_max_column(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  max_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnRangeFilter.max_column)
}
inline void ColumnRangeFilter::set_max_column(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  max_column_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnRangeFilter.max_column)
}
inline void ColumnRangeFilter::set_max_column(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  max_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnRangeFilter.max_column)
}
inline void ColumnRangeFilter::set_max_column(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  max_column_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnRangeFilter.max_column)
}
inline std::string* ColumnRangeFilter::mutable_max_column() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnRangeFilter.max_column)
  return max_column_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnRangeFilter::release_max_column() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnRangeFilter.max_column)
  if (!has_max_column()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return max_column_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnRangeFilter::set_allocated_max_column(std::string* max_column) {
  if (max_column != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  max_column_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), max_column);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnRangeFilter.max_column)
}

// optional bool max_column_inclusive = 4;
inline bool ColumnRangeFilter::has_max_column_inclusive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnRangeFilter::clear_max_column_inclusive() {
  max_column_inclusive_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ColumnRangeFilter::max_column_inclusive() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnRangeFilter.max_column_inclusive)
  return max_column_inclusive_;
}
inline void ColumnRangeFilter::set_max_column_inclusive(bool value) {
  _has_bits_[0] |= 0x00000008u;
  max_column_inclusive_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnRangeFilter.max_column_inclusive)
}

// -------------------------------------------------------------------

// CompareFilter

// required .hbase.pb.CompareType compare_op = 1;
inline bool CompareFilter::has_compare_op() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompareFilter::clear_compare_op() {
  compare_op_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::CompareType CompareFilter::compare_op() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompareFilter.compare_op)
  return static_cast< ::hbase::pb::CompareType >(compare_op_);
}
inline void CompareFilter::set_compare_op(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  compare_op_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.CompareFilter.compare_op)
}

// optional .hbase.pb.Comparator comparator = 2;
inline bool CompareFilter::has_comparator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::Comparator& CompareFilter::comparator() const {
  const ::hbase::pb::Comparator* p = comparator_;
  // @@protoc_insertion_point(field_get:hbase.pb.CompareFilter.comparator)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Comparator*>(
      &::hbase::pb::_Comparator_default_instance_);
}
inline ::hbase::pb::Comparator* CompareFilter::release_comparator() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompareFilter.comparator)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = nullptr;
  return temp;
}
inline ::hbase::pb::Comparator* CompareFilter::mutable_comparator() {
  _has_bits_[0] |= 0x00000001u;
  if (comparator_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Comparator>(GetArenaNoVirtual());
    comparator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompareFilter.comparator)
  return comparator_;
}
inline void CompareFilter::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(comparator_);
  }
  if (comparator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      comparator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  comparator_ = comparator;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompareFilter.comparator)
}

// -------------------------------------------------------------------

// DependentColumnFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool DependentColumnFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DependentColumnFilter::clear_compare_filter() {
  if (compare_filter_ != nullptr) compare_filter_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::CompareFilter& DependentColumnFilter::compare_filter() const {
  const ::hbase::pb::CompareFilter* p = compare_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.DependentColumnFilter.compare_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CompareFilter*>(
      &::hbase::pb::_CompareFilter_default_instance_);
}
inline ::hbase::pb::CompareFilter* DependentColumnFilter::release_compare_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.DependentColumnFilter.compare_filter)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::CompareFilter* DependentColumnFilter::mutable_compare_filter() {
  _has_bits_[0] |= 0x00000004u;
  if (compare_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CompareFilter>(GetArenaNoVirtual());
    compare_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.DependentColumnFilter.compare_filter)
  return compare_filter_;
}
inline void DependentColumnFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete compare_filter_;
  }
  if (compare_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compare_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compare_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  compare_filter_ = compare_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DependentColumnFilter.compare_filter)
}

// optional bytes column_family = 2;
inline bool DependentColumnFilter::has_column_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DependentColumnFilter::clear_column_family() {
  column_family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DependentColumnFilter::column_family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DependentColumnFilter.column_family)
  return column_family_.GetNoArena();
}
inline void DependentColumnFilter::set_column_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DependentColumnFilter.column_family)
}
inline void DependentColumnFilter::set_column_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DependentColumnFilter.column_family)
}
inline void DependentColumnFilter::set_column_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DependentColumnFilter.column_family)
}
inline void DependentColumnFilter::set_column_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DependentColumnFilter.column_family)
}
inline std::string* DependentColumnFilter::mutable_column_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DependentColumnFilter.column_family)
  return column_family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DependentColumnFilter::release_column_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.DependentColumnFilter.column_family)
  if (!has_column_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return column_family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DependentColumnFilter::set_allocated_column_family(std::string* column_family) {
  if (column_family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  column_family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DependentColumnFilter.column_family)
}

// optional bytes column_qualifier = 3;
inline bool DependentColumnFilter::has_column_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DependentColumnFilter::clear_column_qualifier() {
  column_qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DependentColumnFilter::column_qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DependentColumnFilter.column_qualifier)
  return column_qualifier_.GetNoArena();
}
inline void DependentColumnFilter::set_column_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.DependentColumnFilter.column_qualifier)
}
inline void DependentColumnFilter::set_column_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.DependentColumnFilter.column_qualifier)
}
inline void DependentColumnFilter::set_column_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.DependentColumnFilter.column_qualifier)
}
inline void DependentColumnFilter::set_column_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.DependentColumnFilter.column_qualifier)
}
inline std::string* DependentColumnFilter::mutable_column_qualifier() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.DependentColumnFilter.column_qualifier)
  return column_qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* DependentColumnFilter::release_column_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.DependentColumnFilter.column_qualifier)
  if (!has_column_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return column_qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void DependentColumnFilter::set_allocated_column_qualifier(std::string* column_qualifier) {
  if (column_qualifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  column_qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.DependentColumnFilter.column_qualifier)
}

// optional bool drop_dependent_column = 4;
inline bool DependentColumnFilter::has_drop_dependent_column() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DependentColumnFilter::clear_drop_dependent_column() {
  drop_dependent_column_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool DependentColumnFilter::drop_dependent_column() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DependentColumnFilter.drop_dependent_column)
  return drop_dependent_column_;
}
inline void DependentColumnFilter::set_drop_dependent_column(bool value) {
  _has_bits_[0] |= 0x00000008u;
  drop_dependent_column_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.DependentColumnFilter.drop_dependent_column)
}

// -------------------------------------------------------------------

// FamilyFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool FamilyFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FamilyFilter::clear_compare_filter() {
  if (compare_filter_ != nullptr) compare_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::CompareFilter& FamilyFilter::compare_filter() const {
  const ::hbase::pb::CompareFilter* p = compare_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.FamilyFilter.compare_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CompareFilter*>(
      &::hbase::pb::_CompareFilter_default_instance_);
}
inline ::hbase::pb::CompareFilter* FamilyFilter::release_compare_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.FamilyFilter.compare_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::CompareFilter* FamilyFilter::mutable_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (compare_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CompareFilter>(GetArenaNoVirtual());
    compare_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.FamilyFilter.compare_filter)
  return compare_filter_;
}
inline void FamilyFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete compare_filter_;
  }
  if (compare_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compare_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compare_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  compare_filter_ = compare_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FamilyFilter.compare_filter)
}

// -------------------------------------------------------------------

// FilterList

// required .hbase.pb.FilterList.Operator operator = 1;
inline bool FilterList::has_operator_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterList::clear_operator_() {
  operator__ = 1;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::hbase::pb::FilterList_Operator FilterList::operator_() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FilterList.operator)
  return static_cast< ::hbase::pb::FilterList_Operator >(operator__);
}
inline void FilterList::set_operator_(::hbase::pb::FilterList_Operator value) {
  assert(::hbase::pb::FilterList_Operator_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  operator__ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.FilterList.operator)
}

// repeated .hbase.pb.Filter filters = 2;
inline int FilterList::filters_size() const {
  return filters_.size();
}
inline void FilterList::clear_filters() {
  filters_.Clear();
}
inline ::hbase::pb::Filter* FilterList::mutable_filters(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FilterList.filters)
  return filters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Filter >*
FilterList::mutable_filters() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FilterList.filters)
  return &filters_;
}
inline const ::hbase::pb::Filter& FilterList::filters(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FilterList.filters)
  return filters_.Get(index);
}
inline ::hbase::pb::Filter* FilterList::add_filters() {
  // @@protoc_insertion_point(field_add:hbase.pb.FilterList.filters)
  return filters_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::Filter >&
FilterList::filters() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FilterList.filters)
  return filters_;
}

// -------------------------------------------------------------------

// FilterWrapper

// required .hbase.pb.Filter filter = 1;
inline bool FilterWrapper::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterWrapper::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Filter& FilterWrapper::filter() const {
  const ::hbase::pb::Filter* p = filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.FilterWrapper.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Filter*>(
      &::hbase::pb::_Filter_default_instance_);
}
inline ::hbase::pb::Filter* FilterWrapper::release_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.FilterWrapper.filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::Filter* FilterWrapper::mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Filter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.FilterWrapper.filter)
  return filter_;
}
inline void FilterWrapper::set_allocated_filter(::hbase::pb::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FilterWrapper.filter)
}

// -------------------------------------------------------------------

// FirstKeyOnlyFilter

// -------------------------------------------------------------------

// FirstKeyValueMatchingQualifiersFilter

// repeated bytes qualifiers = 1;
inline int FirstKeyValueMatchingQualifiersFilter::qualifiers_size() const {
  return qualifiers_.size();
}
inline void FirstKeyValueMatchingQualifiersFilter::clear_qualifiers() {
  qualifiers_.Clear();
}
inline const std::string& FirstKeyValueMatchingQualifiersFilter::qualifiers(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  return qualifiers_.Get(index);
}
inline std::string* FirstKeyValueMatchingQualifiersFilter::mutable_qualifiers(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  return qualifiers_.Mutable(index);
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  qualifiers_.Mutable(index)->assign(value);
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  qualifiers_.Mutable(index)->assign(std::move(value));
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qualifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline void FirstKeyValueMatchingQualifiersFilter::set_qualifiers(int index, const void* value, size_t size) {
  qualifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline std::string* FirstKeyValueMatchingQualifiersFilter::add_qualifiers() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  return qualifiers_.Add();
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const std::string& value) {
  qualifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(std::string&& value) {
  qualifiers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  qualifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline void FirstKeyValueMatchingQualifiersFilter::add_qualifiers(const void* value, size_t size) {
  qualifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FirstKeyValueMatchingQualifiersFilter::qualifiers() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  return qualifiers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FirstKeyValueMatchingQualifiersFilter::mutable_qualifiers() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FirstKeyValueMatchingQualifiersFilter.qualifiers)
  return &qualifiers_;
}

// -------------------------------------------------------------------

// FuzzyRowFilter

// repeated .hbase.pb.BytesBytesPair fuzzy_keys_data = 1;
inline int FuzzyRowFilter::fuzzy_keys_data_size() const {
  return fuzzy_keys_data_.size();
}
inline ::hbase::pb::BytesBytesPair* FuzzyRowFilter::mutable_fuzzy_keys_data(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FuzzyRowFilter.fuzzy_keys_data)
  return fuzzy_keys_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
FuzzyRowFilter::mutable_fuzzy_keys_data() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FuzzyRowFilter.fuzzy_keys_data)
  return &fuzzy_keys_data_;
}
inline const ::hbase::pb::BytesBytesPair& FuzzyRowFilter::fuzzy_keys_data(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FuzzyRowFilter.fuzzy_keys_data)
  return fuzzy_keys_data_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* FuzzyRowFilter::add_fuzzy_keys_data() {
  // @@protoc_insertion_point(field_add:hbase.pb.FuzzyRowFilter.fuzzy_keys_data)
  return fuzzy_keys_data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
FuzzyRowFilter::fuzzy_keys_data() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FuzzyRowFilter.fuzzy_keys_data)
  return fuzzy_keys_data_;
}

// -------------------------------------------------------------------

// InclusiveStopFilter

// optional bytes stop_row_key = 1;
inline bool InclusiveStopFilter::has_stop_row_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InclusiveStopFilter::clear_stop_row_key() {
  stop_row_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InclusiveStopFilter::stop_row_key() const {
  // @@protoc_insertion_point(field_get:hbase.pb.InclusiveStopFilter.stop_row_key)
  return stop_row_key_.GetNoArena();
}
inline void InclusiveStopFilter::set_stop_row_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  stop_row_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.InclusiveStopFilter.stop_row_key)
}
inline void InclusiveStopFilter::set_stop_row_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  stop_row_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.InclusiveStopFilter.stop_row_key)
}
inline void InclusiveStopFilter::set_stop_row_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  stop_row_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.InclusiveStopFilter.stop_row_key)
}
inline void InclusiveStopFilter::set_stop_row_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  stop_row_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.InclusiveStopFilter.stop_row_key)
}
inline std::string* InclusiveStopFilter::mutable_stop_row_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.InclusiveStopFilter.stop_row_key)
  return stop_row_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* InclusiveStopFilter::release_stop_row_key() {
  // @@protoc_insertion_point(field_release:hbase.pb.InclusiveStopFilter.stop_row_key)
  if (!has_stop_row_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return stop_row_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void InclusiveStopFilter::set_allocated_stop_row_key(std::string* stop_row_key) {
  if (stop_row_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  stop_row_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stop_row_key);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.InclusiveStopFilter.stop_row_key)
}

// -------------------------------------------------------------------

// KeyOnlyFilter

// required bool len_as_val = 1;
inline bool KeyOnlyFilter::has_len_as_val() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyOnlyFilter::clear_len_as_val() {
  len_as_val_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool KeyOnlyFilter::len_as_val() const {
  // @@protoc_insertion_point(field_get:hbase.pb.KeyOnlyFilter.len_as_val)
  return len_as_val_;
}
inline void KeyOnlyFilter::set_len_as_val(bool value) {
  _has_bits_[0] |= 0x00000001u;
  len_as_val_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.KeyOnlyFilter.len_as_val)
}

// -------------------------------------------------------------------

// MultipleColumnPrefixFilter

// repeated bytes sorted_prefixes = 1;
inline int MultipleColumnPrefixFilter::sorted_prefixes_size() const {
  return sorted_prefixes_.size();
}
inline void MultipleColumnPrefixFilter::clear_sorted_prefixes() {
  sorted_prefixes_.Clear();
}
inline const std::string& MultipleColumnPrefixFilter::sorted_prefixes(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  return sorted_prefixes_.Get(index);
}
inline std::string* MultipleColumnPrefixFilter::mutable_sorted_prefixes(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  return sorted_prefixes_.Mutable(index);
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  sorted_prefixes_.Mutable(index)->assign(value);
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  sorted_prefixes_.Mutable(index)->assign(std::move(value));
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sorted_prefixes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline void MultipleColumnPrefixFilter::set_sorted_prefixes(int index, const void* value, size_t size) {
  sorted_prefixes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline std::string* MultipleColumnPrefixFilter::add_sorted_prefixes() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  return sorted_prefixes_.Add();
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const std::string& value) {
  sorted_prefixes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(std::string&& value) {
  sorted_prefixes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sorted_prefixes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline void MultipleColumnPrefixFilter::add_sorted_prefixes(const void* value, size_t size) {
  sorted_prefixes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MultipleColumnPrefixFilter::sorted_prefixes() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  return sorted_prefixes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MultipleColumnPrefixFilter::mutable_sorted_prefixes() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultipleColumnPrefixFilter.sorted_prefixes)
  return &sorted_prefixes_;
}

// -------------------------------------------------------------------

// PageFilter

// required int64 page_size = 1;
inline bool PageFilter::has_page_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageFilter::clear_page_size() {
  page_size_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 PageFilter::page_size() const {
  // @@protoc_insertion_point(field_get:hbase.pb.PageFilter.page_size)
  return page_size_;
}
inline void PageFilter::set_page_size(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  page_size_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.PageFilter.page_size)
}

// -------------------------------------------------------------------

// PrefixFilter

// optional bytes prefix = 1;
inline bool PrefixFilter::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrefixFilter::clear_prefix() {
  prefix_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PrefixFilter::prefix() const {
  // @@protoc_insertion_point(field_get:hbase.pb.PrefixFilter.prefix)
  return prefix_.GetNoArena();
}
inline void PrefixFilter::set_prefix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.PrefixFilter.prefix)
}
inline void PrefixFilter::set_prefix(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.PrefixFilter.prefix)
}
inline void PrefixFilter::set_prefix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.PrefixFilter.prefix)
}
inline void PrefixFilter::set_prefix(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  prefix_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.PrefixFilter.prefix)
}
inline std::string* PrefixFilter::mutable_prefix() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.PrefixFilter.prefix)
  return prefix_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* PrefixFilter::release_prefix() {
  // @@protoc_insertion_point(field_release:hbase.pb.PrefixFilter.prefix)
  if (!has_prefix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return prefix_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void PrefixFilter::set_allocated_prefix(std::string* prefix) {
  if (prefix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  prefix_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), prefix);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.PrefixFilter.prefix)
}

// -------------------------------------------------------------------

// QualifierFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool QualifierFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QualifierFilter::clear_compare_filter() {
  if (compare_filter_ != nullptr) compare_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::CompareFilter& QualifierFilter::compare_filter() const {
  const ::hbase::pb::CompareFilter* p = compare_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.QualifierFilter.compare_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CompareFilter*>(
      &::hbase::pb::_CompareFilter_default_instance_);
}
inline ::hbase::pb::CompareFilter* QualifierFilter::release_compare_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.QualifierFilter.compare_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::CompareFilter* QualifierFilter::mutable_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (compare_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CompareFilter>(GetArenaNoVirtual());
    compare_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.QualifierFilter.compare_filter)
  return compare_filter_;
}
inline void QualifierFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete compare_filter_;
  }
  if (compare_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compare_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compare_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  compare_filter_ = compare_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.QualifierFilter.compare_filter)
}

// -------------------------------------------------------------------

// RandomRowFilter

// required float chance = 1;
inline bool RandomRowFilter::has_chance() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RandomRowFilter::clear_chance() {
  chance_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float RandomRowFilter::chance() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RandomRowFilter.chance)
  return chance_;
}
inline void RandomRowFilter::set_chance(float value) {
  _has_bits_[0] |= 0x00000001u;
  chance_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RandomRowFilter.chance)
}

// -------------------------------------------------------------------

// RowFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool RowFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowFilter::clear_compare_filter() {
  if (compare_filter_ != nullptr) compare_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::CompareFilter& RowFilter::compare_filter() const {
  const ::hbase::pb::CompareFilter* p = compare_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.RowFilter.compare_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CompareFilter*>(
      &::hbase::pb::_CompareFilter_default_instance_);
}
inline ::hbase::pb::CompareFilter* RowFilter::release_compare_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.RowFilter.compare_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::CompareFilter* RowFilter::mutable_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (compare_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CompareFilter>(GetArenaNoVirtual());
    compare_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RowFilter.compare_filter)
  return compare_filter_;
}
inline void RowFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete compare_filter_;
  }
  if (compare_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compare_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compare_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  compare_filter_ = compare_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RowFilter.compare_filter)
}

// -------------------------------------------------------------------

// SingleColumnValueExcludeFilter

// required .hbase.pb.SingleColumnValueFilter single_column_value_filter = 1;
inline bool SingleColumnValueExcludeFilter::has_single_column_value_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleColumnValueExcludeFilter::clear_single_column_value_filter() {
  if (single_column_value_filter_ != nullptr) single_column_value_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::SingleColumnValueFilter& SingleColumnValueExcludeFilter::single_column_value_filter() const {
  const ::hbase::pb::SingleColumnValueFilter* p = single_column_value_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueExcludeFilter.single_column_value_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::SingleColumnValueFilter*>(
      &::hbase::pb::_SingleColumnValueFilter_default_instance_);
}
inline ::hbase::pb::SingleColumnValueFilter* SingleColumnValueExcludeFilter::release_single_column_value_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.SingleColumnValueExcludeFilter.single_column_value_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::SingleColumnValueFilter* temp = single_column_value_filter_;
  single_column_value_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::SingleColumnValueFilter* SingleColumnValueExcludeFilter::mutable_single_column_value_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (single_column_value_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::SingleColumnValueFilter>(GetArenaNoVirtual());
    single_column_value_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SingleColumnValueExcludeFilter.single_column_value_filter)
  return single_column_value_filter_;
}
inline void SingleColumnValueExcludeFilter::set_allocated_single_column_value_filter(::hbase::pb::SingleColumnValueFilter* single_column_value_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete single_column_value_filter_;
  }
  if (single_column_value_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      single_column_value_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, single_column_value_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  single_column_value_filter_ = single_column_value_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SingleColumnValueExcludeFilter.single_column_value_filter)
}

// -------------------------------------------------------------------

// SingleColumnValueFilter

// optional bytes column_family = 1;
inline bool SingleColumnValueFilter::has_column_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleColumnValueFilter::clear_column_family() {
  column_family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SingleColumnValueFilter::column_family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.column_family)
  return column_family_.GetNoArena();
}
inline void SingleColumnValueFilter::set_column_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.SingleColumnValueFilter.column_family)
}
inline void SingleColumnValueFilter::set_column_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.SingleColumnValueFilter.column_family)
}
inline void SingleColumnValueFilter::set_column_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.SingleColumnValueFilter.column_family)
}
inline void SingleColumnValueFilter::set_column_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.SingleColumnValueFilter.column_family)
}
inline std::string* SingleColumnValueFilter::mutable_column_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.SingleColumnValueFilter.column_family)
  return column_family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SingleColumnValueFilter::release_column_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.SingleColumnValueFilter.column_family)
  if (!has_column_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return column_family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SingleColumnValueFilter::set_allocated_column_family(std::string* column_family) {
  if (column_family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  column_family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SingleColumnValueFilter.column_family)
}

// optional bytes column_qualifier = 2;
inline bool SingleColumnValueFilter::has_column_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleColumnValueFilter::clear_column_qualifier() {
  column_qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SingleColumnValueFilter::column_qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.column_qualifier)
  return column_qualifier_.GetNoArena();
}
inline void SingleColumnValueFilter::set_column_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.SingleColumnValueFilter.column_qualifier)
}
inline void SingleColumnValueFilter::set_column_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.SingleColumnValueFilter.column_qualifier)
}
inline void SingleColumnValueFilter::set_column_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.SingleColumnValueFilter.column_qualifier)
}
inline void SingleColumnValueFilter::set_column_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  column_qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.SingleColumnValueFilter.column_qualifier)
}
inline std::string* SingleColumnValueFilter::mutable_column_qualifier() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.SingleColumnValueFilter.column_qualifier)
  return column_qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SingleColumnValueFilter::release_column_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.SingleColumnValueFilter.column_qualifier)
  if (!has_column_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return column_qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SingleColumnValueFilter::set_allocated_column_qualifier(std::string* column_qualifier) {
  if (column_qualifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  column_qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SingleColumnValueFilter.column_qualifier)
}

// required .hbase.pb.CompareType compare_op = 3;
inline bool SingleColumnValueFilter::has_compare_op() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleColumnValueFilter::clear_compare_op() {
  compare_op_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hbase::pb::CompareType SingleColumnValueFilter::compare_op() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.compare_op)
  return static_cast< ::hbase::pb::CompareType >(compare_op_);
}
inline void SingleColumnValueFilter::set_compare_op(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  compare_op_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SingleColumnValueFilter.compare_op)
}

// required .hbase.pb.Comparator comparator = 4;
inline bool SingleColumnValueFilter::has_comparator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::Comparator& SingleColumnValueFilter::comparator() const {
  const ::hbase::pb::Comparator* p = comparator_;
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.comparator)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Comparator*>(
      &::hbase::pb::_Comparator_default_instance_);
}
inline ::hbase::pb::Comparator* SingleColumnValueFilter::release_comparator() {
  // @@protoc_insertion_point(field_release:hbase.pb.SingleColumnValueFilter.comparator)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = nullptr;
  return temp;
}
inline ::hbase::pb::Comparator* SingleColumnValueFilter::mutable_comparator() {
  _has_bits_[0] |= 0x00000004u;
  if (comparator_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Comparator>(GetArenaNoVirtual());
    comparator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SingleColumnValueFilter.comparator)
  return comparator_;
}
inline void SingleColumnValueFilter::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(comparator_);
  }
  if (comparator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      comparator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  comparator_ = comparator;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SingleColumnValueFilter.comparator)
}

// optional bool filter_if_missing = 5;
inline bool SingleColumnValueFilter::has_filter_if_missing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleColumnValueFilter::clear_filter_if_missing() {
  filter_if_missing_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SingleColumnValueFilter::filter_if_missing() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.filter_if_missing)
  return filter_if_missing_;
}
inline void SingleColumnValueFilter::set_filter_if_missing(bool value) {
  _has_bits_[0] |= 0x00000010u;
  filter_if_missing_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SingleColumnValueFilter.filter_if_missing)
}

// optional bool latest_version_only = 6;
inline bool SingleColumnValueFilter::has_latest_version_only() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleColumnValueFilter::clear_latest_version_only() {
  latest_version_only_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool SingleColumnValueFilter::latest_version_only() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SingleColumnValueFilter.latest_version_only)
  return latest_version_only_;
}
inline void SingleColumnValueFilter::set_latest_version_only(bool value) {
  _has_bits_[0] |= 0x00000020u;
  latest_version_only_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SingleColumnValueFilter.latest_version_only)
}

// -------------------------------------------------------------------

// SkipFilter

// required .hbase.pb.Filter filter = 1;
inline bool SkipFilter::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkipFilter::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Filter& SkipFilter::filter() const {
  const ::hbase::pb::Filter* p = filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.SkipFilter.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Filter*>(
      &::hbase::pb::_Filter_default_instance_);
}
inline ::hbase::pb::Filter* SkipFilter::release_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.SkipFilter.filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::Filter* SkipFilter::mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Filter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SkipFilter.filter)
  return filter_;
}
inline void SkipFilter::set_allocated_filter(::hbase::pb::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SkipFilter.filter)
}

// -------------------------------------------------------------------

// TimestampsFilter

// repeated int64 timestamps = 1 [packed = true];
inline int TimestampsFilter::timestamps_size() const {
  return timestamps_.size();
}
inline void TimestampsFilter::clear_timestamps() {
  timestamps_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::int64 TimestampsFilter::timestamps(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimestampsFilter.timestamps)
  return timestamps_.Get(index);
}
inline void TimestampsFilter::set_timestamps(int index, ::PROTOBUF_NAMESPACE_ID::int64 value) {
  timestamps_.Set(index, value);
  // @@protoc_insertion_point(field_set:hbase.pb.TimestampsFilter.timestamps)
}
inline void TimestampsFilter::add_timestamps(::PROTOBUF_NAMESPACE_ID::int64 value) {
  timestamps_.Add(value);
  // @@protoc_insertion_point(field_add:hbase.pb.TimestampsFilter.timestamps)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >&
TimestampsFilter::timestamps() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TimestampsFilter.timestamps)
  return timestamps_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::int64 >*
TimestampsFilter::mutable_timestamps() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TimestampsFilter.timestamps)
  return &timestamps_;
}

// optional bool can_hint = 2;
inline bool TimestampsFilter::has_can_hint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimestampsFilter::clear_can_hint() {
  can_hint_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool TimestampsFilter::can_hint() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimestampsFilter.can_hint)
  return can_hint_;
}
inline void TimestampsFilter::set_can_hint(bool value) {
  _has_bits_[0] |= 0x00000001u;
  can_hint_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimestampsFilter.can_hint)
}

// -------------------------------------------------------------------

// ValueFilter

// required .hbase.pb.CompareFilter compare_filter = 1;
inline bool ValueFilter::has_compare_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ValueFilter::clear_compare_filter() {
  if (compare_filter_ != nullptr) compare_filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::CompareFilter& ValueFilter::compare_filter() const {
  const ::hbase::pb::CompareFilter* p = compare_filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.ValueFilter.compare_filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::CompareFilter*>(
      &::hbase::pb::_CompareFilter_default_instance_);
}
inline ::hbase::pb::CompareFilter* ValueFilter::release_compare_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.ValueFilter.compare_filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::CompareFilter* temp = compare_filter_;
  compare_filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::CompareFilter* ValueFilter::mutable_compare_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (compare_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::CompareFilter>(GetArenaNoVirtual());
    compare_filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ValueFilter.compare_filter)
  return compare_filter_;
}
inline void ValueFilter::set_allocated_compare_filter(::hbase::pb::CompareFilter* compare_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete compare_filter_;
  }
  if (compare_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      compare_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, compare_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  compare_filter_ = compare_filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ValueFilter.compare_filter)
}

// -------------------------------------------------------------------

// WhileMatchFilter

// required .hbase.pb.Filter filter = 1;
inline bool WhileMatchFilter::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhileMatchFilter::clear_filter() {
  if (filter_ != nullptr) filter_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Filter& WhileMatchFilter::filter() const {
  const ::hbase::pb::Filter* p = filter_;
  // @@protoc_insertion_point(field_get:hbase.pb.WhileMatchFilter.filter)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Filter*>(
      &::hbase::pb::_Filter_default_instance_);
}
inline ::hbase::pb::Filter* WhileMatchFilter::release_filter() {
  // @@protoc_insertion_point(field_release:hbase.pb.WhileMatchFilter.filter)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Filter* temp = filter_;
  filter_ = nullptr;
  return temp;
}
inline ::hbase::pb::Filter* WhileMatchFilter::mutable_filter() {
  _has_bits_[0] |= 0x00000001u;
  if (filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Filter>(GetArenaNoVirtual());
    filter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.WhileMatchFilter.filter)
  return filter_;
}
inline void WhileMatchFilter::set_allocated_filter(::hbase::pb::Filter* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WhileMatchFilter.filter)
}

// -------------------------------------------------------------------

// FilterAllFilter

// -------------------------------------------------------------------

// RowRange

// optional bytes start_row = 1;
inline bool RowRange::has_start_row() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowRange::clear_start_row() {
  start_row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RowRange::start_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RowRange.start_row)
  return start_row_.GetNoArena();
}
inline void RowRange::set_start_row(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RowRange.start_row)
}
inline void RowRange::set_start_row(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RowRange.start_row)
}
inline void RowRange::set_start_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RowRange.start_row)
}
inline void RowRange::set_start_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  start_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RowRange.start_row)
}
inline std::string* RowRange::mutable_start_row() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RowRange.start_row)
  return start_row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RowRange::release_start_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.RowRange.start_row)
  if (!has_start_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RowRange::set_allocated_start_row(std::string* start_row) {
  if (start_row != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RowRange.start_row)
}

// optional bool start_row_inclusive = 2;
inline bool RowRange::has_start_row_inclusive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RowRange::clear_start_row_inclusive() {
  start_row_inclusive_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool RowRange::start_row_inclusive() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RowRange.start_row_inclusive)
  return start_row_inclusive_;
}
inline void RowRange::set_start_row_inclusive(bool value) {
  _has_bits_[0] |= 0x00000004u;
  start_row_inclusive_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RowRange.start_row_inclusive)
}

// optional bytes stop_row = 3;
inline bool RowRange::has_stop_row() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RowRange::clear_stop_row() {
  stop_row_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RowRange::stop_row() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RowRange.stop_row)
  return stop_row_.GetNoArena();
}
inline void RowRange::set_stop_row(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RowRange.stop_row)
}
inline void RowRange::set_stop_row(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RowRange.stop_row)
}
inline void RowRange::set_stop_row(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RowRange.stop_row)
}
inline void RowRange::set_stop_row(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  stop_row_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RowRange.stop_row)
}
inline std::string* RowRange::mutable_stop_row() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RowRange.stop_row)
  return stop_row_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RowRange::release_stop_row() {
  // @@protoc_insertion_point(field_release:hbase.pb.RowRange.stop_row)
  if (!has_stop_row()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return stop_row_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RowRange::set_allocated_stop_row(std::string* stop_row) {
  if (stop_row != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  stop_row_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), stop_row);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RowRange.stop_row)
}

// optional bool stop_row_inclusive = 4;
inline bool RowRange::has_stop_row_inclusive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RowRange::clear_stop_row_inclusive() {
  stop_row_inclusive_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool RowRange::stop_row_inclusive() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RowRange.stop_row_inclusive)
  return stop_row_inclusive_;
}
inline void RowRange::set_stop_row_inclusive(bool value) {
  _has_bits_[0] |= 0x00000008u;
  stop_row_inclusive_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RowRange.stop_row_inclusive)
}

// -------------------------------------------------------------------

// MultiRowRangeFilter

// repeated .hbase.pb.RowRange row_range_list = 1;
inline int MultiRowRangeFilter::row_range_list_size() const {
  return row_range_list_.size();
}
inline void MultiRowRangeFilter::clear_row_range_list() {
  row_range_list_.Clear();
}
inline ::hbase::pb::RowRange* MultiRowRangeFilter::mutable_row_range_list(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.MultiRowRangeFilter.row_range_list)
  return row_range_list_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RowRange >*
MultiRowRangeFilter::mutable_row_range_list() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.MultiRowRangeFilter.row_range_list)
  return &row_range_list_;
}
inline const ::hbase::pb::RowRange& MultiRowRangeFilter::row_range_list(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.MultiRowRangeFilter.row_range_list)
  return row_range_list_.Get(index);
}
inline ::hbase::pb::RowRange* MultiRowRangeFilter::add_row_range_list() {
  // @@protoc_insertion_point(field_add:hbase.pb.MultiRowRangeFilter.row_range_list)
  return row_range_list_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::RowRange >&
MultiRowRangeFilter::row_range_list() const {
  // @@protoc_insertion_point(field_list:hbase.pb.MultiRowRangeFilter.row_range_list)
  return row_range_list_;
}

// -------------------------------------------------------------------

// ColumnValueFilter

// required bytes family = 1;
inline bool ColumnValueFilter::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnValueFilter::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnValueFilter::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnValueFilter.family)
  return family_.GetNoArena();
}
inline void ColumnValueFilter::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnValueFilter.family)
}
inline void ColumnValueFilter::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnValueFilter.family)
}
inline void ColumnValueFilter::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnValueFilter.family)
}
inline void ColumnValueFilter::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnValueFilter.family)
}
inline std::string* ColumnValueFilter::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnValueFilter.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnValueFilter::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnValueFilter.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnValueFilter::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnValueFilter.family)
}

// required bytes qualifier = 2;
inline bool ColumnValueFilter::has_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnValueFilter::clear_qualifier() {
  qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ColumnValueFilter::qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnValueFilter.qualifier)
  return qualifier_.GetNoArena();
}
inline void ColumnValueFilter::set_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnValueFilter.qualifier)
}
inline void ColumnValueFilter::set_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnValueFilter.qualifier)
}
inline void ColumnValueFilter::set_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnValueFilter.qualifier)
}
inline void ColumnValueFilter::set_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnValueFilter.qualifier)
}
inline std::string* ColumnValueFilter::mutable_qualifier() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnValueFilter.qualifier)
  return qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnValueFilter::release_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnValueFilter.qualifier)
  if (!has_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnValueFilter::set_allocated_qualifier(std::string* qualifier) {
  if (qualifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnValueFilter.qualifier)
}

// required .hbase.pb.CompareType compare_op = 3;
inline bool ColumnValueFilter::has_compare_op() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnValueFilter::clear_compare_op() {
  compare_op_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hbase::pb::CompareType ColumnValueFilter::compare_op() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnValueFilter.compare_op)
  return static_cast< ::hbase::pb::CompareType >(compare_op_);
}
inline void ColumnValueFilter::set_compare_op(::hbase::pb::CompareType value) {
  assert(::hbase::pb::CompareType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  compare_op_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnValueFilter.compare_op)
}

// required .hbase.pb.Comparator comparator = 4;
inline bool ColumnValueFilter::has_comparator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::Comparator& ColumnValueFilter::comparator() const {
  const ::hbase::pb::Comparator* p = comparator_;
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnValueFilter.comparator)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Comparator*>(
      &::hbase::pb::_Comparator_default_instance_);
}
inline ::hbase::pb::Comparator* ColumnValueFilter::release_comparator() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnValueFilter.comparator)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::Comparator* temp = comparator_;
  comparator_ = nullptr;
  return temp;
}
inline ::hbase::pb::Comparator* ColumnValueFilter::mutable_comparator() {
  _has_bits_[0] |= 0x00000004u;
  if (comparator_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Comparator>(GetArenaNoVirtual());
    comparator_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnValueFilter.comparator)
  return comparator_;
}
inline void ColumnValueFilter::set_allocated_comparator(::hbase::pb::Comparator* comparator) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(comparator_);
  }
  if (comparator) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      comparator = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, comparator, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  comparator_ = comparator;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnValueFilter.comparator)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::FilterList_Operator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::FilterList_Operator>() {
  return ::hbase::pb::FilterList_Operator_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Filter_2eproto
