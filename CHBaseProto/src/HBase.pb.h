// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: HBase.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_HBase_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_HBase_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_HBase_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_HBase_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[25]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_HBase_2eproto;
namespace hbase {
namespace pb {
class BigDecimalMsg;
class BigDecimalMsgDefaultTypeInternal;
extern BigDecimalMsgDefaultTypeInternal _BigDecimalMsg_default_instance_;
class BytesBytesPair;
class BytesBytesPairDefaultTypeInternal;
extern BytesBytesPairDefaultTypeInternal _BytesBytesPair_default_instance_;
class ColumnFamilySchema;
class ColumnFamilySchemaDefaultTypeInternal;
extern ColumnFamilySchemaDefaultTypeInternal _ColumnFamilySchema_default_instance_;
class ColumnFamilyTimeRange;
class ColumnFamilyTimeRangeDefaultTypeInternal;
extern ColumnFamilyTimeRangeDefaultTypeInternal _ColumnFamilyTimeRange_default_instance_;
class Coprocessor;
class CoprocessorDefaultTypeInternal;
extern CoprocessorDefaultTypeInternal _Coprocessor_default_instance_;
class DoubleMsg;
class DoubleMsgDefaultTypeInternal;
extern DoubleMsgDefaultTypeInternal _DoubleMsg_default_instance_;
class EmptyMsg;
class EmptyMsgDefaultTypeInternal;
extern EmptyMsgDefaultTypeInternal _EmptyMsg_default_instance_;
class FavoredNodes;
class FavoredNodesDefaultTypeInternal;
extern FavoredNodesDefaultTypeInternal _FavoredNodes_default_instance_;
class LongMsg;
class LongMsgDefaultTypeInternal;
extern LongMsgDefaultTypeInternal _LongMsg_default_instance_;
class NameBytesPair;
class NameBytesPairDefaultTypeInternal;
extern NameBytesPairDefaultTypeInternal _NameBytesPair_default_instance_;
class NameInt64Pair;
class NameInt64PairDefaultTypeInternal;
extern NameInt64PairDefaultTypeInternal _NameInt64Pair_default_instance_;
class NameStringPair;
class NameStringPairDefaultTypeInternal;
extern NameStringPairDefaultTypeInternal _NameStringPair_default_instance_;
class NamespaceDescriptor;
class NamespaceDescriptorDefaultTypeInternal;
extern NamespaceDescriptorDefaultTypeInternal _NamespaceDescriptor_default_instance_;
class ProcedureDescription;
class ProcedureDescriptionDefaultTypeInternal;
extern ProcedureDescriptionDefaultTypeInternal _ProcedureDescription_default_instance_;
class RegionInfo;
class RegionInfoDefaultTypeInternal;
extern RegionInfoDefaultTypeInternal _RegionInfo_default_instance_;
class RegionServerInfo;
class RegionServerInfoDefaultTypeInternal;
extern RegionServerInfoDefaultTypeInternal _RegionServerInfo_default_instance_;
class RegionSpecifier;
class RegionSpecifierDefaultTypeInternal;
extern RegionSpecifierDefaultTypeInternal _RegionSpecifier_default_instance_;
class ServerName;
class ServerNameDefaultTypeInternal;
extern ServerNameDefaultTypeInternal _ServerName_default_instance_;
class SnapshotDescription;
class SnapshotDescriptionDefaultTypeInternal;
extern SnapshotDescriptionDefaultTypeInternal _SnapshotDescription_default_instance_;
class TableName;
class TableNameDefaultTypeInternal;
extern TableNameDefaultTypeInternal _TableName_default_instance_;
class TableSchema;
class TableSchemaDefaultTypeInternal;
extern TableSchemaDefaultTypeInternal _TableSchema_default_instance_;
class TableState;
class TableStateDefaultTypeInternal;
extern TableStateDefaultTypeInternal _TableState_default_instance_;
class TimeRange;
class TimeRangeDefaultTypeInternal;
extern TimeRangeDefaultTypeInternal _TimeRange_default_instance_;
class UUID;
class UUIDDefaultTypeInternal;
extern UUIDDefaultTypeInternal _UUID_default_instance_;
class VersionInfo;
class VersionInfoDefaultTypeInternal;
extern VersionInfoDefaultTypeInternal _VersionInfo_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::BigDecimalMsg* Arena::CreateMaybeMessage<::hbase::pb::BigDecimalMsg>(Arena*);
template<> ::hbase::pb::BytesBytesPair* Arena::CreateMaybeMessage<::hbase::pb::BytesBytesPair>(Arena*);
template<> ::hbase::pb::ColumnFamilySchema* Arena::CreateMaybeMessage<::hbase::pb::ColumnFamilySchema>(Arena*);
template<> ::hbase::pb::ColumnFamilyTimeRange* Arena::CreateMaybeMessage<::hbase::pb::ColumnFamilyTimeRange>(Arena*);
template<> ::hbase::pb::Coprocessor* Arena::CreateMaybeMessage<::hbase::pb::Coprocessor>(Arena*);
template<> ::hbase::pb::DoubleMsg* Arena::CreateMaybeMessage<::hbase::pb::DoubleMsg>(Arena*);
template<> ::hbase::pb::EmptyMsg* Arena::CreateMaybeMessage<::hbase::pb::EmptyMsg>(Arena*);
template<> ::hbase::pb::FavoredNodes* Arena::CreateMaybeMessage<::hbase::pb::FavoredNodes>(Arena*);
template<> ::hbase::pb::LongMsg* Arena::CreateMaybeMessage<::hbase::pb::LongMsg>(Arena*);
template<> ::hbase::pb::NameBytesPair* Arena::CreateMaybeMessage<::hbase::pb::NameBytesPair>(Arena*);
template<> ::hbase::pb::NameInt64Pair* Arena::CreateMaybeMessage<::hbase::pb::NameInt64Pair>(Arena*);
template<> ::hbase::pb::NameStringPair* Arena::CreateMaybeMessage<::hbase::pb::NameStringPair>(Arena*);
template<> ::hbase::pb::NamespaceDescriptor* Arena::CreateMaybeMessage<::hbase::pb::NamespaceDescriptor>(Arena*);
template<> ::hbase::pb::ProcedureDescription* Arena::CreateMaybeMessage<::hbase::pb::ProcedureDescription>(Arena*);
template<> ::hbase::pb::RegionInfo* Arena::CreateMaybeMessage<::hbase::pb::RegionInfo>(Arena*);
template<> ::hbase::pb::RegionServerInfo* Arena::CreateMaybeMessage<::hbase::pb::RegionServerInfo>(Arena*);
template<> ::hbase::pb::RegionSpecifier* Arena::CreateMaybeMessage<::hbase::pb::RegionSpecifier>(Arena*);
template<> ::hbase::pb::ServerName* Arena::CreateMaybeMessage<::hbase::pb::ServerName>(Arena*);
template<> ::hbase::pb::SnapshotDescription* Arena::CreateMaybeMessage<::hbase::pb::SnapshotDescription>(Arena*);
template<> ::hbase::pb::TableName* Arena::CreateMaybeMessage<::hbase::pb::TableName>(Arena*);
template<> ::hbase::pb::TableSchema* Arena::CreateMaybeMessage<::hbase::pb::TableSchema>(Arena*);
template<> ::hbase::pb::TableState* Arena::CreateMaybeMessage<::hbase::pb::TableState>(Arena*);
template<> ::hbase::pb::TimeRange* Arena::CreateMaybeMessage<::hbase::pb::TimeRange>(Arena*);
template<> ::hbase::pb::UUID* Arena::CreateMaybeMessage<::hbase::pb::UUID>(Arena*);
template<> ::hbase::pb::VersionInfo* Arena::CreateMaybeMessage<::hbase::pb::VersionInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum TableState_State : int {
  TableState_State_ENABLED = 0,
  TableState_State_DISABLED = 1,
  TableState_State_DISABLING = 2,
  TableState_State_ENABLING = 3
};
bool TableState_State_IsValid(int value);
constexpr TableState_State TableState_State_State_MIN = TableState_State_ENABLED;
constexpr TableState_State TableState_State_State_MAX = TableState_State_ENABLING;
constexpr int TableState_State_State_ARRAYSIZE = TableState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TableState_State_descriptor();
template<typename T>
inline const std::string& TableState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TableState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TableState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TableState_State_descriptor(), enum_t_value);
}
inline bool TableState_State_Parse(
    const std::string& name, TableState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TableState_State>(
    TableState_State_descriptor(), name, value);
}
enum RegionSpecifier_RegionSpecifierType : int {
  RegionSpecifier_RegionSpecifierType_REGION_NAME = 1,
  RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME = 2
};
bool RegionSpecifier_RegionSpecifierType_IsValid(int value);
constexpr RegionSpecifier_RegionSpecifierType RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MIN = RegionSpecifier_RegionSpecifierType_REGION_NAME;
constexpr RegionSpecifier_RegionSpecifierType RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX = RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME;
constexpr int RegionSpecifier_RegionSpecifierType_RegionSpecifierType_ARRAYSIZE = RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionSpecifier_RegionSpecifierType_descriptor();
template<typename T>
inline const std::string& RegionSpecifier_RegionSpecifierType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionSpecifier_RegionSpecifierType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionSpecifier_RegionSpecifierType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionSpecifier_RegionSpecifierType_descriptor(), enum_t_value);
}
inline bool RegionSpecifier_RegionSpecifierType_Parse(
    const std::string& name, RegionSpecifier_RegionSpecifierType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionSpecifier_RegionSpecifierType>(
    RegionSpecifier_RegionSpecifierType_descriptor(), name, value);
}
enum SnapshotDescription_Type : int {
  SnapshotDescription_Type_DISABLED = 0,
  SnapshotDescription_Type_FLUSH = 1,
  SnapshotDescription_Type_SKIPFLUSH = 2
};
bool SnapshotDescription_Type_IsValid(int value);
constexpr SnapshotDescription_Type SnapshotDescription_Type_Type_MIN = SnapshotDescription_Type_DISABLED;
constexpr SnapshotDescription_Type SnapshotDescription_Type_Type_MAX = SnapshotDescription_Type_SKIPFLUSH;
constexpr int SnapshotDescription_Type_Type_ARRAYSIZE = SnapshotDescription_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SnapshotDescription_Type_descriptor();
template<typename T>
inline const std::string& SnapshotDescription_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SnapshotDescription_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SnapshotDescription_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SnapshotDescription_Type_descriptor(), enum_t_value);
}
inline bool SnapshotDescription_Type_Parse(
    const std::string& name, SnapshotDescription_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SnapshotDescription_Type>(
    SnapshotDescription_Type_descriptor(), name, value);
}
enum CompareType : int {
  LESS = 0,
  LESS_OR_EQUAL = 1,
  EQUAL = 2,
  NOT_EQUAL = 3,
  GREATER_OR_EQUAL = 4,
  GREATER = 5,
  NO_OP = 6
};
bool CompareType_IsValid(int value);
constexpr CompareType CompareType_MIN = LESS;
constexpr CompareType CompareType_MAX = NO_OP;
constexpr int CompareType_ARRAYSIZE = CompareType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompareType_descriptor();
template<typename T>
inline const std::string& CompareType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompareType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompareType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompareType_descriptor(), enum_t_value);
}
inline bool CompareType_Parse(
    const std::string& name, CompareType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompareType>(
    CompareType_descriptor(), name, value);
}
enum TimeUnit : int {
  NANOSECONDS = 1,
  MICROSECONDS = 2,
  MILLISECONDS = 3,
  SECONDS = 4,
  MINUTES = 5,
  HOURS = 6,
  DAYS = 7
};
bool TimeUnit_IsValid(int value);
constexpr TimeUnit TimeUnit_MIN = NANOSECONDS;
constexpr TimeUnit TimeUnit_MAX = DAYS;
constexpr int TimeUnit_ARRAYSIZE = TimeUnit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TimeUnit_descriptor();
template<typename T>
inline const std::string& TimeUnit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TimeUnit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TimeUnit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TimeUnit_descriptor(), enum_t_value);
}
inline bool TimeUnit_Parse(
    const std::string& name, TimeUnit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TimeUnit>(
    TimeUnit_descriptor(), name, value);
}
// ===================================================================

class TableName :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TableName) */ {
 public:
  TableName();
  virtual ~TableName();

  TableName(const TableName& from);
  TableName(TableName&& from) noexcept
    : TableName() {
    *this = ::std::move(from);
  }

  inline TableName& operator=(const TableName& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableName& operator=(TableName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableName* internal_default_instance() {
    return reinterpret_cast<const TableName*>(
               &_TableName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TableName& a, TableName& b) {
    a.Swap(&b);
  }
  inline void Swap(TableName* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableName* New() const final {
    return CreateMaybeMessage<TableName>(nullptr);
  }

  TableName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableName& from);
  void MergeFrom(const TableName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TableName";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamespaceFieldNumber = 1,
    kQualifierFieldNumber = 2,
  };
  // required bytes namespace = 1;
  bool has_namespace_() const;
  void clear_namespace_();
  const std::string& namespace_() const;
  void set_namespace_(const std::string& value);
  void set_namespace_(std::string&& value);
  void set_namespace_(const char* value);
  void set_namespace_(const void* value, size_t size);
  std::string* mutable_namespace_();
  std::string* release_namespace_();
  void set_allocated_namespace_(std::string* namespace_);

  // required bytes qualifier = 2;
  bool has_qualifier() const;
  void clear_qualifier();
  const std::string& qualifier() const;
  void set_qualifier(const std::string& value);
  void set_qualifier(std::string&& value);
  void set_qualifier(const char* value);
  void set_qualifier(const void* value, size_t size);
  std::string* mutable_qualifier();
  std::string* release_qualifier();
  void set_allocated_qualifier(std::string* qualifier);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableName)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr namespace__;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr qualifier_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class TableSchema :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TableSchema) */ {
 public:
  TableSchema();
  virtual ~TableSchema();

  TableSchema(const TableSchema& from);
  TableSchema(TableSchema&& from) noexcept
    : TableSchema() {
    *this = ::std::move(from);
  }

  inline TableSchema& operator=(const TableSchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableSchema& operator=(TableSchema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableSchema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableSchema* internal_default_instance() {
    return reinterpret_cast<const TableSchema*>(
               &_TableSchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TableSchema& a, TableSchema& b) {
    a.Swap(&b);
  }
  inline void Swap(TableSchema* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableSchema* New() const final {
    return CreateMaybeMessage<TableSchema>(nullptr);
  }

  TableSchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableSchema>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableSchema& from);
  void MergeFrom(const TableSchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableSchema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TableSchema";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kColumnFamiliesFieldNumber = 3,
    kConfigurationFieldNumber = 4,
    kTableNameFieldNumber = 1,
  };
  // repeated .hbase.pb.BytesBytesPair attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  ::hbase::pb::BytesBytesPair* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_attributes();
  const ::hbase::pb::BytesBytesPair& attributes(int index) const;
  ::hbase::pb::BytesBytesPair* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      attributes() const;

  // repeated .hbase.pb.ColumnFamilySchema column_families = 3;
  int column_families_size() const;
  void clear_column_families();
  ::hbase::pb::ColumnFamilySchema* mutable_column_families(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >*
      mutable_column_families();
  const ::hbase::pb::ColumnFamilySchema& column_families(int index) const;
  ::hbase::pb::ColumnFamilySchema* add_column_families();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >&
      column_families() const;

  // repeated .hbase.pb.NameStringPair configuration = 4;
  int configuration_size() const;
  void clear_configuration();
  ::hbase::pb::NameStringPair* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();
  const ::hbase::pb::NameStringPair& configuration(int index) const;
  ::hbase::pb::NameStringPair* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;

  // optional .hbase.pb.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableSchema)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair > attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema > column_families_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;
  ::hbase::pb::TableName* table_name_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class TableState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TableState) */ {
 public:
  TableState();
  virtual ~TableState();

  TableState(const TableState& from);
  TableState(TableState&& from) noexcept
    : TableState() {
    *this = ::std::move(from);
  }

  inline TableState& operator=(const TableState& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableState& operator=(TableState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableState* internal_default_instance() {
    return reinterpret_cast<const TableState*>(
               &_TableState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TableState& a, TableState& b) {
    a.Swap(&b);
  }
  inline void Swap(TableState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableState* New() const final {
    return CreateMaybeMessage<TableState>(nullptr);
  }

  TableState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableState& from);
  void MergeFrom(const TableState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TableState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef TableState_State State;
  static constexpr State ENABLED =
    TableState_State_ENABLED;
  static constexpr State DISABLED =
    TableState_State_DISABLED;
  static constexpr State DISABLING =
    TableState_State_DISABLING;
  static constexpr State ENABLING =
    TableState_State_ENABLING;
  static inline bool State_IsValid(int value) {
    return TableState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    TableState_State_State_MIN;
  static constexpr State State_MAX =
    TableState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    TableState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return TableState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return TableState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return TableState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .hbase.pb.TableState.State state = 1;
  bool has_state() const;
  void clear_state();
  ::hbase::pb::TableState_State state() const;
  void set_state(::hbase::pb::TableState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class ColumnFamilySchema :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnFamilySchema) */ {
 public:
  ColumnFamilySchema();
  virtual ~ColumnFamilySchema();

  ColumnFamilySchema(const ColumnFamilySchema& from);
  ColumnFamilySchema(ColumnFamilySchema&& from) noexcept
    : ColumnFamilySchema() {
    *this = ::std::move(from);
  }

  inline ColumnFamilySchema& operator=(const ColumnFamilySchema& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnFamilySchema& operator=(ColumnFamilySchema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnFamilySchema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnFamilySchema* internal_default_instance() {
    return reinterpret_cast<const ColumnFamilySchema*>(
               &_ColumnFamilySchema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ColumnFamilySchema& a, ColumnFamilySchema& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnFamilySchema* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnFamilySchema* New() const final {
    return CreateMaybeMessage<ColumnFamilySchema>(nullptr);
  }

  ColumnFamilySchema* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnFamilySchema>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnFamilySchema& from);
  void MergeFrom(const ColumnFamilySchema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnFamilySchema* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnFamilySchema";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributesFieldNumber = 2,
    kConfigurationFieldNumber = 3,
    kNameFieldNumber = 1,
  };
  // repeated .hbase.pb.BytesBytesPair attributes = 2;
  int attributes_size() const;
  void clear_attributes();
  ::hbase::pb::BytesBytesPair* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_attributes();
  const ::hbase::pb::BytesBytesPair& attributes(int index) const;
  ::hbase::pb::BytesBytesPair* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      attributes() const;

  // repeated .hbase.pb.NameStringPair configuration = 3;
  int configuration_size() const;
  void clear_configuration();
  ::hbase::pb::NameStringPair* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();
  const ::hbase::pb::NameStringPair& configuration(int index) const;
  ::hbase::pb::NameStringPair* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;

  // required bytes name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnFamilySchema)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair > attributes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class RegionInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionInfo) */ {
 public:
  RegionInfo();
  virtual ~RegionInfo();

  RegionInfo(const RegionInfo& from);
  RegionInfo(RegionInfo&& from) noexcept
    : RegionInfo() {
    *this = ::std::move(from);
  }

  inline RegionInfo& operator=(const RegionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionInfo& operator=(RegionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionInfo* internal_default_instance() {
    return reinterpret_cast<const RegionInfo*>(
               &_RegionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RegionInfo& a, RegionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionInfo* New() const final {
    return CreateMaybeMessage<RegionInfo>(nullptr);
  }

  RegionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionInfo& from);
  void MergeFrom(const RegionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartKeyFieldNumber = 3,
    kEndKeyFieldNumber = 4,
    kTableNameFieldNumber = 2,
    kRegionIdFieldNumber = 1,
    kOfflineFieldNumber = 5,
    kSplitFieldNumber = 6,
    kReplicaIdFieldNumber = 7,
  };
  // optional bytes start_key = 3;
  bool has_start_key() const;
  void clear_start_key();
  const std::string& start_key() const;
  void set_start_key(const std::string& value);
  void set_start_key(std::string&& value);
  void set_start_key(const char* value);
  void set_start_key(const void* value, size_t size);
  std::string* mutable_start_key();
  std::string* release_start_key();
  void set_allocated_start_key(std::string* start_key);

  // optional bytes end_key = 4;
  bool has_end_key() const;
  void clear_end_key();
  const std::string& end_key() const;
  void set_end_key(const std::string& value);
  void set_end_key(std::string&& value);
  void set_end_key(const char* value);
  void set_end_key(const void* value, size_t size);
  std::string* mutable_end_key();
  std::string* release_end_key();
  void set_allocated_end_key(std::string* end_key);

  // required .hbase.pb.TableName table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required uint64 region_id = 1;
  bool has_region_id() const;
  void clear_region_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id() const;
  void set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional bool offline = 5;
  bool has_offline() const;
  void clear_offline();
  bool offline() const;
  void set_offline(bool value);

  // optional bool split = 6;
  bool has_split() const;
  void clear_split();
  bool split() const;
  void set_split(bool value);

  // optional int32 replica_id = 7 [default = 0];
  bool has_replica_id() const;
  void clear_replica_id();
  ::PROTOBUF_NAMESPACE_ID::int32 replica_id() const;
  void set_replica_id(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_key_;
  ::hbase::pb::TableName* table_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 region_id_;
  bool offline_;
  bool split_;
  ::PROTOBUF_NAMESPACE_ID::int32 replica_id_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class FavoredNodes :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FavoredNodes) */ {
 public:
  FavoredNodes();
  virtual ~FavoredNodes();

  FavoredNodes(const FavoredNodes& from);
  FavoredNodes(FavoredNodes&& from) noexcept
    : FavoredNodes() {
    *this = ::std::move(from);
  }

  inline FavoredNodes& operator=(const FavoredNodes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FavoredNodes& operator=(FavoredNodes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FavoredNodes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FavoredNodes* internal_default_instance() {
    return reinterpret_cast<const FavoredNodes*>(
               &_FavoredNodes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FavoredNodes& a, FavoredNodes& b) {
    a.Swap(&b);
  }
  inline void Swap(FavoredNodes* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FavoredNodes* New() const final {
    return CreateMaybeMessage<FavoredNodes>(nullptr);
  }

  FavoredNodes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FavoredNodes>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FavoredNodes& from);
  void MergeFrom(const FavoredNodes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FavoredNodes* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FavoredNodes";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFavoredNodeFieldNumber = 1,
  };
  // repeated .hbase.pb.ServerName favored_node = 1;
  int favored_node_size() const;
  void clear_favored_node();
  ::hbase::pb::ServerName* mutable_favored_node(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
      mutable_favored_node();
  const ::hbase::pb::ServerName& favored_node(int index) const;
  ::hbase::pb::ServerName* add_favored_node();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
      favored_node() const;

  // @@protoc_insertion_point(class_scope:hbase.pb.FavoredNodes)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName > favored_node_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class RegionSpecifier :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionSpecifier) */ {
 public:
  RegionSpecifier();
  virtual ~RegionSpecifier();

  RegionSpecifier(const RegionSpecifier& from);
  RegionSpecifier(RegionSpecifier&& from) noexcept
    : RegionSpecifier() {
    *this = ::std::move(from);
  }

  inline RegionSpecifier& operator=(const RegionSpecifier& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionSpecifier& operator=(RegionSpecifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionSpecifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionSpecifier* internal_default_instance() {
    return reinterpret_cast<const RegionSpecifier*>(
               &_RegionSpecifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RegionSpecifier& a, RegionSpecifier& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionSpecifier* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionSpecifier* New() const final {
    return CreateMaybeMessage<RegionSpecifier>(nullptr);
  }

  RegionSpecifier* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionSpecifier>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionSpecifier& from);
  void MergeFrom(const RegionSpecifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionSpecifier* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionSpecifier";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RegionSpecifier_RegionSpecifierType RegionSpecifierType;
  static constexpr RegionSpecifierType REGION_NAME =
    RegionSpecifier_RegionSpecifierType_REGION_NAME;
  static constexpr RegionSpecifierType ENCODED_REGION_NAME =
    RegionSpecifier_RegionSpecifierType_ENCODED_REGION_NAME;
  static inline bool RegionSpecifierType_IsValid(int value) {
    return RegionSpecifier_RegionSpecifierType_IsValid(value);
  }
  static constexpr RegionSpecifierType RegionSpecifierType_MIN =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MIN;
  static constexpr RegionSpecifierType RegionSpecifierType_MAX =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_MAX;
  static constexpr int RegionSpecifierType_ARRAYSIZE =
    RegionSpecifier_RegionSpecifierType_RegionSpecifierType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RegionSpecifierType_descriptor() {
    return RegionSpecifier_RegionSpecifierType_descriptor();
  }
  template<typename T>
  static inline const std::string& RegionSpecifierType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RegionSpecifierType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RegionSpecifierType_Name.");
    return RegionSpecifier_RegionSpecifierType_Name(enum_t_value);
  }
  static inline bool RegionSpecifierType_Parse(const std::string& name,
      RegionSpecifierType* value) {
    return RegionSpecifier_RegionSpecifierType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // required bytes value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // required .hbase.pb.RegionSpecifier.RegionSpecifierType type = 1;
  bool has_type() const;
  void clear_type();
  ::hbase::pb::RegionSpecifier_RegionSpecifierType type() const;
  void set_type(::hbase::pb::RegionSpecifier_RegionSpecifierType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionSpecifier)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  int type_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class TimeRange :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TimeRange) */ {
 public:
  TimeRange();
  virtual ~TimeRange();

  TimeRange(const TimeRange& from);
  TimeRange(TimeRange&& from) noexcept
    : TimeRange() {
    *this = ::std::move(from);
  }

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimeRange& operator=(TimeRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimeRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimeRange* internal_default_instance() {
    return reinterpret_cast<const TimeRange*>(
               &_TimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TimeRange& a, TimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(TimeRange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimeRange* New() const final {
    return CreateMaybeMessage<TimeRange>(nullptr);
  }

  TimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimeRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimeRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TimeRange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromFieldNumber = 1,
    kToFieldNumber = 2,
  };
  // optional uint64 from = 1;
  bool has_from() const;
  void clear_from();
  ::PROTOBUF_NAMESPACE_ID::uint64 from() const;
  void set_from(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 to = 2;
  bool has_to() const;
  void clear_to();
  ::PROTOBUF_NAMESPACE_ID::uint64 to() const;
  void set_to(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TimeRange)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 from_;
  ::PROTOBUF_NAMESPACE_ID::uint64 to_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class ColumnFamilyTimeRange :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ColumnFamilyTimeRange) */ {
 public:
  ColumnFamilyTimeRange();
  virtual ~ColumnFamilyTimeRange();

  ColumnFamilyTimeRange(const ColumnFamilyTimeRange& from);
  ColumnFamilyTimeRange(ColumnFamilyTimeRange&& from) noexcept
    : ColumnFamilyTimeRange() {
    *this = ::std::move(from);
  }

  inline ColumnFamilyTimeRange& operator=(const ColumnFamilyTimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline ColumnFamilyTimeRange& operator=(ColumnFamilyTimeRange&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ColumnFamilyTimeRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnFamilyTimeRange* internal_default_instance() {
    return reinterpret_cast<const ColumnFamilyTimeRange*>(
               &_ColumnFamilyTimeRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ColumnFamilyTimeRange& a, ColumnFamilyTimeRange& b) {
    a.Swap(&b);
  }
  inline void Swap(ColumnFamilyTimeRange* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ColumnFamilyTimeRange* New() const final {
    return CreateMaybeMessage<ColumnFamilyTimeRange>(nullptr);
  }

  ColumnFamilyTimeRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ColumnFamilyTimeRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ColumnFamilyTimeRange& from);
  void MergeFrom(const ColumnFamilyTimeRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnFamilyTimeRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ColumnFamilyTimeRange";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColumnFamilyFieldNumber = 1,
    kTimeRangeFieldNumber = 2,
  };
  // required bytes column_family = 1;
  bool has_column_family() const;
  void clear_column_family();
  const std::string& column_family() const;
  void set_column_family(const std::string& value);
  void set_column_family(std::string&& value);
  void set_column_family(const char* value);
  void set_column_family(const void* value, size_t size);
  std::string* mutable_column_family();
  std::string* release_column_family();
  void set_allocated_column_family(std::string* column_family);

  // required .hbase.pb.TimeRange time_range = 2;
  bool has_time_range() const;
  void clear_time_range();
  const ::hbase::pb::TimeRange& time_range() const;
  ::hbase::pb::TimeRange* release_time_range();
  ::hbase::pb::TimeRange* mutable_time_range();
  void set_allocated_time_range(::hbase::pb::TimeRange* time_range);

  // @@protoc_insertion_point(class_scope:hbase.pb.ColumnFamilyTimeRange)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr column_family_;
  ::hbase::pb::TimeRange* time_range_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class ServerName :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ServerName) */ {
 public:
  ServerName();
  virtual ~ServerName();

  ServerName(const ServerName& from);
  ServerName(ServerName&& from) noexcept
    : ServerName() {
    *this = ::std::move(from);
  }

  inline ServerName& operator=(const ServerName& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServerName& operator=(ServerName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ServerName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerName* internal_default_instance() {
    return reinterpret_cast<const ServerName*>(
               &_ServerName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ServerName& a, ServerName& b) {
    a.Swap(&b);
  }
  inline void Swap(ServerName* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServerName* New() const final {
    return CreateMaybeMessage<ServerName>(nullptr);
  }

  ServerName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServerName>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ServerName& from);
  void MergeFrom(const ServerName& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServerName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ServerName";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostNameFieldNumber = 1,
    kStartCodeFieldNumber = 3,
    kPortFieldNumber = 2,
  };
  // required string host_name = 1;
  bool has_host_name() const;
  void clear_host_name();
  const std::string& host_name() const;
  void set_host_name(const std::string& value);
  void set_host_name(std::string&& value);
  void set_host_name(const char* value);
  void set_host_name(const char* value, size_t size);
  std::string* mutable_host_name();
  std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);

  // optional uint64 start_code = 3;
  bool has_start_code() const;
  void clear_start_code();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_code() const;
  void set_start_code(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 port = 2;
  bool has_port() const;
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ServerName)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_code_;
  ::PROTOBUF_NAMESPACE_ID::uint32 port_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class Coprocessor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Coprocessor) */ {
 public:
  Coprocessor();
  virtual ~Coprocessor();

  Coprocessor(const Coprocessor& from);
  Coprocessor(Coprocessor&& from) noexcept
    : Coprocessor() {
    *this = ::std::move(from);
  }

  inline Coprocessor& operator=(const Coprocessor& from) {
    CopyFrom(from);
    return *this;
  }
  inline Coprocessor& operator=(Coprocessor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Coprocessor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coprocessor* internal_default_instance() {
    return reinterpret_cast<const Coprocessor*>(
               &_Coprocessor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Coprocessor& a, Coprocessor& b) {
    a.Swap(&b);
  }
  inline void Swap(Coprocessor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Coprocessor* New() const final {
    return CreateMaybeMessage<Coprocessor>(nullptr);
  }

  Coprocessor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Coprocessor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Coprocessor& from);
  void MergeFrom(const Coprocessor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coprocessor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Coprocessor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:hbase.pb.Coprocessor)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class NameStringPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.NameStringPair) */ {
 public:
  NameStringPair();
  virtual ~NameStringPair();

  NameStringPair(const NameStringPair& from);
  NameStringPair(NameStringPair&& from) noexcept
    : NameStringPair() {
    *this = ::std::move(from);
  }

  inline NameStringPair& operator=(const NameStringPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameStringPair& operator=(NameStringPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameStringPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameStringPair* internal_default_instance() {
    return reinterpret_cast<const NameStringPair*>(
               &_NameStringPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(NameStringPair& a, NameStringPair& b) {
    a.Swap(&b);
  }
  inline void Swap(NameStringPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameStringPair* New() const final {
    return CreateMaybeMessage<NameStringPair>(nullptr);
  }

  NameStringPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameStringPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameStringPair& from);
  void MergeFrom(const NameStringPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameStringPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.NameStringPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // required string value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameStringPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class NameBytesPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.NameBytesPair) */ {
 public:
  NameBytesPair();
  virtual ~NameBytesPair();

  NameBytesPair(const NameBytesPair& from);
  NameBytesPair(NameBytesPair&& from) noexcept
    : NameBytesPair() {
    *this = ::std::move(from);
  }

  inline NameBytesPair& operator=(const NameBytesPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameBytesPair& operator=(NameBytesPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameBytesPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameBytesPair* internal_default_instance() {
    return reinterpret_cast<const NameBytesPair*>(
               &_NameBytesPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(NameBytesPair& a, NameBytesPair& b) {
    a.Swap(&b);
  }
  inline void Swap(NameBytesPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameBytesPair* New() const final {
    return CreateMaybeMessage<NameBytesPair>(nullptr);
  }

  NameBytesPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameBytesPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameBytesPair& from);
  void MergeFrom(const NameBytesPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameBytesPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.NameBytesPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  const std::string& value() const;
  void set_value(const std::string& value);
  void set_value(std::string&& value);
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  std::string* mutable_value();
  std::string* release_value();
  void set_allocated_value(std::string* value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameBytesPair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class BytesBytesPair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BytesBytesPair) */ {
 public:
  BytesBytesPair();
  virtual ~BytesBytesPair();

  BytesBytesPair(const BytesBytesPair& from);
  BytesBytesPair(BytesBytesPair&& from) noexcept
    : BytesBytesPair() {
    *this = ::std::move(from);
  }

  inline BytesBytesPair& operator=(const BytesBytesPair& from) {
    CopyFrom(from);
    return *this;
  }
  inline BytesBytesPair& operator=(BytesBytesPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BytesBytesPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BytesBytesPair* internal_default_instance() {
    return reinterpret_cast<const BytesBytesPair*>(
               &_BytesBytesPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BytesBytesPair& a, BytesBytesPair& b) {
    a.Swap(&b);
  }
  inline void Swap(BytesBytesPair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BytesBytesPair* New() const final {
    return CreateMaybeMessage<BytesBytesPair>(nullptr);
  }

  BytesBytesPair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BytesBytesPair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BytesBytesPair& from);
  void MergeFrom(const BytesBytesPair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BytesBytesPair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BytesBytesPair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstFieldNumber = 1,
    kSecondFieldNumber = 2,
  };
  // required bytes first = 1;
  bool has_first() const;
  void clear_first();
  const std::string& first() const;
  void set_first(const std::string& value);
  void set_first(std::string&& value);
  void set_first(const char* value);
  void set_first(const void* value, size_t size);
  std::string* mutable_first();
  std::string* release_first();
  void set_allocated_first(std::string* first);

  // required bytes second = 2;
  bool has_second() const;
  void clear_second();
  const std::string& second() const;
  void set_second(const std::string& value);
  void set_second(std::string&& value);
  void set_second(const char* value);
  void set_second(const void* value, size_t size);
  std::string* mutable_second();
  std::string* release_second();
  void set_allocated_second(std::string* second);

  // @@protoc_insertion_point(class_scope:hbase.pb.BytesBytesPair)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr second_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class NameInt64Pair :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.NameInt64Pair) */ {
 public:
  NameInt64Pair();
  virtual ~NameInt64Pair();

  NameInt64Pair(const NameInt64Pair& from);
  NameInt64Pair(NameInt64Pair&& from) noexcept
    : NameInt64Pair() {
    *this = ::std::move(from);
  }

  inline NameInt64Pair& operator=(const NameInt64Pair& from) {
    CopyFrom(from);
    return *this;
  }
  inline NameInt64Pair& operator=(NameInt64Pair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NameInt64Pair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NameInt64Pair* internal_default_instance() {
    return reinterpret_cast<const NameInt64Pair*>(
               &_NameInt64Pair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(NameInt64Pair& a, NameInt64Pair& b) {
    a.Swap(&b);
  }
  inline void Swap(NameInt64Pair* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NameInt64Pair* New() const final {
    return CreateMaybeMessage<NameInt64Pair>(nullptr);
  }

  NameInt64Pair* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NameInt64Pair>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NameInt64Pair& from);
  void MergeFrom(const NameInt64Pair& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NameInt64Pair* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.NameInt64Pair";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional int64 value = 2;
  bool has_value() const;
  void clear_value();
  ::PROTOBUF_NAMESPACE_ID::int64 value() const;
  void set_value(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.NameInt64Pair)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::int64 value_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class SnapshotDescription :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SnapshotDescription) */ {
 public:
  SnapshotDescription();
  virtual ~SnapshotDescription();

  SnapshotDescription(const SnapshotDescription& from);
  SnapshotDescription(SnapshotDescription&& from) noexcept
    : SnapshotDescription() {
    *this = ::std::move(from);
  }

  inline SnapshotDescription& operator=(const SnapshotDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotDescription& operator=(SnapshotDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnapshotDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnapshotDescription* internal_default_instance() {
    return reinterpret_cast<const SnapshotDescription*>(
               &_SnapshotDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(SnapshotDescription& a, SnapshotDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotDescription* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnapshotDescription* New() const final {
    return CreateMaybeMessage<SnapshotDescription>(nullptr);
  }

  SnapshotDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnapshotDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnapshotDescription& from);
  void MergeFrom(const SnapshotDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SnapshotDescription";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SnapshotDescription_Type Type;
  static constexpr Type DISABLED =
    SnapshotDescription_Type_DISABLED;
  static constexpr Type FLUSH =
    SnapshotDescription_Type_FLUSH;
  static constexpr Type SKIPFLUSH =
    SnapshotDescription_Type_SKIPFLUSH;
  static inline bool Type_IsValid(int value) {
    return SnapshotDescription_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    SnapshotDescription_Type_Type_MIN;
  static constexpr Type Type_MAX =
    SnapshotDescription_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    SnapshotDescription_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return SnapshotDescription_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return SnapshotDescription_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return SnapshotDescription_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTableFieldNumber = 2,
    kOwnerFieldNumber = 6,
    kCreationTimeFieldNumber = 3,
    kVersionFieldNumber = 5,
    kTypeFieldNumber = 4,
  };
  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string table = 2;
  bool has_table() const;
  void clear_table();
  const std::string& table() const;
  void set_table(const std::string& value);
  void set_table(std::string&& value);
  void set_table(const char* value);
  void set_table(const char* value, size_t size);
  std::string* mutable_table();
  std::string* release_table();
  void set_allocated_table(std::string* table);

  // optional string owner = 6;
  bool has_owner() const;
  void clear_owner();
  const std::string& owner() const;
  void set_owner(const std::string& value);
  void set_owner(std::string&& value);
  void set_owner(const char* value);
  void set_owner(const char* value, size_t size);
  std::string* mutable_owner();
  std::string* release_owner();
  void set_allocated_owner(std::string* owner);

  // optional int64 creation_time = 3 [default = 0];
  bool has_creation_time() const;
  void clear_creation_time();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time() const;
  void set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // optional int32 version = 5;
  bool has_version() const;
  void clear_version();
  ::PROTOBUF_NAMESPACE_ID::int32 version() const;
  void set_version(::PROTOBUF_NAMESPACE_ID::int32 value);

  // optional .hbase.pb.SnapshotDescription.Type type = 4 [default = FLUSH];
  bool has_type() const;
  void clear_type();
  ::hbase::pb::SnapshotDescription_Type type() const;
  void set_type(::hbase::pb::SnapshotDescription_Type value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SnapshotDescription)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr owner_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time_;
  ::PROTOBUF_NAMESPACE_ID::int32 version_;
  int type_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class ProcedureDescription :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ProcedureDescription) */ {
 public:
  ProcedureDescription();
  virtual ~ProcedureDescription();

  ProcedureDescription(const ProcedureDescription& from);
  ProcedureDescription(ProcedureDescription&& from) noexcept
    : ProcedureDescription() {
    *this = ::std::move(from);
  }

  inline ProcedureDescription& operator=(const ProcedureDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProcedureDescription& operator=(ProcedureDescription&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProcedureDescription& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcedureDescription* internal_default_instance() {
    return reinterpret_cast<const ProcedureDescription*>(
               &_ProcedureDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(ProcedureDescription& a, ProcedureDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(ProcedureDescription* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProcedureDescription* New() const final {
    return CreateMaybeMessage<ProcedureDescription>(nullptr);
  }

  ProcedureDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProcedureDescription>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProcedureDescription& from);
  void MergeFrom(const ProcedureDescription& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProcedureDescription* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ProcedureDescription";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 4,
    kSignatureFieldNumber = 1,
    kInstanceFieldNumber = 2,
    kCreationTimeFieldNumber = 3,
  };
  // repeated .hbase.pb.NameStringPair configuration = 4;
  int configuration_size() const;
  void clear_configuration();
  ::hbase::pb::NameStringPair* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();
  const ::hbase::pb::NameStringPair& configuration(int index) const;
  ::hbase::pb::NameStringPair* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;

  // required string signature = 1;
  bool has_signature() const;
  void clear_signature();
  const std::string& signature() const;
  void set_signature(const std::string& value);
  void set_signature(std::string&& value);
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  std::string* mutable_signature();
  std::string* release_signature();
  void set_allocated_signature(std::string* signature);

  // optional string instance = 2;
  bool has_instance() const;
  void clear_instance();
  const std::string& instance() const;
  void set_instance(const std::string& value);
  void set_instance(std::string&& value);
  void set_instance(const char* value);
  void set_instance(const char* value, size_t size);
  std::string* mutable_instance();
  std::string* release_instance();
  void set_allocated_instance(std::string* instance);

  // optional int64 creation_time = 3 [default = 0];
  bool has_creation_time() const;
  void clear_creation_time();
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time() const;
  void set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ProcedureDescription)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instance_;
  ::PROTOBUF_NAMESPACE_ID::int64 creation_time_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class EmptyMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.EmptyMsg) */ {
 public:
  EmptyMsg();
  virtual ~EmptyMsg();

  EmptyMsg(const EmptyMsg& from);
  EmptyMsg(EmptyMsg&& from) noexcept
    : EmptyMsg() {
    *this = ::std::move(from);
  }

  inline EmptyMsg& operator=(const EmptyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline EmptyMsg& operator=(EmptyMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EmptyMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EmptyMsg* internal_default_instance() {
    return reinterpret_cast<const EmptyMsg*>(
               &_EmptyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(EmptyMsg& a, EmptyMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(EmptyMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EmptyMsg* New() const final {
    return CreateMaybeMessage<EmptyMsg>(nullptr);
  }

  EmptyMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EmptyMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EmptyMsg& from);
  void MergeFrom(const EmptyMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EmptyMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.EmptyMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.EmptyMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class LongMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.LongMsg) */ {
 public:
  LongMsg();
  virtual ~LongMsg();

  LongMsg(const LongMsg& from);
  LongMsg(LongMsg&& from) noexcept
    : LongMsg() {
    *this = ::std::move(from);
  }

  inline LongMsg& operator=(const LongMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline LongMsg& operator=(LongMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LongMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongMsg* internal_default_instance() {
    return reinterpret_cast<const LongMsg*>(
               &_LongMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(LongMsg& a, LongMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(LongMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LongMsg* New() const final {
    return CreateMaybeMessage<LongMsg>(nullptr);
  }

  LongMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LongMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LongMsg& from);
  void MergeFrom(const LongMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.LongMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLongMsgFieldNumber = 1,
  };
  // required int64 long_msg = 1;
  bool has_long_msg() const;
  void clear_long_msg();
  ::PROTOBUF_NAMESPACE_ID::int64 long_msg() const;
  void set_long_msg(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.LongMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 long_msg_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class DoubleMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.DoubleMsg) */ {
 public:
  DoubleMsg();
  virtual ~DoubleMsg();

  DoubleMsg(const DoubleMsg& from);
  DoubleMsg(DoubleMsg&& from) noexcept
    : DoubleMsg() {
    *this = ::std::move(from);
  }

  inline DoubleMsg& operator=(const DoubleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleMsg& operator=(DoubleMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DoubleMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleMsg* internal_default_instance() {
    return reinterpret_cast<const DoubleMsg*>(
               &_DoubleMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(DoubleMsg& a, DoubleMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(DoubleMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DoubleMsg* New() const final {
    return CreateMaybeMessage<DoubleMsg>(nullptr);
  }

  DoubleMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DoubleMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DoubleMsg& from);
  void MergeFrom(const DoubleMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.DoubleMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDoubleMsgFieldNumber = 1,
  };
  // required double double_msg = 1;
  bool has_double_msg() const;
  void clear_double_msg();
  double double_msg() const;
  void set_double_msg(double value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DoubleMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double double_msg_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class BigDecimalMsg :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BigDecimalMsg) */ {
 public:
  BigDecimalMsg();
  virtual ~BigDecimalMsg();

  BigDecimalMsg(const BigDecimalMsg& from);
  BigDecimalMsg(BigDecimalMsg&& from) noexcept
    : BigDecimalMsg() {
    *this = ::std::move(from);
  }

  inline BigDecimalMsg& operator=(const BigDecimalMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BigDecimalMsg& operator=(BigDecimalMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BigDecimalMsg& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BigDecimalMsg* internal_default_instance() {
    return reinterpret_cast<const BigDecimalMsg*>(
               &_BigDecimalMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(BigDecimalMsg& a, BigDecimalMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BigDecimalMsg* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BigDecimalMsg* New() const final {
    return CreateMaybeMessage<BigDecimalMsg>(nullptr);
  }

  BigDecimalMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BigDecimalMsg>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BigDecimalMsg& from);
  void MergeFrom(const BigDecimalMsg& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BigDecimalMsg* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BigDecimalMsg";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBigdecimalMsgFieldNumber = 1,
  };
  // required bytes bigdecimal_msg = 1;
  bool has_bigdecimal_msg() const;
  void clear_bigdecimal_msg();
  const std::string& bigdecimal_msg() const;
  void set_bigdecimal_msg(const std::string& value);
  void set_bigdecimal_msg(std::string&& value);
  void set_bigdecimal_msg(const char* value);
  void set_bigdecimal_msg(const void* value, size_t size);
  std::string* mutable_bigdecimal_msg();
  std::string* release_bigdecimal_msg();
  void set_allocated_bigdecimal_msg(std::string* bigdecimal_msg);

  // @@protoc_insertion_point(class_scope:hbase.pb.BigDecimalMsg)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bigdecimal_msg_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class UUID :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.UUID) */ {
 public:
  UUID();
  virtual ~UUID();

  UUID(const UUID& from);
  UUID(UUID&& from) noexcept
    : UUID() {
    *this = ::std::move(from);
  }

  inline UUID& operator=(const UUID& from) {
    CopyFrom(from);
    return *this;
  }
  inline UUID& operator=(UUID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const UUID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UUID* internal_default_instance() {
    return reinterpret_cast<const UUID*>(
               &_UUID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(UUID& a, UUID& b) {
    a.Swap(&b);
  }
  inline void Swap(UUID* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline UUID* New() const final {
    return CreateMaybeMessage<UUID>(nullptr);
  }

  UUID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<UUID>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const UUID& from);
  void MergeFrom(const UUID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UUID* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.UUID";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeastSigBitsFieldNumber = 1,
    kMostSigBitsFieldNumber = 2,
  };
  // required uint64 least_sig_bits = 1;
  bool has_least_sig_bits() const;
  void clear_least_sig_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 least_sig_bits() const;
  void set_least_sig_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 most_sig_bits = 2;
  bool has_most_sig_bits() const;
  void clear_most_sig_bits();
  ::PROTOBUF_NAMESPACE_ID::uint64 most_sig_bits() const;
  void set_most_sig_bits(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.UUID)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 least_sig_bits_;
  ::PROTOBUF_NAMESPACE_ID::uint64 most_sig_bits_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class NamespaceDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.NamespaceDescriptor) */ {
 public:
  NamespaceDescriptor();
  virtual ~NamespaceDescriptor();

  NamespaceDescriptor(const NamespaceDescriptor& from);
  NamespaceDescriptor(NamespaceDescriptor&& from) noexcept
    : NamespaceDescriptor() {
    *this = ::std::move(from);
  }

  inline NamespaceDescriptor& operator=(const NamespaceDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamespaceDescriptor& operator=(NamespaceDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NamespaceDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NamespaceDescriptor* internal_default_instance() {
    return reinterpret_cast<const NamespaceDescriptor*>(
               &_NamespaceDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(NamespaceDescriptor& a, NamespaceDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(NamespaceDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NamespaceDescriptor* New() const final {
    return CreateMaybeMessage<NamespaceDescriptor>(nullptr);
  }

  NamespaceDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NamespaceDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NamespaceDescriptor& from);
  void MergeFrom(const NamespaceDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NamespaceDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.NamespaceDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigurationFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .hbase.pb.NameStringPair configuration = 2;
  int configuration_size() const;
  void clear_configuration();
  ::hbase::pb::NameStringPair* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();
  const ::hbase::pb::NameStringPair& configuration(int index) const;
  ::hbase::pb::NameStringPair* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;

  // required bytes name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const void* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // @@protoc_insertion_point(class_scope:hbase.pb.NamespaceDescriptor)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class VersionInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.VersionInfo) */ {
 public:
  VersionInfo();
  virtual ~VersionInfo();

  VersionInfo(const VersionInfo& from);
  VersionInfo(VersionInfo&& from) noexcept
    : VersionInfo() {
    *this = ::std::move(from);
  }

  inline VersionInfo& operator=(const VersionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VersionInfo& operator=(VersionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VersionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionInfo* internal_default_instance() {
    return reinterpret_cast<const VersionInfo*>(
               &_VersionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(VersionInfo& a, VersionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(VersionInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VersionInfo* New() const final {
    return CreateMaybeMessage<VersionInfo>(nullptr);
  }

  VersionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VersionInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VersionInfo& from);
  void MergeFrom(const VersionInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.VersionInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kUrlFieldNumber = 2,
    kRevisionFieldNumber = 3,
    kUserFieldNumber = 4,
    kDateFieldNumber = 5,
    kSrcChecksumFieldNumber = 6,
    kVersionMajorFieldNumber = 7,
    kVersionMinorFieldNumber = 8,
  };
  // required string version = 1;
  bool has_version() const;
  void clear_version();
  const std::string& version() const;
  void set_version(const std::string& value);
  void set_version(std::string&& value);
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  std::string* mutable_version();
  std::string* release_version();
  void set_allocated_version(std::string* version);

  // required string url = 2;
  bool has_url() const;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);

  // required string revision = 3;
  bool has_revision() const;
  void clear_revision();
  const std::string& revision() const;
  void set_revision(const std::string& value);
  void set_revision(std::string&& value);
  void set_revision(const char* value);
  void set_revision(const char* value, size_t size);
  std::string* mutable_revision();
  std::string* release_revision();
  void set_allocated_revision(std::string* revision);

  // required string user = 4;
  bool has_user() const;
  void clear_user();
  const std::string& user() const;
  void set_user(const std::string& value);
  void set_user(std::string&& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  std::string* mutable_user();
  std::string* release_user();
  void set_allocated_user(std::string* user);

  // required string date = 5;
  bool has_date() const;
  void clear_date();
  const std::string& date() const;
  void set_date(const std::string& value);
  void set_date(std::string&& value);
  void set_date(const char* value);
  void set_date(const char* value, size_t size);
  std::string* mutable_date();
  std::string* release_date();
  void set_allocated_date(std::string* date);

  // required string src_checksum = 6;
  bool has_src_checksum() const;
  void clear_src_checksum();
  const std::string& src_checksum() const;
  void set_src_checksum(const std::string& value);
  void set_src_checksum(std::string&& value);
  void set_src_checksum(const char* value);
  void set_src_checksum(const char* value, size_t size);
  std::string* mutable_src_checksum();
  std::string* release_src_checksum();
  void set_allocated_src_checksum(std::string* src_checksum);

  // optional uint32 version_major = 7;
  bool has_version_major() const;
  void clear_version_major();
  ::PROTOBUF_NAMESPACE_ID::uint32 version_major() const;
  void set_version_major(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 version_minor = 8;
  bool has_version_minor() const;
  void clear_version_minor();
  ::PROTOBUF_NAMESPACE_ID::uint32 version_minor() const;
  void set_version_minor(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.VersionInfo)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr revision_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_checksum_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_major_;
  ::PROTOBUF_NAMESPACE_ID::uint32 version_minor_;
  friend struct ::TableStruct_HBase_2eproto;
};
// -------------------------------------------------------------------

class RegionServerInfo :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionServerInfo) */ {
 public:
  RegionServerInfo();
  virtual ~RegionServerInfo();

  RegionServerInfo(const RegionServerInfo& from);
  RegionServerInfo(RegionServerInfo&& from) noexcept
    : RegionServerInfo() {
    *this = ::std::move(from);
  }

  inline RegionServerInfo& operator=(const RegionServerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionServerInfo& operator=(RegionServerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionServerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionServerInfo* internal_default_instance() {
    return reinterpret_cast<const RegionServerInfo*>(
               &_RegionServerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(RegionServerInfo& a, RegionServerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionServerInfo* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionServerInfo* New() const final {
    return CreateMaybeMessage<RegionServerInfo>(nullptr);
  }

  RegionServerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionServerInfo>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionServerInfo& from);
  void MergeFrom(const RegionServerInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionServerInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionServerInfo";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_HBase_2eproto);
    return ::descriptor_table_HBase_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionInfoFieldNumber = 2,
    kInfoPortFieldNumber = 1,
  };
  // optional .hbase.pb.VersionInfo version_info = 2;
  bool has_version_info() const;
  void clear_version_info();
  const ::hbase::pb::VersionInfo& version_info() const;
  ::hbase::pb::VersionInfo* release_version_info();
  ::hbase::pb::VersionInfo* mutable_version_info();
  void set_allocated_version_info(::hbase::pb::VersionInfo* version_info);

  // optional int32 infoPort = 1;
  bool has_infoport() const;
  void clear_infoport();
  ::PROTOBUF_NAMESPACE_ID::int32 infoport() const;
  void set_infoport(::PROTOBUF_NAMESPACE_ID::int32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionServerInfo)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::VersionInfo* version_info_;
  ::PROTOBUF_NAMESPACE_ID::int32 infoport_;
  friend struct ::TableStruct_HBase_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TableName

// required bytes namespace = 1;
inline bool TableName::has_namespace_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableName::clear_namespace_() {
  namespace__.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TableName::namespace_() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableName.namespace)
  return namespace__.GetNoArena();
}
inline void TableName::set_namespace_(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.TableName.namespace)
}
inline void TableName::set_namespace_(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.TableName.namespace)
}
inline void TableName::set_namespace_(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.TableName.namespace)
}
inline void TableName::set_namespace_(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  namespace__.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.TableName.namespace)
}
inline std::string* TableName::mutable_namespace_() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableName.namespace)
  return namespace__.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TableName::release_namespace_() {
  // @@protoc_insertion_point(field_release:hbase.pb.TableName.namespace)
  if (!has_namespace_()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return namespace__.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TableName::set_allocated_namespace_(std::string* namespace_) {
  if (namespace_ != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  namespace__.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), namespace_);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TableName.namespace)
}

// required bytes qualifier = 2;
inline bool TableName::has_qualifier() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableName::clear_qualifier() {
  qualifier_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TableName::qualifier() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableName.qualifier)
  return qualifier_.GetNoArena();
}
inline void TableName::set_qualifier(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.TableName.qualifier)
}
inline void TableName::set_qualifier(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.TableName.qualifier)
}
inline void TableName::set_qualifier(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.TableName.qualifier)
}
inline void TableName::set_qualifier(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  qualifier_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.TableName.qualifier)
}
inline std::string* TableName::mutable_qualifier() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableName.qualifier)
  return qualifier_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* TableName::release_qualifier() {
  // @@protoc_insertion_point(field_release:hbase.pb.TableName.qualifier)
  if (!has_qualifier()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return qualifier_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void TableName::set_allocated_qualifier(std::string* qualifier) {
  if (qualifier != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  qualifier_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), qualifier);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TableName.qualifier)
}

// -------------------------------------------------------------------

// TableSchema

// optional .hbase.pb.TableName table_name = 1;
inline bool TableSchema::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableSchema::clear_table_name() {
  if (table_name_ != nullptr) table_name_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::TableName& TableSchema::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.TableSchema.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* TableSchema::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.TableSchema.table_name)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* TableSchema::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableSchema.table_name)
  return table_name_;
}
inline void TableSchema::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_name_;
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TableSchema.table_name)
}

// repeated .hbase.pb.BytesBytesPair attributes = 2;
inline int TableSchema::attributes_size() const {
  return attributes_.size();
}
inline void TableSchema::clear_attributes() {
  attributes_.Clear();
}
inline ::hbase::pb::BytesBytesPair* TableSchema::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableSchema.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
TableSchema::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TableSchema.attributes)
  return &attributes_;
}
inline const ::hbase::pb::BytesBytesPair& TableSchema::attributes(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableSchema.attributes)
  return attributes_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* TableSchema::add_attributes() {
  // @@protoc_insertion_point(field_add:hbase.pb.TableSchema.attributes)
  return attributes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
TableSchema::attributes() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TableSchema.attributes)
  return attributes_;
}

// repeated .hbase.pb.ColumnFamilySchema column_families = 3;
inline int TableSchema::column_families_size() const {
  return column_families_.size();
}
inline void TableSchema::clear_column_families() {
  column_families_.Clear();
}
inline ::hbase::pb::ColumnFamilySchema* TableSchema::mutable_column_families(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableSchema.column_families)
  return column_families_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >*
TableSchema::mutable_column_families() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TableSchema.column_families)
  return &column_families_;
}
inline const ::hbase::pb::ColumnFamilySchema& TableSchema::column_families(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableSchema.column_families)
  return column_families_.Get(index);
}
inline ::hbase::pb::ColumnFamilySchema* TableSchema::add_column_families() {
  // @@protoc_insertion_point(field_add:hbase.pb.TableSchema.column_families)
  return column_families_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ColumnFamilySchema >&
TableSchema::column_families() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TableSchema.column_families)
  return column_families_;
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int TableSchema::configuration_size() const {
  return configuration_.size();
}
inline void TableSchema::clear_configuration() {
  configuration_.Clear();
}
inline ::hbase::pb::NameStringPair* TableSchema::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableSchema.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
TableSchema::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TableSchema.configuration)
  return &configuration_;
}
inline const ::hbase::pb::NameStringPair& TableSchema::configuration(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableSchema.configuration)
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* TableSchema::add_configuration() {
  // @@protoc_insertion_point(field_add:hbase.pb.TableSchema.configuration)
  return configuration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
TableSchema::configuration() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TableSchema.configuration)
  return configuration_;
}

// -------------------------------------------------------------------

// TableState

// required .hbase.pb.TableState.State state = 1;
inline bool TableState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::hbase::pb::TableState_State TableState::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableState.state)
  return static_cast< ::hbase::pb::TableState_State >(state_);
}
inline void TableState::set_state(::hbase::pb::TableState_State value) {
  assert(::hbase::pb::TableState_State_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TableState.state)
}

// -------------------------------------------------------------------

// ColumnFamilySchema

// required bytes name = 1;
inline bool ColumnFamilySchema::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnFamilySchema::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnFamilySchema::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnFamilySchema.name)
  return name_.GetNoArena();
}
inline void ColumnFamilySchema::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnFamilySchema.name)
}
inline void ColumnFamilySchema::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnFamilySchema.name)
}
inline void ColumnFamilySchema::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnFamilySchema.name)
}
inline void ColumnFamilySchema::set_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnFamilySchema.name)
}
inline std::string* ColumnFamilySchema::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnFamilySchema.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnFamilySchema::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnFamilySchema.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnFamilySchema::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnFamilySchema.name)
}

// repeated .hbase.pb.BytesBytesPair attributes = 2;
inline int ColumnFamilySchema::attributes_size() const {
  return attributes_.size();
}
inline void ColumnFamilySchema::clear_attributes() {
  attributes_.Clear();
}
inline ::hbase::pb::BytesBytesPair* ColumnFamilySchema::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnFamilySchema.attributes)
  return attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
ColumnFamilySchema::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ColumnFamilySchema.attributes)
  return &attributes_;
}
inline const ::hbase::pb::BytesBytesPair& ColumnFamilySchema::attributes(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnFamilySchema.attributes)
  return attributes_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* ColumnFamilySchema::add_attributes() {
  // @@protoc_insertion_point(field_add:hbase.pb.ColumnFamilySchema.attributes)
  return attributes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
ColumnFamilySchema::attributes() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ColumnFamilySchema.attributes)
  return attributes_;
}

// repeated .hbase.pb.NameStringPair configuration = 3;
inline int ColumnFamilySchema::configuration_size() const {
  return configuration_.size();
}
inline void ColumnFamilySchema::clear_configuration() {
  configuration_.Clear();
}
inline ::hbase::pb::NameStringPair* ColumnFamilySchema::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnFamilySchema.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ColumnFamilySchema::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ColumnFamilySchema.configuration)
  return &configuration_;
}
inline const ::hbase::pb::NameStringPair& ColumnFamilySchema::configuration(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnFamilySchema.configuration)
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ColumnFamilySchema::add_configuration() {
  // @@protoc_insertion_point(field_add:hbase.pb.ColumnFamilySchema.configuration)
  return configuration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ColumnFamilySchema::configuration() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ColumnFamilySchema.configuration)
  return configuration_;
}

// -------------------------------------------------------------------

// RegionInfo

// required uint64 region_id = 1;
inline bool RegionInfo::has_region_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegionInfo::clear_region_id() {
  region_id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionInfo::region_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.region_id)
  return region_id_;
}
inline void RegionInfo::set_region_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  region_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.region_id)
}

// required .hbase.pb.TableName table_name = 2;
inline bool RegionInfo::has_table_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionInfo::clear_table_name() {
  if (table_name_ != nullptr) table_name_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::TableName& RegionInfo::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* RegionInfo::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionInfo.table_name)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* RegionInfo::mutable_table_name() {
  _has_bits_[0] |= 0x00000004u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionInfo.table_name)
  return table_name_;
}
inline void RegionInfo::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete table_name_;
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionInfo.table_name)
}

// optional bytes start_key = 3;
inline bool RegionInfo::has_start_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionInfo::clear_start_key() {
  start_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionInfo::start_key() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.start_key)
  return start_key_.GetNoArena();
}
inline void RegionInfo::set_start_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.start_key)
}
inline void RegionInfo::set_start_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionInfo.start_key)
}
inline void RegionInfo::set_start_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionInfo.start_key)
}
inline void RegionInfo::set_start_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  start_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionInfo.start_key)
}
inline std::string* RegionInfo::mutable_start_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionInfo.start_key)
  return start_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionInfo::release_start_key() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionInfo.start_key)
  if (!has_start_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionInfo::set_allocated_start_key(std::string* start_key) {
  if (start_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_key);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionInfo.start_key)
}

// optional bytes end_key = 4;
inline bool RegionInfo::has_end_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionInfo::clear_end_key() {
  end_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionInfo::end_key() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.end_key)
  return end_key_.GetNoArena();
}
inline void RegionInfo::set_end_key(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.end_key)
}
inline void RegionInfo::set_end_key(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionInfo.end_key)
}
inline void RegionInfo::set_end_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionInfo.end_key)
}
inline void RegionInfo::set_end_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  end_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionInfo.end_key)
}
inline std::string* RegionInfo::mutable_end_key() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionInfo.end_key)
  return end_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionInfo::release_end_key() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionInfo.end_key)
  if (!has_end_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return end_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionInfo::set_allocated_end_key(std::string* end_key) {
  if (end_key != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  end_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_key);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionInfo.end_key)
}

// optional bool offline = 5;
inline bool RegionInfo::has_offline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionInfo::clear_offline() {
  offline_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool RegionInfo::offline() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.offline)
  return offline_;
}
inline void RegionInfo::set_offline(bool value) {
  _has_bits_[0] |= 0x00000010u;
  offline_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.offline)
}

// optional bool split = 6;
inline bool RegionInfo::has_split() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionInfo::clear_split() {
  split_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool RegionInfo::split() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.split)
  return split_;
}
inline void RegionInfo::set_split(bool value) {
  _has_bits_[0] |= 0x00000020u;
  split_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.split)
}

// optional int32 replica_id = 7 [default = 0];
inline bool RegionInfo::has_replica_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RegionInfo::clear_replica_id() {
  replica_id_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionInfo::replica_id() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionInfo.replica_id)
  return replica_id_;
}
inline void RegionInfo::set_replica_id(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  replica_id_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionInfo.replica_id)
}

// -------------------------------------------------------------------

// FavoredNodes

// repeated .hbase.pb.ServerName favored_node = 1;
inline int FavoredNodes::favored_node_size() const {
  return favored_node_.size();
}
inline void FavoredNodes::clear_favored_node() {
  favored_node_.Clear();
}
inline ::hbase::pb::ServerName* FavoredNodes::mutable_favored_node(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FavoredNodes.favored_node)
  return favored_node_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >*
FavoredNodes::mutable_favored_node() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FavoredNodes.favored_node)
  return &favored_node_;
}
inline const ::hbase::pb::ServerName& FavoredNodes::favored_node(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FavoredNodes.favored_node)
  return favored_node_.Get(index);
}
inline ::hbase::pb::ServerName* FavoredNodes::add_favored_node() {
  // @@protoc_insertion_point(field_add:hbase.pb.FavoredNodes.favored_node)
  return favored_node_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::ServerName >&
FavoredNodes::favored_node() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FavoredNodes.favored_node)
  return favored_node_;
}

// -------------------------------------------------------------------

// RegionSpecifier

// required .hbase.pb.RegionSpecifier.RegionSpecifierType type = 1;
inline bool RegionSpecifier::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionSpecifier::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::RegionSpecifier_RegionSpecifierType RegionSpecifier::type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionSpecifier.type)
  return static_cast< ::hbase::pb::RegionSpecifier_RegionSpecifierType >(type_);
}
inline void RegionSpecifier::set_type(::hbase::pb::RegionSpecifier_RegionSpecifierType value) {
  assert(::hbase::pb::RegionSpecifier_RegionSpecifierType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionSpecifier.type)
}

// required bytes value = 2;
inline bool RegionSpecifier::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionSpecifier::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionSpecifier::value() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionSpecifier.value)
  return value_.GetNoArena();
}
inline void RegionSpecifier::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionSpecifier.value)
}
inline void RegionSpecifier::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionSpecifier.value)
}
inline void RegionSpecifier::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionSpecifier.value)
}
inline void RegionSpecifier::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionSpecifier.value)
}
inline std::string* RegionSpecifier::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionSpecifier.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionSpecifier::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionSpecifier.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionSpecifier::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionSpecifier.value)
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 from = 1;
inline bool TimeRange::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeRange::clear_from() {
  from_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TimeRange::from() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimeRange.from)
  return from_;
}
inline void TimeRange::set_from(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  from_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimeRange.from)
}

// optional uint64 to = 2;
inline bool TimeRange::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeRange::clear_to() {
  to_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TimeRange::to() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimeRange.to)
  return to_;
}
inline void TimeRange::set_to(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  to_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimeRange.to)
}

// -------------------------------------------------------------------

// ColumnFamilyTimeRange

// required bytes column_family = 1;
inline bool ColumnFamilyTimeRange::has_column_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnFamilyTimeRange::clear_column_family() {
  column_family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ColumnFamilyTimeRange::column_family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnFamilyTimeRange.column_family)
  return column_family_.GetNoArena();
}
inline void ColumnFamilyTimeRange::set_column_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ColumnFamilyTimeRange.column_family)
}
inline void ColumnFamilyTimeRange::set_column_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ColumnFamilyTimeRange.column_family)
}
inline void ColumnFamilyTimeRange::set_column_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ColumnFamilyTimeRange.column_family)
}
inline void ColumnFamilyTimeRange::set_column_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  column_family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ColumnFamilyTimeRange.column_family)
}
inline std::string* ColumnFamilyTimeRange::mutable_column_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnFamilyTimeRange.column_family)
  return column_family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ColumnFamilyTimeRange::release_column_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnFamilyTimeRange.column_family)
  if (!has_column_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return column_family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnFamilyTimeRange::set_allocated_column_family(std::string* column_family) {
  if (column_family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  column_family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), column_family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnFamilyTimeRange.column_family)
}

// required .hbase.pb.TimeRange time_range = 2;
inline bool ColumnFamilyTimeRange::has_time_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnFamilyTimeRange::clear_time_range() {
  if (time_range_ != nullptr) time_range_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::TimeRange& ColumnFamilyTimeRange::time_range() const {
  const ::hbase::pb::TimeRange* p = time_range_;
  // @@protoc_insertion_point(field_get:hbase.pb.ColumnFamilyTimeRange.time_range)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimeRange*>(
      &::hbase::pb::_TimeRange_default_instance_);
}
inline ::hbase::pb::TimeRange* ColumnFamilyTimeRange::release_time_range() {
  // @@protoc_insertion_point(field_release:hbase.pb.ColumnFamilyTimeRange.time_range)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::TimeRange* temp = time_range_;
  time_range_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimeRange* ColumnFamilyTimeRange::mutable_time_range() {
  _has_bits_[0] |= 0x00000002u;
  if (time_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimeRange>(GetArenaNoVirtual());
    time_range_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ColumnFamilyTimeRange.time_range)
  return time_range_;
}
inline void ColumnFamilyTimeRange::set_allocated_time_range(::hbase::pb::TimeRange* time_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_range_;
  }
  if (time_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time_range, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  time_range_ = time_range;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ColumnFamilyTimeRange.time_range)
}

// -------------------------------------------------------------------

// ServerName

// required string host_name = 1;
inline bool ServerName::has_host_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerName::clear_host_name() {
  host_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ServerName::host_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerName.host_name)
  return host_name_.GetNoArena();
}
inline void ServerName::set_host_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ServerName.host_name)
}
inline void ServerName::set_host_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  host_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ServerName.host_name)
}
inline void ServerName::set_host_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  host_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ServerName.host_name)
}
inline void ServerName::set_host_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  host_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ServerName.host_name)
}
inline std::string* ServerName::mutable_host_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ServerName.host_name)
  return host_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ServerName::release_host_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.ServerName.host_name)
  if (!has_host_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return host_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ServerName::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), host_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ServerName.host_name)
}

// optional uint32 port = 2;
inline bool ServerName::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerName::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 ServerName::port() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerName.port)
  return port_;
}
inline void ServerName::set_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  port_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerName.port)
}

// optional uint64 start_code = 3;
inline bool ServerName::has_start_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerName::clear_start_code() {
  start_code_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ServerName::start_code() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ServerName.start_code)
  return start_code_;
}
inline void ServerName::set_start_code(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  start_code_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ServerName.start_code)
}

// -------------------------------------------------------------------

// Coprocessor

// required string name = 1;
inline bool Coprocessor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coprocessor::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Coprocessor::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Coprocessor.name)
  return name_.GetNoArena();
}
inline void Coprocessor::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.Coprocessor.name)
}
inline void Coprocessor::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.Coprocessor.name)
}
inline void Coprocessor::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.Coprocessor.name)
}
inline void Coprocessor::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.Coprocessor.name)
}
inline std::string* Coprocessor::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.Coprocessor.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Coprocessor::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.Coprocessor.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Coprocessor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Coprocessor.name)
}

// -------------------------------------------------------------------

// NameStringPair

// required string name = 1;
inline bool NameStringPair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameStringPair::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NameStringPair::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameStringPair.name)
  return name_.GetNoArena();
}
inline void NameStringPair::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NameStringPair.name)
}
inline void NameStringPair::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NameStringPair.name)
}
inline void NameStringPair::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NameStringPair.name)
}
inline void NameStringPair::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NameStringPair.name)
}
inline std::string* NameStringPair::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NameStringPair.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NameStringPair::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.NameStringPair.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NameStringPair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NameStringPair.name)
}

// required string value = 2;
inline bool NameStringPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameStringPair::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NameStringPair::value() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameStringPair.value)
  return value_.GetNoArena();
}
inline void NameStringPair::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NameStringPair.value)
}
inline void NameStringPair::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NameStringPair.value)
}
inline void NameStringPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NameStringPair.value)
}
inline void NameStringPair::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NameStringPair.value)
}
inline std::string* NameStringPair::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NameStringPair.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NameStringPair::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.NameStringPair.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NameStringPair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NameStringPair.value)
}

// -------------------------------------------------------------------

// NameBytesPair

// required string name = 1;
inline bool NameBytesPair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameBytesPair::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NameBytesPair::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameBytesPair.name)
  return name_.GetNoArena();
}
inline void NameBytesPair::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NameBytesPair.name)
}
inline void NameBytesPair::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NameBytesPair.name)
}
inline void NameBytesPair::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NameBytesPair.name)
}
inline void NameBytesPair::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NameBytesPair.name)
}
inline std::string* NameBytesPair::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NameBytesPair.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NameBytesPair::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.NameBytesPair.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NameBytesPair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NameBytesPair.name)
}

// optional bytes value = 2;
inline bool NameBytesPair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameBytesPair::clear_value() {
  value_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NameBytesPair::value() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameBytesPair.value)
  return value_.GetNoArena();
}
inline void NameBytesPair::set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NameBytesPair.value)
}
inline void NameBytesPair::set_value(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NameBytesPair.value)
}
inline void NameBytesPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NameBytesPair.value)
}
inline void NameBytesPair::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  value_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NameBytesPair.value)
}
inline std::string* NameBytesPair::mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NameBytesPair.value)
  return value_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NameBytesPair::release_value() {
  // @@protoc_insertion_point(field_release:hbase.pb.NameBytesPair.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return value_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NameBytesPair::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NameBytesPair.value)
}

// -------------------------------------------------------------------

// BytesBytesPair

// required bytes first = 1;
inline bool BytesBytesPair::has_first() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BytesBytesPair::clear_first() {
  first_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BytesBytesPair::first() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BytesBytesPair.first)
  return first_.GetNoArena();
}
inline void BytesBytesPair::set_first(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BytesBytesPair.first)
}
inline void BytesBytesPair::set_first(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  first_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BytesBytesPair.first)
}
inline void BytesBytesPair::set_first(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  first_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BytesBytesPair.first)
}
inline void BytesBytesPair::set_first(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  first_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BytesBytesPair.first)
}
inline std::string* BytesBytesPair::mutable_first() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BytesBytesPair.first)
  return first_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BytesBytesPair::release_first() {
  // @@protoc_insertion_point(field_release:hbase.pb.BytesBytesPair.first)
  if (!has_first()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return first_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BytesBytesPair::set_allocated_first(std::string* first) {
  if (first != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), first);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BytesBytesPair.first)
}

// required bytes second = 2;
inline bool BytesBytesPair::has_second() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BytesBytesPair::clear_second() {
  second_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BytesBytesPair::second() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BytesBytesPair.second)
  return second_.GetNoArena();
}
inline void BytesBytesPair::set_second(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  second_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BytesBytesPair.second)
}
inline void BytesBytesPair::set_second(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  second_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BytesBytesPair.second)
}
inline void BytesBytesPair::set_second(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  second_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BytesBytesPair.second)
}
inline void BytesBytesPair::set_second(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  second_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BytesBytesPair.second)
}
inline std::string* BytesBytesPair::mutable_second() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BytesBytesPair.second)
  return second_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BytesBytesPair::release_second() {
  // @@protoc_insertion_point(field_release:hbase.pb.BytesBytesPair.second)
  if (!has_second()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return second_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BytesBytesPair::set_allocated_second(std::string* second) {
  if (second != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  second_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), second);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BytesBytesPair.second)
}

// -------------------------------------------------------------------

// NameInt64Pair

// optional string name = 1;
inline bool NameInt64Pair::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NameInt64Pair::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NameInt64Pair::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameInt64Pair.name)
  return name_.GetNoArena();
}
inline void NameInt64Pair::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NameInt64Pair.name)
}
inline void NameInt64Pair::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NameInt64Pair.name)
}
inline void NameInt64Pair::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NameInt64Pair.name)
}
inline void NameInt64Pair::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NameInt64Pair.name)
}
inline std::string* NameInt64Pair::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NameInt64Pair.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NameInt64Pair::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.NameInt64Pair.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NameInt64Pair::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NameInt64Pair.name)
}

// optional int64 value = 2;
inline bool NameInt64Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NameInt64Pair::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NameInt64Pair::value() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NameInt64Pair.value)
  return value_;
}
inline void NameInt64Pair::set_value(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  value_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.NameInt64Pair.value)
}

// -------------------------------------------------------------------

// SnapshotDescription

// required string name = 1;
inline bool SnapshotDescription::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnapshotDescription::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SnapshotDescription::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.name)
  return name_.GetNoArena();
}
inline void SnapshotDescription::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.name)
}
inline void SnapshotDescription::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.SnapshotDescription.name)
}
inline void SnapshotDescription::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.SnapshotDescription.name)
}
inline void SnapshotDescription::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.SnapshotDescription.name)
}
inline std::string* SnapshotDescription::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.SnapshotDescription.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDescription::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.SnapshotDescription.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDescription::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SnapshotDescription.name)
}

// optional string table = 2;
inline bool SnapshotDescription::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnapshotDescription::clear_table() {
  table_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SnapshotDescription::table() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.table)
  return table_.GetNoArena();
}
inline void SnapshotDescription::set_table(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.table)
}
inline void SnapshotDescription::set_table(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  table_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.SnapshotDescription.table)
}
inline void SnapshotDescription::set_table(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.SnapshotDescription.table)
}
inline void SnapshotDescription::set_table(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  table_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.SnapshotDescription.table)
}
inline std::string* SnapshotDescription::mutable_table() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.SnapshotDescription.table)
  return table_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDescription::release_table() {
  // @@protoc_insertion_point(field_release:hbase.pb.SnapshotDescription.table)
  if (!has_table()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDescription::set_allocated_table(std::string* table) {
  if (table != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SnapshotDescription.table)
}

// optional int64 creation_time = 3 [default = 0];
inline bool SnapshotDescription::has_creation_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnapshotDescription::clear_creation_time() {
  creation_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 SnapshotDescription::creation_time() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.creation_time)
  return creation_time_;
}
inline void SnapshotDescription::set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000008u;
  creation_time_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.creation_time)
}

// optional .hbase.pb.SnapshotDescription.Type type = 4 [default = FLUSH];
inline bool SnapshotDescription::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SnapshotDescription::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hbase::pb::SnapshotDescription_Type SnapshotDescription::type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.type)
  return static_cast< ::hbase::pb::SnapshotDescription_Type >(type_);
}
inline void SnapshotDescription::set_type(::hbase::pb::SnapshotDescription_Type value) {
  assert(::hbase::pb::SnapshotDescription_Type_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.type)
}

// optional int32 version = 5;
inline bool SnapshotDescription::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnapshotDescription::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 SnapshotDescription::version() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.version)
  return version_;
}
inline void SnapshotDescription::set_version(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.version)
}

// optional string owner = 6;
inline bool SnapshotDescription::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnapshotDescription::clear_owner() {
  owner_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SnapshotDescription::owner() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SnapshotDescription.owner)
  return owner_.GetNoArena();
}
inline void SnapshotDescription::set_owner(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.SnapshotDescription.owner)
}
inline void SnapshotDescription::set_owner(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.SnapshotDescription.owner)
}
inline void SnapshotDescription::set_owner(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.SnapshotDescription.owner)
}
inline void SnapshotDescription::set_owner(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  owner_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.SnapshotDescription.owner)
}
inline std::string* SnapshotDescription::mutable_owner() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.SnapshotDescription.owner)
  return owner_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* SnapshotDescription::release_owner() {
  // @@protoc_insertion_point(field_release:hbase.pb.SnapshotDescription.owner)
  if (!has_owner()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return owner_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void SnapshotDescription::set_allocated_owner(std::string* owner) {
  if (owner != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  owner_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), owner);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SnapshotDescription.owner)
}

// -------------------------------------------------------------------

// ProcedureDescription

// required string signature = 1;
inline bool ProcedureDescription::has_signature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcedureDescription::clear_signature() {
  signature_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ProcedureDescription::signature() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ProcedureDescription.signature)
  return signature_.GetNoArena();
}
inline void ProcedureDescription::set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ProcedureDescription.signature)
}
inline void ProcedureDescription::set_signature(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ProcedureDescription.signature)
}
inline void ProcedureDescription::set_signature(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ProcedureDescription.signature)
}
inline void ProcedureDescription::set_signature(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  signature_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ProcedureDescription.signature)
}
inline std::string* ProcedureDescription::mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ProcedureDescription.signature)
  return signature_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ProcedureDescription::release_signature() {
  // @@protoc_insertion_point(field_release:hbase.pb.ProcedureDescription.signature)
  if (!has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return signature_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureDescription::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ProcedureDescription.signature)
}

// optional string instance = 2;
inline bool ProcedureDescription::has_instance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcedureDescription::clear_instance() {
  instance_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ProcedureDescription::instance() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ProcedureDescription.instance)
  return instance_.GetNoArena();
}
inline void ProcedureDescription::set_instance(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ProcedureDescription.instance)
}
inline void ProcedureDescription::set_instance(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  instance_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ProcedureDescription.instance)
}
inline void ProcedureDescription::set_instance(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  instance_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ProcedureDescription.instance)
}
inline void ProcedureDescription::set_instance(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  instance_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ProcedureDescription.instance)
}
inline std::string* ProcedureDescription::mutable_instance() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ProcedureDescription.instance)
  return instance_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ProcedureDescription::release_instance() {
  // @@protoc_insertion_point(field_release:hbase.pb.ProcedureDescription.instance)
  if (!has_instance()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return instance_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ProcedureDescription::set_allocated_instance(std::string* instance) {
  if (instance != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  instance_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instance);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ProcedureDescription.instance)
}

// optional int64 creation_time = 3 [default = 0];
inline bool ProcedureDescription::has_creation_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcedureDescription::clear_creation_time() {
  creation_time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ProcedureDescription::creation_time() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ProcedureDescription.creation_time)
  return creation_time_;
}
inline void ProcedureDescription::set_creation_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  creation_time_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ProcedureDescription.creation_time)
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int ProcedureDescription::configuration_size() const {
  return configuration_.size();
}
inline void ProcedureDescription::clear_configuration() {
  configuration_.Clear();
}
inline ::hbase::pb::NameStringPair* ProcedureDescription::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ProcedureDescription.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ProcedureDescription::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ProcedureDescription.configuration)
  return &configuration_;
}
inline const ::hbase::pb::NameStringPair& ProcedureDescription::configuration(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ProcedureDescription.configuration)
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ProcedureDescription::add_configuration() {
  // @@protoc_insertion_point(field_add:hbase.pb.ProcedureDescription.configuration)
  return configuration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ProcedureDescription::configuration() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ProcedureDescription.configuration)
  return configuration_;
}

// -------------------------------------------------------------------

// EmptyMsg

// -------------------------------------------------------------------

// LongMsg

// required int64 long_msg = 1;
inline bool LongMsg::has_long_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LongMsg::clear_long_msg() {
  long_msg_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LongMsg::long_msg() const {
  // @@protoc_insertion_point(field_get:hbase.pb.LongMsg.long_msg)
  return long_msg_;
}
inline void LongMsg::set_long_msg(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  long_msg_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.LongMsg.long_msg)
}

// -------------------------------------------------------------------

// DoubleMsg

// required double double_msg = 1;
inline bool DoubleMsg::has_double_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleMsg::clear_double_msg() {
  double_msg_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DoubleMsg::double_msg() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DoubleMsg.double_msg)
  return double_msg_;
}
inline void DoubleMsg::set_double_msg(double value) {
  _has_bits_[0] |= 0x00000001u;
  double_msg_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.DoubleMsg.double_msg)
}

// -------------------------------------------------------------------

// BigDecimalMsg

// required bytes bigdecimal_msg = 1;
inline bool BigDecimalMsg::has_bigdecimal_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BigDecimalMsg::clear_bigdecimal_msg() {
  bigdecimal_msg_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BigDecimalMsg::bigdecimal_msg() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BigDecimalMsg.bigdecimal_msg)
  return bigdecimal_msg_.GetNoArena();
}
inline void BigDecimalMsg::set_bigdecimal_msg(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  bigdecimal_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BigDecimalMsg.bigdecimal_msg)
}
inline void BigDecimalMsg::set_bigdecimal_msg(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  bigdecimal_msg_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BigDecimalMsg.bigdecimal_msg)
}
inline void BigDecimalMsg::set_bigdecimal_msg(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  bigdecimal_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BigDecimalMsg.bigdecimal_msg)
}
inline void BigDecimalMsg::set_bigdecimal_msg(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  bigdecimal_msg_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BigDecimalMsg.bigdecimal_msg)
}
inline std::string* BigDecimalMsg::mutable_bigdecimal_msg() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BigDecimalMsg.bigdecimal_msg)
  return bigdecimal_msg_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BigDecimalMsg::release_bigdecimal_msg() {
  // @@protoc_insertion_point(field_release:hbase.pb.BigDecimalMsg.bigdecimal_msg)
  if (!has_bigdecimal_msg()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return bigdecimal_msg_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BigDecimalMsg::set_allocated_bigdecimal_msg(std::string* bigdecimal_msg) {
  if (bigdecimal_msg != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bigdecimal_msg_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bigdecimal_msg);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BigDecimalMsg.bigdecimal_msg)
}

// -------------------------------------------------------------------

// UUID

// required uint64 least_sig_bits = 1;
inline bool UUID::has_least_sig_bits() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UUID::clear_least_sig_bits() {
  least_sig_bits_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UUID::least_sig_bits() const {
  // @@protoc_insertion_point(field_get:hbase.pb.UUID.least_sig_bits)
  return least_sig_bits_;
}
inline void UUID::set_least_sig_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  least_sig_bits_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.UUID.least_sig_bits)
}

// required uint64 most_sig_bits = 2;
inline bool UUID::has_most_sig_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UUID::clear_most_sig_bits() {
  most_sig_bits_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 UUID::most_sig_bits() const {
  // @@protoc_insertion_point(field_get:hbase.pb.UUID.most_sig_bits)
  return most_sig_bits_;
}
inline void UUID::set_most_sig_bits(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  most_sig_bits_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.UUID.most_sig_bits)
}

// -------------------------------------------------------------------

// NamespaceDescriptor

// required bytes name = 1;
inline bool NamespaceDescriptor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NamespaceDescriptor::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NamespaceDescriptor::name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.NamespaceDescriptor.name)
  return name_.GetNoArena();
}
inline void NamespaceDescriptor::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.NamespaceDescriptor.name)
}
inline void NamespaceDescriptor::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.NamespaceDescriptor.name)
}
inline void NamespaceDescriptor::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.NamespaceDescriptor.name)
}
inline void NamespaceDescriptor::set_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.NamespaceDescriptor.name)
}
inline std::string* NamespaceDescriptor::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.NamespaceDescriptor.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* NamespaceDescriptor::release_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.NamespaceDescriptor.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void NamespaceDescriptor::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.NamespaceDescriptor.name)
}

// repeated .hbase.pb.NameStringPair configuration = 2;
inline int NamespaceDescriptor::configuration_size() const {
  return configuration_.size();
}
inline void NamespaceDescriptor::clear_configuration() {
  configuration_.Clear();
}
inline ::hbase::pb::NameStringPair* NamespaceDescriptor::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.NamespaceDescriptor.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
NamespaceDescriptor::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.NamespaceDescriptor.configuration)
  return &configuration_;
}
inline const ::hbase::pb::NameStringPair& NamespaceDescriptor::configuration(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.NamespaceDescriptor.configuration)
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* NamespaceDescriptor::add_configuration() {
  // @@protoc_insertion_point(field_add:hbase.pb.NamespaceDescriptor.configuration)
  return configuration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
NamespaceDescriptor::configuration() const {
  // @@protoc_insertion_point(field_list:hbase.pb.NamespaceDescriptor.configuration)
  return configuration_;
}

// -------------------------------------------------------------------

// VersionInfo

// required string version = 1;
inline bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VersionInfo::version() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.version)
  return version_.GetNoArena();
}
inline void VersionInfo::set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.version)
}
inline void VersionInfo::set_version(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.version)
}
inline void VersionInfo::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.version)
}
inline void VersionInfo::set_version(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  version_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.version)
}
inline std::string* VersionInfo::mutable_version() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.version)
  return version_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_version() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.version)
  if (!has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return version_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.version)
}

// required string url = 2;
inline bool VersionInfo::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionInfo::clear_url() {
  url_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& VersionInfo::url() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.url)
  return url_.GetNoArena();
}
inline void VersionInfo::set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.url)
}
inline void VersionInfo::set_url(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.url)
}
inline void VersionInfo::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.url)
}
inline void VersionInfo::set_url(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  url_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.url)
}
inline std::string* VersionInfo::mutable_url() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.url)
  return url_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_url() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.url)
  if (!has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return url_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  url_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.url)
}

// required string revision = 3;
inline bool VersionInfo::has_revision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VersionInfo::clear_revision() {
  revision_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& VersionInfo::revision() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.revision)
  return revision_.GetNoArena();
}
inline void VersionInfo::set_revision(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.revision)
}
inline void VersionInfo::set_revision(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  revision_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.revision)
}
inline void VersionInfo::set_revision(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.revision)
}
inline void VersionInfo::set_revision(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  revision_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.revision)
}
inline std::string* VersionInfo::mutable_revision() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.revision)
  return revision_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_revision() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.revision)
  if (!has_revision()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return revision_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_revision(std::string* revision) {
  if (revision != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  revision_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), revision);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.revision)
}

// required string user = 4;
inline bool VersionInfo::has_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VersionInfo::clear_user() {
  user_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& VersionInfo::user() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.user)
  return user_.GetNoArena();
}
inline void VersionInfo::set_user(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.user)
}
inline void VersionInfo::set_user(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  user_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.user)
}
inline void VersionInfo::set_user(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.user)
}
inline void VersionInfo::set_user(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  user_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.user)
}
inline std::string* VersionInfo::mutable_user() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.user)
  return user_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_user() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.user)
  if (!has_user()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return user_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_user(std::string* user) {
  if (user != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  user_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.user)
}

// required string date = 5;
inline bool VersionInfo::has_date() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VersionInfo::clear_date() {
  date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& VersionInfo::date() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.date)
  return date_.GetNoArena();
}
inline void VersionInfo::set_date(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.date)
}
inline void VersionInfo::set_date(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  date_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.date)
}
inline void VersionInfo::set_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.date)
}
inline void VersionInfo::set_date(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.date)
}
inline std::string* VersionInfo::mutable_date() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.date)
  return date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_date() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.date)
  if (!has_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return date_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_date(std::string* date) {
  if (date != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), date);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.date)
}

// required string src_checksum = 6;
inline bool VersionInfo::has_src_checksum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VersionInfo::clear_src_checksum() {
  src_checksum_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& VersionInfo::src_checksum() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.src_checksum)
  return src_checksum_.GetNoArena();
}
inline void VersionInfo::set_src_checksum(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  src_checksum_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.src_checksum)
}
inline void VersionInfo::set_src_checksum(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  src_checksum_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.VersionInfo.src_checksum)
}
inline void VersionInfo::set_src_checksum(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  src_checksum_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.VersionInfo.src_checksum)
}
inline void VersionInfo::set_src_checksum(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  src_checksum_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.VersionInfo.src_checksum)
}
inline std::string* VersionInfo::mutable_src_checksum() {
  _has_bits_[0] |= 0x00000020u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.VersionInfo.src_checksum)
  return src_checksum_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* VersionInfo::release_src_checksum() {
  // @@protoc_insertion_point(field_release:hbase.pb.VersionInfo.src_checksum)
  if (!has_src_checksum()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return src_checksum_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void VersionInfo::set_allocated_src_checksum(std::string* src_checksum) {
  if (src_checksum != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  src_checksum_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_checksum);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.VersionInfo.src_checksum)
}

// optional uint32 version_major = 7;
inline bool VersionInfo::has_version_major() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VersionInfo::clear_version_major() {
  version_major_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionInfo::version_major() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.version_major)
  return version_major_;
}
inline void VersionInfo::set_version_major(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  version_major_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.version_major)
}

// optional uint32 version_minor = 8;
inline bool VersionInfo::has_version_minor() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VersionInfo::clear_version_minor() {
  version_minor_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 VersionInfo::version_minor() const {
  // @@protoc_insertion_point(field_get:hbase.pb.VersionInfo.version_minor)
  return version_minor_;
}
inline void VersionInfo::set_version_minor(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  version_minor_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.VersionInfo.version_minor)
}

// -------------------------------------------------------------------

// RegionServerInfo

// optional int32 infoPort = 1;
inline bool RegionServerInfo::has_infoport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionServerInfo::clear_infoport() {
  infoport_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 RegionServerInfo::infoport() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionServerInfo.infoPort)
  return infoport_;
}
inline void RegionServerInfo::set_infoport(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  infoport_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionServerInfo.infoPort)
}

// optional .hbase.pb.VersionInfo version_info = 2;
inline bool RegionServerInfo::has_version_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionServerInfo::clear_version_info() {
  if (version_info_ != nullptr) version_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::VersionInfo& RegionServerInfo::version_info() const {
  const ::hbase::pb::VersionInfo* p = version_info_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionServerInfo.version_info)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::VersionInfo*>(
      &::hbase::pb::_VersionInfo_default_instance_);
}
inline ::hbase::pb::VersionInfo* RegionServerInfo::release_version_info() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionServerInfo.version_info)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::VersionInfo* temp = version_info_;
  version_info_ = nullptr;
  return temp;
}
inline ::hbase::pb::VersionInfo* RegionServerInfo::mutable_version_info() {
  _has_bits_[0] |= 0x00000001u;
  if (version_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::VersionInfo>(GetArenaNoVirtual());
    version_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionServerInfo.version_info)
  return version_info_;
}
inline void RegionServerInfo::set_allocated_version_info(::hbase::pb::VersionInfo* version_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete version_info_;
  }
  if (version_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      version_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, version_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  version_info_ = version_info;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionServerInfo.version_info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::TableState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::TableState_State>() {
  return ::hbase::pb::TableState_State_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::RegionSpecifier_RegionSpecifierType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::RegionSpecifier_RegionSpecifierType>() {
  return ::hbase::pb::RegionSpecifier_RegionSpecifierType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::SnapshotDescription_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SnapshotDescription_Type>() {
  return ::hbase::pb::SnapshotDescription_Type_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::CompareType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::CompareType>() {
  return ::hbase::pb::CompareType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::TimeUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::TimeUnit>() {
  return ::hbase::pb::TimeUnit_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_HBase_2eproto
