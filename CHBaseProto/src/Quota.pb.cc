// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Quota.proto

#include "Quota.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_Quota_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpaceQuota_Quota_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Quota_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpaceQuotaStatus_Quota_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Quota_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Throttle_Quota_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_Quota_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TimedQuota_Quota_2eproto;
namespace hbase {
namespace pb {
class TimedQuotaDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<TimedQuota> _instance;
} _TimedQuota_default_instance_;
class ThrottleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Throttle> _instance;
} _Throttle_default_instance_;
class ThrottleRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ThrottleRequest> _instance;
} _ThrottleRequest_default_instance_;
class QuotasDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Quotas> _instance;
} _Quotas_default_instance_;
class QuotaUsageDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<QuotaUsage> _instance;
} _QuotaUsage_default_instance_;
class SpaceQuotaDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpaceQuota> _instance;
} _SpaceQuota_default_instance_;
class SpaceLimitRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpaceLimitRequest> _instance;
} _SpaceLimitRequest_default_instance_;
class SpaceQuotaStatusDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpaceQuotaStatus> _instance;
} _SpaceQuotaStatus_default_instance_;
class SpaceQuotaSnapshotDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SpaceQuotaSnapshot> _instance;
} _SpaceQuotaSnapshot_default_instance_;
}  // namespace pb
}  // namespace hbase
static void InitDefaultsscc_info_QuotaUsage_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_QuotaUsage_default_instance_;
    new (ptr) ::hbase::pb::QuotaUsage();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::QuotaUsage::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_QuotaUsage_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_QuotaUsage_Quota_2eproto}, {}};

static void InitDefaultsscc_info_Quotas_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_Quotas_default_instance_;
    new (ptr) ::hbase::pb::Quotas();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::Quotas::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Quotas_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_Quotas_Quota_2eproto}, {
      &scc_info_Throttle_Quota_2eproto.base,
      &scc_info_SpaceQuota_Quota_2eproto.base,}};

static void InitDefaultsscc_info_SpaceLimitRequest_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_SpaceLimitRequest_default_instance_;
    new (ptr) ::hbase::pb::SpaceLimitRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::SpaceLimitRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SpaceLimitRequest_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_SpaceLimitRequest_Quota_2eproto}, {
      &scc_info_SpaceQuota_Quota_2eproto.base,}};

static void InitDefaultsscc_info_SpaceQuota_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_SpaceQuota_default_instance_;
    new (ptr) ::hbase::pb::SpaceQuota();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::SpaceQuota::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpaceQuota_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SpaceQuota_Quota_2eproto}, {}};

static void InitDefaultsscc_info_SpaceQuotaSnapshot_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_SpaceQuotaSnapshot_default_instance_;
    new (ptr) ::hbase::pb::SpaceQuotaSnapshot();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::SpaceQuotaSnapshot::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_SpaceQuotaSnapshot_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_SpaceQuotaSnapshot_Quota_2eproto}, {
      &scc_info_SpaceQuotaStatus_Quota_2eproto.base,}};

static void InitDefaultsscc_info_SpaceQuotaStatus_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_SpaceQuotaStatus_default_instance_;
    new (ptr) ::hbase::pb::SpaceQuotaStatus();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::SpaceQuotaStatus::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_SpaceQuotaStatus_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_SpaceQuotaStatus_Quota_2eproto}, {}};

static void InitDefaultsscc_info_Throttle_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_Throttle_default_instance_;
    new (ptr) ::hbase::pb::Throttle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::Throttle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_Throttle_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_Throttle_Quota_2eproto}, {
      &scc_info_TimedQuota_Quota_2eproto.base,}};

static void InitDefaultsscc_info_ThrottleRequest_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_ThrottleRequest_default_instance_;
    new (ptr) ::hbase::pb::ThrottleRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::ThrottleRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_ThrottleRequest_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_ThrottleRequest_Quota_2eproto}, {
      &scc_info_TimedQuota_Quota_2eproto.base,}};

static void InitDefaultsscc_info_TimedQuota_Quota_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::hbase::pb::_TimedQuota_default_instance_;
    new (ptr) ::hbase::pb::TimedQuota();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::hbase::pb::TimedQuota::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_TimedQuota_Quota_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_TimedQuota_Quota_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_Quota_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_Quota_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_Quota_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_Quota_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, time_unit_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, soft_limit_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, share_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::TimedQuota, scope_),
  2,
  0,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, req_num_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, req_size_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, write_num_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, write_size_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, read_num_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Throttle, read_size_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::ThrottleRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::ThrottleRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::ThrottleRequest, type_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::ThrottleRequest, timed_quota_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Quotas, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Quotas, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Quotas, bypass_globals_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Quotas, throttle_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::Quotas, space_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::QuotaUsage, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::QuotaUsage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuota, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuota, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuota, soft_limit_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuota, violation_policy_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuota, remove_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceLimitRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceLimitRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceLimitRequest, quota_),
  0,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaStatus, violation_policy_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaStatus, in_violation_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaSnapshot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaSnapshot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaSnapshot, quota_status_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaSnapshot, quota_usage_),
  PROTOBUF_FIELD_OFFSET(::hbase::pb::SpaceQuotaSnapshot, quota_limit_),
  0,
  1,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 9, sizeof(::hbase::pb::TimedQuota)},
  { 13, 24, sizeof(::hbase::pb::Throttle)},
  { 30, 37, sizeof(::hbase::pb::ThrottleRequest)},
  { 39, 47, sizeof(::hbase::pb::Quotas)},
  { 50, 55, sizeof(::hbase::pb::QuotaUsage)},
  { 55, 63, sizeof(::hbase::pb::SpaceQuota)},
  { 66, 72, sizeof(::hbase::pb::SpaceLimitRequest)},
  { 73, 80, sizeof(::hbase::pb::SpaceQuotaStatus)},
  { 82, 90, sizeof(::hbase::pb::SpaceQuotaSnapshot)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_TimedQuota_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_Throttle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_ThrottleRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_Quotas_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_QuotaUsage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_SpaceQuota_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_SpaceLimitRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_SpaceQuotaStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::hbase::pb::_SpaceQuotaSnapshot_default_instance_),
};

const char descriptor_table_protodef_Quota_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013Quota.proto\022\010hbase.pb\032\013HBase.proto\"\204\001\n"
  "\nTimedQuota\022%\n\ttime_unit\030\001 \002(\0162\022.hbase.p"
  "b.TimeUnit\022\022\n\nsoft_limit\030\002 \001(\004\022\r\n\005share\030"
  "\003 \001(\002\022,\n\005scope\030\004 \001(\0162\024.hbase.pb.QuotaSco"
  "pe:\007MACHINE\"\375\001\n\010Throttle\022%\n\007req_num\030\001 \001("
  "\0132\024.hbase.pb.TimedQuota\022&\n\010req_size\030\002 \001("
  "\0132\024.hbase.pb.TimedQuota\022\'\n\twrite_num\030\003 \001"
  "(\0132\024.hbase.pb.TimedQuota\022(\n\nwrite_size\030\004"
  " \001(\0132\024.hbase.pb.TimedQuota\022&\n\010read_num\030\005"
  " \001(\0132\024.hbase.pb.TimedQuota\022\'\n\tread_size\030"
  "\006 \001(\0132\024.hbase.pb.TimedQuota\"b\n\017ThrottleR"
  "equest\022$\n\004type\030\001 \001(\0162\026.hbase.pb.Throttle"
  "Type\022)\n\013timed_quota\030\002 \001(\0132\024.hbase.pb.Tim"
  "edQuota\"r\n\006Quotas\022\035\n\016bypass_globals\030\001 \001("
  "\010:\005false\022$\n\010throttle\030\002 \001(\0132\022.hbase.pb.Th"
  "rottle\022#\n\005space\030\003 \001(\0132\024.hbase.pb.SpaceQu"
  "ota\"\014\n\nQuotaUsage\"q\n\nSpaceQuota\022\022\n\nsoft_"
  "limit\030\001 \001(\004\0228\n\020violation_policy\030\002 \001(\0162\036."
  "hbase.pb.SpaceViolationPolicy\022\025\n\006remove\030"
  "\003 \001(\010:\005false\"8\n\021SpaceLimitRequest\022#\n\005quo"
  "ta\030\001 \001(\0132\024.hbase.pb.SpaceQuota\"b\n\020SpaceQ"
  "uotaStatus\0228\n\020violation_policy\030\001 \001(\0162\036.h"
  "base.pb.SpaceViolationPolicy\022\024\n\014in_viola"
  "tion\030\002 \001(\010\"p\n\022SpaceQuotaSnapshot\0220\n\014quot"
  "a_status\030\001 \001(\0132\032.hbase.pb.SpaceQuotaStat"
  "us\022\023\n\013quota_usage\030\002 \001(\004\022\023\n\013quota_limit\030\003"
  " \001(\004*&\n\nQuotaScope\022\013\n\007CLUSTER\020\001\022\013\n\007MACHI"
  "NE\020\002*v\n\014ThrottleType\022\022\n\016REQUEST_NUMBER\020\001"
  "\022\020\n\014REQUEST_SIZE\020\002\022\020\n\014WRITE_NUMBER\020\003\022\016\n\n"
  "WRITE_SIZE\020\004\022\017\n\013READ_NUMBER\020\005\022\r\n\tREAD_SI"
  "ZE\020\006*$\n\tQuotaType\022\014\n\010THROTTLE\020\001\022\t\n\005SPACE"
  "\020\002*]\n\024SpaceViolationPolicy\022\013\n\007DISABLE\020\001\022"
  "\031\n\025NO_WRITES_COMPACTIONS\020\002\022\r\n\tNO_WRITES\020"
  "\003\022\016\n\nNO_INSERTS\020\004BA\n*org.apache.hadoop.h"
  "base.protobuf.generatedB\013QuotaProtosH\001\210\001"
  "\001\240\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_Quota_2eproto_deps[1] = {
  &::descriptor_table_HBase_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_Quota_2eproto_sccs[9] = {
  &scc_info_QuotaUsage_Quota_2eproto.base,
  &scc_info_Quotas_Quota_2eproto.base,
  &scc_info_SpaceLimitRequest_Quota_2eproto.base,
  &scc_info_SpaceQuota_Quota_2eproto.base,
  &scc_info_SpaceQuotaSnapshot_Quota_2eproto.base,
  &scc_info_SpaceQuotaStatus_Quota_2eproto.base,
  &scc_info_Throttle_Quota_2eproto.base,
  &scc_info_ThrottleRequest_Quota_2eproto.base,
  &scc_info_TimedQuota_Quota_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_Quota_2eproto_once;
static bool descriptor_table_Quota_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Quota_2eproto = {
  &descriptor_table_Quota_2eproto_initialized, descriptor_table_protodef_Quota_2eproto, "Quota.proto", 1404,
  &descriptor_table_Quota_2eproto_once, descriptor_table_Quota_2eproto_sccs, descriptor_table_Quota_2eproto_deps, 9, 1,
  schemas, file_default_instances, TableStruct_Quota_2eproto::offsets,
  file_level_metadata_Quota_2eproto, 9, file_level_enum_descriptors_Quota_2eproto, file_level_service_descriptors_Quota_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_Quota_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_Quota_2eproto), true);
namespace hbase {
namespace pb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotaScope_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Quota_2eproto);
  return file_level_enum_descriptors_Quota_2eproto[0];
}
bool QuotaScope_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThrottleType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Quota_2eproto);
  return file_level_enum_descriptors_Quota_2eproto[1];
}
bool ThrottleType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotaType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Quota_2eproto);
  return file_level_enum_descriptors_Quota_2eproto[2];
}
bool QuotaType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceViolationPolicy_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_Quota_2eproto);
  return file_level_enum_descriptors_Quota_2eproto[3];
}
bool SpaceViolationPolicy_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void TimedQuota::InitAsDefaultInstance() {
}
class TimedQuota::_Internal {
 public:
  using HasBits = decltype(std::declval<TimedQuota>()._has_bits_);
  static void set_has_time_unit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_soft_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_share(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

TimedQuota::TimedQuota()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.TimedQuota)
}
TimedQuota::TimedQuota(const TimedQuota& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&soft_limit_, &from.soft_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&scope_) -
    reinterpret_cast<char*>(&soft_limit_)) + sizeof(scope_));
  // @@protoc_insertion_point(copy_constructor:hbase.pb.TimedQuota)
}

void TimedQuota::SharedCtor() {
  ::memset(&soft_limit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&share_) -
      reinterpret_cast<char*>(&soft_limit_)) + sizeof(share_));
  time_unit_ = 1;
  scope_ = 2;
}

TimedQuota::~TimedQuota() {
  // @@protoc_insertion_point(destructor:hbase.pb.TimedQuota)
  SharedDtor();
}

void TimedQuota::SharedDtor() {
}

void TimedQuota::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const TimedQuota& TimedQuota::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_TimedQuota_Quota_2eproto.base);
  return *internal_default_instance();
}


void TimedQuota::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.TimedQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&soft_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&share_) -
        reinterpret_cast<char*>(&soft_limit_)) + sizeof(share_));
    time_unit_ = 1;
    scope_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* TimedQuota::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .hbase.pb.TimeUnit time_unit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::TimeUnit_IsValid(val))) {
            set_time_unit(static_cast<::hbase::pb::TimeUnit>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint64 soft_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_soft_limit(&has_bits);
          soft_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float share = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_share(&has_bits);
          share_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::QuotaScope_IsValid(val))) {
            set_scope(static_cast<::hbase::pb::QuotaScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool TimedQuota::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.TimedQuota)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .hbase.pb.TimeUnit time_unit = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::TimeUnit_IsValid(value)) {
            set_time_unit(static_cast< ::hbase::pb::TimeUnit >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 soft_limit = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_soft_limit(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &soft_limit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional float share = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (29 & 0xFF)) {
          _Internal::set_has_share(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   float, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &share_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::QuotaScope_IsValid(value)) {
            set_scope(static_cast< ::hbase::pb::QuotaScope >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.TimedQuota)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.TimedQuota)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void TimedQuota::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.TimedQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.TimeUnit time_unit = 1;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->time_unit(), output);
  }

  // optional uint64 soft_limit = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->soft_limit(), output);
  }

  // optional float share = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloat(3, this->share(), output);
  }

  // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->scope(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.TimedQuota)
}

::PROTOBUF_NAMESPACE_ID::uint8* TimedQuota::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.TimedQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .hbase.pb.TimeUnit time_unit = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->time_unit(), target);
  }

  // optional uint64 soft_limit = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->soft_limit(), target);
  }

  // optional float share = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->share(), target);
  }

  // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->scope(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.TimedQuota)
  return target;
}

size_t TimedQuota::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.TimedQuota)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .hbase.pb.TimeUnit time_unit = 1;
  if (has_time_unit()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->time_unit());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 soft_limit = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->soft_limit());
    }

    // optional float share = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->scope());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TimedQuota::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.TimedQuota)
  GOOGLE_DCHECK_NE(&from, this);
  const TimedQuota* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<TimedQuota>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.TimedQuota)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.TimedQuota)
    MergeFrom(*source);
  }
}

void TimedQuota::MergeFrom(const TimedQuota& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.TimedQuota)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      soft_limit_ = from.soft_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      share_ = from.share_;
    }
    if (cached_has_bits & 0x00000004u) {
      time_unit_ = from.time_unit_;
    }
    if (cached_has_bits & 0x00000008u) {
      scope_ = from.scope_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void TimedQuota::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.TimedQuota)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimedQuota::CopyFrom(const TimedQuota& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.TimedQuota)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimedQuota::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;
  return true;
}

void TimedQuota::InternalSwap(TimedQuota* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(soft_limit_, other->soft_limit_);
  swap(share_, other->share_);
  swap(time_unit_, other->time_unit_);
  swap(scope_, other->scope_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TimedQuota::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Throttle::InitAsDefaultInstance() {
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->req_num_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->req_size_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->write_num_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->write_size_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->read_num_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
  ::hbase::pb::_Throttle_default_instance_._instance.get_mutable()->read_size_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
}
class Throttle::_Internal {
 public:
  using HasBits = decltype(std::declval<Throttle>()._has_bits_);
  static const ::hbase::pb::TimedQuota& req_num(const Throttle* msg);
  static void set_has_req_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::hbase::pb::TimedQuota& req_size(const Throttle* msg);
  static void set_has_req_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hbase::pb::TimedQuota& write_num(const Throttle* msg);
  static void set_has_write_num(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::hbase::pb::TimedQuota& write_size(const Throttle* msg);
  static void set_has_write_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::hbase::pb::TimedQuota& read_num(const Throttle* msg);
  static void set_has_read_num(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::hbase::pb::TimedQuota& read_size(const Throttle* msg);
  static void set_has_read_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::hbase::pb::TimedQuota&
Throttle::_Internal::req_num(const Throttle* msg) {
  return *msg->req_num_;
}
const ::hbase::pb::TimedQuota&
Throttle::_Internal::req_size(const Throttle* msg) {
  return *msg->req_size_;
}
const ::hbase::pb::TimedQuota&
Throttle::_Internal::write_num(const Throttle* msg) {
  return *msg->write_num_;
}
const ::hbase::pb::TimedQuota&
Throttle::_Internal::write_size(const Throttle* msg) {
  return *msg->write_size_;
}
const ::hbase::pb::TimedQuota&
Throttle::_Internal::read_num(const Throttle* msg) {
  return *msg->read_num_;
}
const ::hbase::pb::TimedQuota&
Throttle::_Internal::read_size(const Throttle* msg) {
  return *msg->read_size_;
}
Throttle::Throttle()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.Throttle)
}
Throttle::Throttle(const Throttle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_req_num()) {
    req_num_ = new ::hbase::pb::TimedQuota(*from.req_num_);
  } else {
    req_num_ = nullptr;
  }
  if (from.has_req_size()) {
    req_size_ = new ::hbase::pb::TimedQuota(*from.req_size_);
  } else {
    req_size_ = nullptr;
  }
  if (from.has_write_num()) {
    write_num_ = new ::hbase::pb::TimedQuota(*from.write_num_);
  } else {
    write_num_ = nullptr;
  }
  if (from.has_write_size()) {
    write_size_ = new ::hbase::pb::TimedQuota(*from.write_size_);
  } else {
    write_size_ = nullptr;
  }
  if (from.has_read_num()) {
    read_num_ = new ::hbase::pb::TimedQuota(*from.read_num_);
  } else {
    read_num_ = nullptr;
  }
  if (from.has_read_size()) {
    read_size_ = new ::hbase::pb::TimedQuota(*from.read_size_);
  } else {
    read_size_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.Throttle)
}

void Throttle::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Throttle_Quota_2eproto.base);
  ::memset(&req_num_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&read_size_) -
      reinterpret_cast<char*>(&req_num_)) + sizeof(read_size_));
}

Throttle::~Throttle() {
  // @@protoc_insertion_point(destructor:hbase.pb.Throttle)
  SharedDtor();
}

void Throttle::SharedDtor() {
  if (this != internal_default_instance()) delete req_num_;
  if (this != internal_default_instance()) delete req_size_;
  if (this != internal_default_instance()) delete write_num_;
  if (this != internal_default_instance()) delete write_size_;
  if (this != internal_default_instance()) delete read_num_;
  if (this != internal_default_instance()) delete read_size_;
}

void Throttle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Throttle& Throttle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Throttle_Quota_2eproto.base);
  return *internal_default_instance();
}


void Throttle::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.Throttle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(req_num_ != nullptr);
      req_num_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(req_size_ != nullptr);
      req_size_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(write_num_ != nullptr);
      write_num_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(write_size_ != nullptr);
      write_size_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(read_num_ != nullptr);
      read_num_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(read_size_ != nullptr);
      read_size_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Throttle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.TimedQuota req_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_req_num(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota req_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_req_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota write_num = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_write_num(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota write_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_write_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota read_num = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_read_num(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota read_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_read_size(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Throttle::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.Throttle)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.TimedQuota req_num = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_req_num()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota req_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_req_size()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota write_num = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_write_num()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota write_size = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_write_size()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota read_num = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_read_num()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota read_size = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_read_size()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.Throttle)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.Throttle)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Throttle::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.Throttle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.TimedQuota req_num = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::req_num(this), output);
  }

  // optional .hbase.pb.TimedQuota req_size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::req_size(this), output);
  }

  // optional .hbase.pb.TimedQuota write_num = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::write_num(this), output);
  }

  // optional .hbase.pb.TimedQuota write_size = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, _Internal::write_size(this), output);
  }

  // optional .hbase.pb.TimedQuota read_num = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, _Internal::read_num(this), output);
  }

  // optional .hbase.pb.TimedQuota read_size = 6;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::read_size(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.Throttle)
}

::PROTOBUF_NAMESPACE_ID::uint8* Throttle::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.Throttle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.TimedQuota req_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::req_num(this), target);
  }

  // optional .hbase.pb.TimedQuota req_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::req_size(this), target);
  }

  // optional .hbase.pb.TimedQuota write_num = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::write_num(this), target);
  }

  // optional .hbase.pb.TimedQuota write_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::write_size(this), target);
  }

  // optional .hbase.pb.TimedQuota read_num = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::read_num(this), target);
  }

  // optional .hbase.pb.TimedQuota read_size = 6;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::read_size(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.Throttle)
  return target;
}

size_t Throttle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.Throttle)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .hbase.pb.TimedQuota req_num = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_num_);
    }

    // optional .hbase.pb.TimedQuota req_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *req_size_);
    }

    // optional .hbase.pb.TimedQuota write_num = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *write_num_);
    }

    // optional .hbase.pb.TimedQuota write_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *write_size_);
    }

    // optional .hbase.pb.TimedQuota read_num = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *read_num_);
    }

    // optional .hbase.pb.TimedQuota read_size = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *read_size_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Throttle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.Throttle)
  GOOGLE_DCHECK_NE(&from, this);
  const Throttle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Throttle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.Throttle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.Throttle)
    MergeFrom(*source);
  }
}

void Throttle::MergeFrom(const Throttle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.Throttle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_req_num()->::hbase::pb::TimedQuota::MergeFrom(from.req_num());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_req_size()->::hbase::pb::TimedQuota::MergeFrom(from.req_size());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_write_num()->::hbase::pb::TimedQuota::MergeFrom(from.write_num());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_write_size()->::hbase::pb::TimedQuota::MergeFrom(from.write_size());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_read_num()->::hbase::pb::TimedQuota::MergeFrom(from.read_num());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_read_size()->::hbase::pb::TimedQuota::MergeFrom(from.read_size());
    }
  }
}

void Throttle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.Throttle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Throttle::CopyFrom(const Throttle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.Throttle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Throttle::IsInitialized() const {
  if (has_req_num()) {
    if (!this->req_num_->IsInitialized()) return false;
  }
  if (has_req_size()) {
    if (!this->req_size_->IsInitialized()) return false;
  }
  if (has_write_num()) {
    if (!this->write_num_->IsInitialized()) return false;
  }
  if (has_write_size()) {
    if (!this->write_size_->IsInitialized()) return false;
  }
  if (has_read_num()) {
    if (!this->read_num_->IsInitialized()) return false;
  }
  if (has_read_size()) {
    if (!this->read_size_->IsInitialized()) return false;
  }
  return true;
}

void Throttle::InternalSwap(Throttle* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(req_num_, other->req_num_);
  swap(req_size_, other->req_size_);
  swap(write_num_, other->write_num_);
  swap(write_size_, other->write_size_);
  swap(read_num_, other->read_num_);
  swap(read_size_, other->read_size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Throttle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ThrottleRequest::InitAsDefaultInstance() {
  ::hbase::pb::_ThrottleRequest_default_instance_._instance.get_mutable()->timed_quota_ = const_cast< ::hbase::pb::TimedQuota*>(
      ::hbase::pb::TimedQuota::internal_default_instance());
}
class ThrottleRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<ThrottleRequest>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::hbase::pb::TimedQuota& timed_quota(const ThrottleRequest* msg);
  static void set_has_timed_quota(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hbase::pb::TimedQuota&
ThrottleRequest::_Internal::timed_quota(const ThrottleRequest* msg) {
  return *msg->timed_quota_;
}
ThrottleRequest::ThrottleRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.ThrottleRequest)
}
ThrottleRequest::ThrottleRequest(const ThrottleRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_timed_quota()) {
    timed_quota_ = new ::hbase::pb::TimedQuota(*from.timed_quota_);
  } else {
    timed_quota_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.ThrottleRequest)
}

void ThrottleRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ThrottleRequest_Quota_2eproto.base);
  timed_quota_ = nullptr;
  type_ = 1;
}

ThrottleRequest::~ThrottleRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.ThrottleRequest)
  SharedDtor();
}

void ThrottleRequest::SharedDtor() {
  if (this != internal_default_instance()) delete timed_quota_;
}

void ThrottleRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ThrottleRequest& ThrottleRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ThrottleRequest_Quota_2eproto.base);
  return *internal_default_instance();
}


void ThrottleRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.ThrottleRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(timed_quota_ != nullptr);
      timed_quota_->Clear();
    }
    type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ThrottleRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.ThrottleType type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::ThrottleType_IsValid(val))) {
            set_type(static_cast<::hbase::pb::ThrottleType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.TimedQuota timed_quota = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_timed_quota(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ThrottleRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.ThrottleRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.ThrottleType type = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::ThrottleType_IsValid(value)) {
            set_type(static_cast< ::hbase::pb::ThrottleType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.TimedQuota timed_quota = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_timed_quota()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.ThrottleRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.ThrottleRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ThrottleRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.ThrottleRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.ThrottleType type = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .hbase.pb.TimedQuota timed_quota = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::timed_quota(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.ThrottleRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* ThrottleRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.ThrottleRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.ThrottleType type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .hbase.pb.TimedQuota timed_quota = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::timed_quota(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.ThrottleRequest)
  return target;
}

size_t ThrottleRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.ThrottleRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .hbase.pb.TimedQuota timed_quota = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *timed_quota_);
    }

    // optional .hbase.pb.ThrottleType type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ThrottleRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.ThrottleRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const ThrottleRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ThrottleRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.ThrottleRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.ThrottleRequest)
    MergeFrom(*source);
  }
}

void ThrottleRequest::MergeFrom(const ThrottleRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.ThrottleRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_timed_quota()->::hbase::pb::TimedQuota::MergeFrom(from.timed_quota());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void ThrottleRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.ThrottleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ThrottleRequest::CopyFrom(const ThrottleRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.ThrottleRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ThrottleRequest::IsInitialized() const {
  if (has_timed_quota()) {
    if (!this->timed_quota_->IsInitialized()) return false;
  }
  return true;
}

void ThrottleRequest::InternalSwap(ThrottleRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timed_quota_, other->timed_quota_);
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ThrottleRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Quotas::InitAsDefaultInstance() {
  ::hbase::pb::_Quotas_default_instance_._instance.get_mutable()->throttle_ = const_cast< ::hbase::pb::Throttle*>(
      ::hbase::pb::Throttle::internal_default_instance());
  ::hbase::pb::_Quotas_default_instance_._instance.get_mutable()->space_ = const_cast< ::hbase::pb::SpaceQuota*>(
      ::hbase::pb::SpaceQuota::internal_default_instance());
}
class Quotas::_Internal {
 public:
  using HasBits = decltype(std::declval<Quotas>()._has_bits_);
  static void set_has_bypass_globals(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::hbase::pb::Throttle& throttle(const Quotas* msg);
  static void set_has_throttle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::hbase::pb::SpaceQuota& space(const Quotas* msg);
  static void set_has_space(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::hbase::pb::Throttle&
Quotas::_Internal::throttle(const Quotas* msg) {
  return *msg->throttle_;
}
const ::hbase::pb::SpaceQuota&
Quotas::_Internal::space(const Quotas* msg) {
  return *msg->space_;
}
Quotas::Quotas()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.Quotas)
}
Quotas::Quotas(const Quotas& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_throttle()) {
    throttle_ = new ::hbase::pb::Throttle(*from.throttle_);
  } else {
    throttle_ = nullptr;
  }
  if (from.has_space()) {
    space_ = new ::hbase::pb::SpaceQuota(*from.space_);
  } else {
    space_ = nullptr;
  }
  bypass_globals_ = from.bypass_globals_;
  // @@protoc_insertion_point(copy_constructor:hbase.pb.Quotas)
}

void Quotas::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Quotas_Quota_2eproto.base);
  ::memset(&throttle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&bypass_globals_) -
      reinterpret_cast<char*>(&throttle_)) + sizeof(bypass_globals_));
}

Quotas::~Quotas() {
  // @@protoc_insertion_point(destructor:hbase.pb.Quotas)
  SharedDtor();
}

void Quotas::SharedDtor() {
  if (this != internal_default_instance()) delete throttle_;
  if (this != internal_default_instance()) delete space_;
}

void Quotas::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Quotas& Quotas::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Quotas_Quota_2eproto.base);
  return *internal_default_instance();
}


void Quotas::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.Quotas)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(throttle_ != nullptr);
      throttle_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(space_ != nullptr);
      space_->Clear();
    }
  }
  bypass_globals_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* Quotas::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional bool bypass_globals = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bypass_globals(&has_bits);
          bypass_globals_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.Throttle throttle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_throttle(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.SpaceQuota space = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_space(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool Quotas::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.Quotas)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool bypass_globals = 1 [default = false];
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bypass_globals(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bypass_globals_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.Throttle throttle = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_throttle()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.SpaceQuota space = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_space()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.Quotas)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.Quotas)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void Quotas::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.Quotas)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool bypass_globals = 1 [default = false];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(1, this->bypass_globals(), output);
  }

  // optional .hbase.pb.Throttle throttle = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::throttle(this), output);
  }

  // optional .hbase.pb.SpaceQuota space = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::space(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.Quotas)
}

::PROTOBUF_NAMESPACE_ID::uint8* Quotas::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.Quotas)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool bypass_globals = 1 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->bypass_globals(), target);
  }

  // optional .hbase.pb.Throttle throttle = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::throttle(this), target);
  }

  // optional .hbase.pb.SpaceQuota space = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::space(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.Quotas)
  return target;
}

size_t Quotas::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.Quotas)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .hbase.pb.Throttle throttle = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *throttle_);
    }

    // optional .hbase.pb.SpaceQuota space = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *space_);
    }

    // optional bool bypass_globals = 1 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Quotas::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.Quotas)
  GOOGLE_DCHECK_NE(&from, this);
  const Quotas* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Quotas>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.Quotas)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.Quotas)
    MergeFrom(*source);
  }
}

void Quotas::MergeFrom(const Quotas& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.Quotas)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_throttle()->::hbase::pb::Throttle::MergeFrom(from.throttle());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_space()->::hbase::pb::SpaceQuota::MergeFrom(from.space());
    }
    if (cached_has_bits & 0x00000004u) {
      bypass_globals_ = from.bypass_globals_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Quotas::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.Quotas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Quotas::CopyFrom(const Quotas& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.Quotas)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Quotas::IsInitialized() const {
  if (has_throttle()) {
    if (!this->throttle_->IsInitialized()) return false;
  }
  return true;
}

void Quotas::InternalSwap(Quotas* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(throttle_, other->throttle_);
  swap(space_, other->space_);
  swap(bypass_globals_, other->bypass_globals_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Quotas::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void QuotaUsage::InitAsDefaultInstance() {
}
class QuotaUsage::_Internal {
 public:
  using HasBits = decltype(std::declval<QuotaUsage>()._has_bits_);
};

QuotaUsage::QuotaUsage()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.QuotaUsage)
}
QuotaUsage::QuotaUsage(const QuotaUsage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:hbase.pb.QuotaUsage)
}

void QuotaUsage::SharedCtor() {
}

QuotaUsage::~QuotaUsage() {
  // @@protoc_insertion_point(destructor:hbase.pb.QuotaUsage)
  SharedDtor();
}

void QuotaUsage::SharedDtor() {
}

void QuotaUsage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const QuotaUsage& QuotaUsage::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_QuotaUsage_Quota_2eproto.base);
  return *internal_default_instance();
}


void QuotaUsage::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.QuotaUsage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* QuotaUsage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      default: {
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool QuotaUsage::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.QuotaUsage)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0) {
      goto success;
    }
    DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
          input, tag, _internal_metadata_.mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.QuotaUsage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.QuotaUsage)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void QuotaUsage::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.QuotaUsage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.QuotaUsage)
}

::PROTOBUF_NAMESPACE_ID::uint8* QuotaUsage::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.QuotaUsage)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.QuotaUsage)
  return target;
}

size_t QuotaUsage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.QuotaUsage)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void QuotaUsage::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.QuotaUsage)
  GOOGLE_DCHECK_NE(&from, this);
  const QuotaUsage* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<QuotaUsage>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.QuotaUsage)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.QuotaUsage)
    MergeFrom(*source);
  }
}

void QuotaUsage::MergeFrom(const QuotaUsage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.QuotaUsage)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

}

void QuotaUsage::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.QuotaUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void QuotaUsage::CopyFrom(const QuotaUsage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.QuotaUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool QuotaUsage::IsInitialized() const {
  return true;
}

void QuotaUsage::InternalSwap(QuotaUsage* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata QuotaUsage::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpaceQuota::InitAsDefaultInstance() {
}
class SpaceQuota::_Internal {
 public:
  using HasBits = decltype(std::declval<SpaceQuota>()._has_bits_);
  static void set_has_soft_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_violation_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_remove(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SpaceQuota::SpaceQuota()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.SpaceQuota)
}
SpaceQuota::SpaceQuota(const SpaceQuota& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&soft_limit_, &from.soft_limit_,
    static_cast<size_t>(reinterpret_cast<char*>(&violation_policy_) -
    reinterpret_cast<char*>(&soft_limit_)) + sizeof(violation_policy_));
  // @@protoc_insertion_point(copy_constructor:hbase.pb.SpaceQuota)
}

void SpaceQuota::SharedCtor() {
  ::memset(&soft_limit_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&remove_) -
      reinterpret_cast<char*>(&soft_limit_)) + sizeof(remove_));
  violation_policy_ = 1;
}

SpaceQuota::~SpaceQuota() {
  // @@protoc_insertion_point(destructor:hbase.pb.SpaceQuota)
  SharedDtor();
}

void SpaceQuota::SharedDtor() {
}

void SpaceQuota::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpaceQuota& SpaceQuota::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpaceQuota_Quota_2eproto.base);
  return *internal_default_instance();
}


void SpaceQuota::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.SpaceQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&soft_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&remove_) -
        reinterpret_cast<char*>(&soft_limit_)) + sizeof(remove_));
    violation_policy_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpaceQuota::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional uint64 soft_limit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_soft_limit(&has_bits);
          soft_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::SpaceViolationPolicy_IsValid(val))) {
            set_violation_policy(static_cast<::hbase::pb::SpaceViolationPolicy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool remove = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_remove(&has_bits);
          remove_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpaceQuota::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.SpaceQuota)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 soft_limit = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_soft_limit(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &soft_limit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::SpaceViolationPolicy_IsValid(value)) {
            set_violation_policy(static_cast< ::hbase::pb::SpaceViolationPolicy >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool remove = 3 [default = false];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_remove(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &remove_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.SpaceQuota)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.SpaceQuota)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpaceQuota::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.SpaceQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 soft_limit = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->soft_limit(), output);
  }

  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->violation_policy(), output);
  }

  // optional bool remove = 3 [default = false];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(3, this->remove(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.SpaceQuota)
}

::PROTOBUF_NAMESPACE_ID::uint8* SpaceQuota::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.SpaceQuota)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 soft_limit = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->soft_limit(), target);
  }

  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->violation_policy(), target);
  }

  // optional bool remove = 3 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->remove(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.SpaceQuota)
  return target;
}

size_t SpaceQuota::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.SpaceQuota)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 soft_limit = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->soft_limit());
    }

    // optional bool remove = 3 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->violation_policy());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpaceQuota::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.SpaceQuota)
  GOOGLE_DCHECK_NE(&from, this);
  const SpaceQuota* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpaceQuota>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.SpaceQuota)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.SpaceQuota)
    MergeFrom(*source);
  }
}

void SpaceQuota::MergeFrom(const SpaceQuota& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.SpaceQuota)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      soft_limit_ = from.soft_limit_;
    }
    if (cached_has_bits & 0x00000002u) {
      remove_ = from.remove_;
    }
    if (cached_has_bits & 0x00000004u) {
      violation_policy_ = from.violation_policy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpaceQuota::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.SpaceQuota)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpaceQuota::CopyFrom(const SpaceQuota& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.SpaceQuota)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpaceQuota::IsInitialized() const {
  return true;
}

void SpaceQuota::InternalSwap(SpaceQuota* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(soft_limit_, other->soft_limit_);
  swap(remove_, other->remove_);
  swap(violation_policy_, other->violation_policy_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpaceQuota::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpaceLimitRequest::InitAsDefaultInstance() {
  ::hbase::pb::_SpaceLimitRequest_default_instance_._instance.get_mutable()->quota_ = const_cast< ::hbase::pb::SpaceQuota*>(
      ::hbase::pb::SpaceQuota::internal_default_instance());
}
class SpaceLimitRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<SpaceLimitRequest>()._has_bits_);
  static const ::hbase::pb::SpaceQuota& quota(const SpaceLimitRequest* msg);
  static void set_has_quota(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::hbase::pb::SpaceQuota&
SpaceLimitRequest::_Internal::quota(const SpaceLimitRequest* msg) {
  return *msg->quota_;
}
SpaceLimitRequest::SpaceLimitRequest()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.SpaceLimitRequest)
}
SpaceLimitRequest::SpaceLimitRequest(const SpaceLimitRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_quota()) {
    quota_ = new ::hbase::pb::SpaceQuota(*from.quota_);
  } else {
    quota_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:hbase.pb.SpaceLimitRequest)
}

void SpaceLimitRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SpaceLimitRequest_Quota_2eproto.base);
  quota_ = nullptr;
}

SpaceLimitRequest::~SpaceLimitRequest() {
  // @@protoc_insertion_point(destructor:hbase.pb.SpaceLimitRequest)
  SharedDtor();
}

void SpaceLimitRequest::SharedDtor() {
  if (this != internal_default_instance()) delete quota_;
}

void SpaceLimitRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpaceLimitRequest& SpaceLimitRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpaceLimitRequest_Quota_2eproto.base);
  return *internal_default_instance();
}


void SpaceLimitRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.SpaceLimitRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(quota_ != nullptr);
    quota_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpaceLimitRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.SpaceQuota quota = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_quota(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpaceLimitRequest::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.SpaceLimitRequest)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.SpaceQuota quota = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_quota()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.SpaceLimitRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.SpaceLimitRequest)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpaceLimitRequest::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.SpaceLimitRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceQuota quota = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::quota(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.SpaceLimitRequest)
}

::PROTOBUF_NAMESPACE_ID::uint8* SpaceLimitRequest::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.SpaceLimitRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceQuota quota = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::quota(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.SpaceLimitRequest)
  return target;
}

size_t SpaceLimitRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.SpaceLimitRequest)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .hbase.pb.SpaceQuota quota = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *quota_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpaceLimitRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.SpaceLimitRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const SpaceLimitRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpaceLimitRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.SpaceLimitRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.SpaceLimitRequest)
    MergeFrom(*source);
  }
}

void SpaceLimitRequest::MergeFrom(const SpaceLimitRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.SpaceLimitRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_quota()) {
    mutable_quota()->::hbase::pb::SpaceQuota::MergeFrom(from.quota());
  }
}

void SpaceLimitRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.SpaceLimitRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpaceLimitRequest::CopyFrom(const SpaceLimitRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.SpaceLimitRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpaceLimitRequest::IsInitialized() const {
  return true;
}

void SpaceLimitRequest::InternalSwap(SpaceLimitRequest* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(quota_, other->quota_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpaceLimitRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpaceQuotaStatus::InitAsDefaultInstance() {
}
class SpaceQuotaStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<SpaceQuotaStatus>()._has_bits_);
  static void set_has_violation_policy(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_in_violation(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SpaceQuotaStatus::SpaceQuotaStatus()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.SpaceQuotaStatus)
}
SpaceQuotaStatus::SpaceQuotaStatus(const SpaceQuotaStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&in_violation_, &from.in_violation_,
    static_cast<size_t>(reinterpret_cast<char*>(&violation_policy_) -
    reinterpret_cast<char*>(&in_violation_)) + sizeof(violation_policy_));
  // @@protoc_insertion_point(copy_constructor:hbase.pb.SpaceQuotaStatus)
}

void SpaceQuotaStatus::SharedCtor() {
  in_violation_ = false;
  violation_policy_ = 1;
}

SpaceQuotaStatus::~SpaceQuotaStatus() {
  // @@protoc_insertion_point(destructor:hbase.pb.SpaceQuotaStatus)
  SharedDtor();
}

void SpaceQuotaStatus::SharedDtor() {
}

void SpaceQuotaStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpaceQuotaStatus& SpaceQuotaStatus::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpaceQuotaStatus_Quota_2eproto.base);
  return *internal_default_instance();
}


void SpaceQuotaStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.SpaceQuotaStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    in_violation_ = false;
    violation_policy_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpaceQuotaStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::hbase::pb::SpaceViolationPolicy_IsValid(val))) {
            set_violation_policy(static_cast<::hbase::pb::SpaceViolationPolicy>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional bool in_violation = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_in_violation(&has_bits);
          in_violation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpaceQuotaStatus::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.SpaceQuotaStatus)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::hbase::pb::SpaceViolationPolicy_IsValid(value)) {
            set_violation_policy(static_cast< ::hbase::pb::SpaceViolationPolicy >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional bool in_violation = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_in_violation(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   bool, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL>(
                 input, &in_violation_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.SpaceQuotaStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.SpaceQuotaStatus)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpaceQuotaStatus::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.SpaceQuotaStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->violation_policy(), output);
  }

  // optional bool in_violation = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBool(2, this->in_violation(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.SpaceQuotaStatus)
}

::PROTOBUF_NAMESPACE_ID::uint8* SpaceQuotaStatus::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.SpaceQuotaStatus)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->violation_policy(), target);
  }

  // optional bool in_violation = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->in_violation(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.SpaceQuotaStatus)
  return target;
}

size_t SpaceQuotaStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.SpaceQuotaStatus)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool in_violation = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->violation_policy());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpaceQuotaStatus::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.SpaceQuotaStatus)
  GOOGLE_DCHECK_NE(&from, this);
  const SpaceQuotaStatus* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpaceQuotaStatus>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.SpaceQuotaStatus)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.SpaceQuotaStatus)
    MergeFrom(*source);
  }
}

void SpaceQuotaStatus::MergeFrom(const SpaceQuotaStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.SpaceQuotaStatus)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      in_violation_ = from.in_violation_;
    }
    if (cached_has_bits & 0x00000002u) {
      violation_policy_ = from.violation_policy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpaceQuotaStatus::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.SpaceQuotaStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpaceQuotaStatus::CopyFrom(const SpaceQuotaStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.SpaceQuotaStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpaceQuotaStatus::IsInitialized() const {
  return true;
}

void SpaceQuotaStatus::InternalSwap(SpaceQuotaStatus* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(in_violation_, other->in_violation_);
  swap(violation_policy_, other->violation_policy_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpaceQuotaStatus::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SpaceQuotaSnapshot::InitAsDefaultInstance() {
  ::hbase::pb::_SpaceQuotaSnapshot_default_instance_._instance.get_mutable()->quota_status_ = const_cast< ::hbase::pb::SpaceQuotaStatus*>(
      ::hbase::pb::SpaceQuotaStatus::internal_default_instance());
}
class SpaceQuotaSnapshot::_Internal {
 public:
  using HasBits = decltype(std::declval<SpaceQuotaSnapshot>()._has_bits_);
  static const ::hbase::pb::SpaceQuotaStatus& quota_status(const SpaceQuotaSnapshot* msg);
  static void set_has_quota_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_quota_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_quota_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::hbase::pb::SpaceQuotaStatus&
SpaceQuotaSnapshot::_Internal::quota_status(const SpaceQuotaSnapshot* msg) {
  return *msg->quota_status_;
}
SpaceQuotaSnapshot::SpaceQuotaSnapshot()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:hbase.pb.SpaceQuotaSnapshot)
}
SpaceQuotaSnapshot::SpaceQuotaSnapshot(const SpaceQuotaSnapshot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_quota_status()) {
    quota_status_ = new ::hbase::pb::SpaceQuotaStatus(*from.quota_status_);
  } else {
    quota_status_ = nullptr;
  }
  ::memcpy(&quota_usage_, &from.quota_usage_,
    static_cast<size_t>(reinterpret_cast<char*>(&quota_limit_) -
    reinterpret_cast<char*>(&quota_usage_)) + sizeof(quota_limit_));
  // @@protoc_insertion_point(copy_constructor:hbase.pb.SpaceQuotaSnapshot)
}

void SpaceQuotaSnapshot::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SpaceQuotaSnapshot_Quota_2eproto.base);
  ::memset(&quota_status_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&quota_limit_) -
      reinterpret_cast<char*>(&quota_status_)) + sizeof(quota_limit_));
}

SpaceQuotaSnapshot::~SpaceQuotaSnapshot() {
  // @@protoc_insertion_point(destructor:hbase.pb.SpaceQuotaSnapshot)
  SharedDtor();
}

void SpaceQuotaSnapshot::SharedDtor() {
  if (this != internal_default_instance()) delete quota_status_;
}

void SpaceQuotaSnapshot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SpaceQuotaSnapshot& SpaceQuotaSnapshot::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SpaceQuotaSnapshot_Quota_2eproto.base);
  return *internal_default_instance();
}


void SpaceQuotaSnapshot::Clear() {
// @@protoc_insertion_point(message_clear_start:hbase.pb.SpaceQuotaSnapshot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(quota_status_ != nullptr);
    quota_status_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&quota_usage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&quota_limit_) -
        reinterpret_cast<char*>(&quota_usage_)) + sizeof(quota_limit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* SpaceQuotaSnapshot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_quota_status(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 quota_usage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_quota_usage(&has_bits);
          quota_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 quota_limit = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_quota_limit(&has_bits);
          quota_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool SpaceQuotaSnapshot::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:hbase.pb.SpaceQuotaSnapshot)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_quota_status()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 quota_usage = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_quota_usage(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_usage_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 quota_limit = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_quota_limit(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &quota_limit_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:hbase.pb.SpaceQuotaSnapshot)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:hbase.pb.SpaceQuotaSnapshot)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void SpaceQuotaSnapshot::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:hbase.pb.SpaceQuotaSnapshot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::quota_status(this), output);
  }

  // optional uint64 quota_usage = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->quota_usage(), output);
  }

  // optional uint64 quota_limit = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(3, this->quota_limit(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:hbase.pb.SpaceQuotaSnapshot)
}

::PROTOBUF_NAMESPACE_ID::uint8* SpaceQuotaSnapshot::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:hbase.pb.SpaceQuotaSnapshot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::quota_status(this), target);
  }

  // optional uint64 quota_usage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->quota_usage(), target);
  }

  // optional uint64 quota_limit = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->quota_limit(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:hbase.pb.SpaceQuotaSnapshot)
  return target;
}

size_t SpaceQuotaSnapshot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:hbase.pb.SpaceQuotaSnapshot)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *quota_status_);
    }

    // optional uint64 quota_usage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->quota_usage());
    }

    // optional uint64 quota_limit = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->quota_limit());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SpaceQuotaSnapshot::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:hbase.pb.SpaceQuotaSnapshot)
  GOOGLE_DCHECK_NE(&from, this);
  const SpaceQuotaSnapshot* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SpaceQuotaSnapshot>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:hbase.pb.SpaceQuotaSnapshot)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:hbase.pb.SpaceQuotaSnapshot)
    MergeFrom(*source);
  }
}

void SpaceQuotaSnapshot::MergeFrom(const SpaceQuotaSnapshot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:hbase.pb.SpaceQuotaSnapshot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_quota_status()->::hbase::pb::SpaceQuotaStatus::MergeFrom(from.quota_status());
    }
    if (cached_has_bits & 0x00000002u) {
      quota_usage_ = from.quota_usage_;
    }
    if (cached_has_bits & 0x00000004u) {
      quota_limit_ = from.quota_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SpaceQuotaSnapshot::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:hbase.pb.SpaceQuotaSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpaceQuotaSnapshot::CopyFrom(const SpaceQuotaSnapshot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:hbase.pb.SpaceQuotaSnapshot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SpaceQuotaSnapshot::IsInitialized() const {
  return true;
}

void SpaceQuotaSnapshot::InternalSwap(SpaceQuotaSnapshot* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(quota_status_, other->quota_status_);
  swap(quota_usage_, other->quota_usage_);
  swap(quota_limit_, other->quota_limit_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SpaceQuotaSnapshot::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::hbase::pb::TimedQuota* Arena::CreateMaybeMessage< ::hbase::pb::TimedQuota >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::TimedQuota >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::Throttle* Arena::CreateMaybeMessage< ::hbase::pb::Throttle >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::Throttle >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::ThrottleRequest* Arena::CreateMaybeMessage< ::hbase::pb::ThrottleRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::ThrottleRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::Quotas* Arena::CreateMaybeMessage< ::hbase::pb::Quotas >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::Quotas >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::QuotaUsage* Arena::CreateMaybeMessage< ::hbase::pb::QuotaUsage >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::QuotaUsage >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::SpaceQuota* Arena::CreateMaybeMessage< ::hbase::pb::SpaceQuota >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::SpaceQuota >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::SpaceLimitRequest* Arena::CreateMaybeMessage< ::hbase::pb::SpaceLimitRequest >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::SpaceLimitRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::SpaceQuotaStatus* Arena::CreateMaybeMessage< ::hbase::pb::SpaceQuotaStatus >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::SpaceQuotaStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::hbase::pb::SpaceQuotaSnapshot* Arena::CreateMaybeMessage< ::hbase::pb::SpaceQuotaSnapshot >(Arena* arena) {
  return Arena::CreateInternal< ::hbase::pb::SpaceQuotaSnapshot >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
