// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Quota.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Quota_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Quota_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Quota_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Quota_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Quota_2eproto;
namespace hbase {
namespace pb {
class QuotaUsage;
class QuotaUsageDefaultTypeInternal;
extern QuotaUsageDefaultTypeInternal _QuotaUsage_default_instance_;
class Quotas;
class QuotasDefaultTypeInternal;
extern QuotasDefaultTypeInternal _Quotas_default_instance_;
class SpaceLimitRequest;
class SpaceLimitRequestDefaultTypeInternal;
extern SpaceLimitRequestDefaultTypeInternal _SpaceLimitRequest_default_instance_;
class SpaceQuota;
class SpaceQuotaDefaultTypeInternal;
extern SpaceQuotaDefaultTypeInternal _SpaceQuota_default_instance_;
class SpaceQuotaSnapshot;
class SpaceQuotaSnapshotDefaultTypeInternal;
extern SpaceQuotaSnapshotDefaultTypeInternal _SpaceQuotaSnapshot_default_instance_;
class SpaceQuotaStatus;
class SpaceQuotaStatusDefaultTypeInternal;
extern SpaceQuotaStatusDefaultTypeInternal _SpaceQuotaStatus_default_instance_;
class Throttle;
class ThrottleDefaultTypeInternal;
extern ThrottleDefaultTypeInternal _Throttle_default_instance_;
class ThrottleRequest;
class ThrottleRequestDefaultTypeInternal;
extern ThrottleRequestDefaultTypeInternal _ThrottleRequest_default_instance_;
class TimedQuota;
class TimedQuotaDefaultTypeInternal;
extern TimedQuotaDefaultTypeInternal _TimedQuota_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::QuotaUsage* Arena::CreateMaybeMessage<::hbase::pb::QuotaUsage>(Arena*);
template<> ::hbase::pb::Quotas* Arena::CreateMaybeMessage<::hbase::pb::Quotas>(Arena*);
template<> ::hbase::pb::SpaceLimitRequest* Arena::CreateMaybeMessage<::hbase::pb::SpaceLimitRequest>(Arena*);
template<> ::hbase::pb::SpaceQuota* Arena::CreateMaybeMessage<::hbase::pb::SpaceQuota>(Arena*);
template<> ::hbase::pb::SpaceQuotaSnapshot* Arena::CreateMaybeMessage<::hbase::pb::SpaceQuotaSnapshot>(Arena*);
template<> ::hbase::pb::SpaceQuotaStatus* Arena::CreateMaybeMessage<::hbase::pb::SpaceQuotaStatus>(Arena*);
template<> ::hbase::pb::Throttle* Arena::CreateMaybeMessage<::hbase::pb::Throttle>(Arena*);
template<> ::hbase::pb::ThrottleRequest* Arena::CreateMaybeMessage<::hbase::pb::ThrottleRequest>(Arena*);
template<> ::hbase::pb::TimedQuota* Arena::CreateMaybeMessage<::hbase::pb::TimedQuota>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum QuotaScope : int {
  CLUSTER = 1,
  MACHINE = 2
};
bool QuotaScope_IsValid(int value);
constexpr QuotaScope QuotaScope_MIN = CLUSTER;
constexpr QuotaScope QuotaScope_MAX = MACHINE;
constexpr int QuotaScope_ARRAYSIZE = QuotaScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotaScope_descriptor();
template<typename T>
inline const std::string& QuotaScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuotaScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuotaScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuotaScope_descriptor(), enum_t_value);
}
inline bool QuotaScope_Parse(
    const std::string& name, QuotaScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuotaScope>(
    QuotaScope_descriptor(), name, value);
}
enum ThrottleType : int {
  REQUEST_NUMBER = 1,
  REQUEST_SIZE = 2,
  WRITE_NUMBER = 3,
  WRITE_SIZE = 4,
  READ_NUMBER = 5,
  READ_SIZE = 6
};
bool ThrottleType_IsValid(int value);
constexpr ThrottleType ThrottleType_MIN = REQUEST_NUMBER;
constexpr ThrottleType ThrottleType_MAX = READ_SIZE;
constexpr int ThrottleType_ARRAYSIZE = ThrottleType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ThrottleType_descriptor();
template<typename T>
inline const std::string& ThrottleType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ThrottleType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ThrottleType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ThrottleType_descriptor(), enum_t_value);
}
inline bool ThrottleType_Parse(
    const std::string& name, ThrottleType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ThrottleType>(
    ThrottleType_descriptor(), name, value);
}
enum QuotaType : int {
  THROTTLE = 1,
  SPACE = 2
};
bool QuotaType_IsValid(int value);
constexpr QuotaType QuotaType_MIN = THROTTLE;
constexpr QuotaType QuotaType_MAX = SPACE;
constexpr int QuotaType_ARRAYSIZE = QuotaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* QuotaType_descriptor();
template<typename T>
inline const std::string& QuotaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, QuotaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function QuotaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    QuotaType_descriptor(), enum_t_value);
}
inline bool QuotaType_Parse(
    const std::string& name, QuotaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<QuotaType>(
    QuotaType_descriptor(), name, value);
}
enum SpaceViolationPolicy : int {
  DISABLE = 1,
  NO_WRITES_COMPACTIONS = 2,
  NO_WRITES = 3,
  NO_INSERTS = 4
};
bool SpaceViolationPolicy_IsValid(int value);
constexpr SpaceViolationPolicy SpaceViolationPolicy_MIN = DISABLE;
constexpr SpaceViolationPolicy SpaceViolationPolicy_MAX = NO_INSERTS;
constexpr int SpaceViolationPolicy_ARRAYSIZE = SpaceViolationPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpaceViolationPolicy_descriptor();
template<typename T>
inline const std::string& SpaceViolationPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpaceViolationPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpaceViolationPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpaceViolationPolicy_descriptor(), enum_t_value);
}
inline bool SpaceViolationPolicy_Parse(
    const std::string& name, SpaceViolationPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpaceViolationPolicy>(
    SpaceViolationPolicy_descriptor(), name, value);
}
// ===================================================================

class TimedQuota :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TimedQuota) */ {
 public:
  TimedQuota();
  virtual ~TimedQuota();

  TimedQuota(const TimedQuota& from);
  TimedQuota(TimedQuota&& from) noexcept
    : TimedQuota() {
    *this = ::std::move(from);
  }

  inline TimedQuota& operator=(const TimedQuota& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimedQuota& operator=(TimedQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TimedQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimedQuota* internal_default_instance() {
    return reinterpret_cast<const TimedQuota*>(
               &_TimedQuota_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(TimedQuota& a, TimedQuota& b) {
    a.Swap(&b);
  }
  inline void Swap(TimedQuota* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TimedQuota* New() const final {
    return CreateMaybeMessage<TimedQuota>(nullptr);
  }

  TimedQuota* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TimedQuota>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TimedQuota& from);
  void MergeFrom(const TimedQuota& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimedQuota* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TimedQuota";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftLimitFieldNumber = 2,
    kShareFieldNumber = 3,
    kTimeUnitFieldNumber = 1,
    kScopeFieldNumber = 4,
  };
  // optional uint64 soft_limit = 2;
  bool has_soft_limit() const;
  void clear_soft_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 soft_limit() const;
  void set_soft_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional float share = 3;
  bool has_share() const;
  void clear_share();
  float share() const;
  void set_share(float value);

  // required .hbase.pb.TimeUnit time_unit = 1;
  bool has_time_unit() const;
  void clear_time_unit();
  ::hbase::pb::TimeUnit time_unit() const;
  void set_time_unit(::hbase::pb::TimeUnit value);

  // optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
  bool has_scope() const;
  void clear_scope();
  ::hbase::pb::QuotaScope scope() const;
  void set_scope(::hbase::pb::QuotaScope value);

  // @@protoc_insertion_point(class_scope:hbase.pb.TimedQuota)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 soft_limit_;
  float share_;
  int time_unit_;
  int scope_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class Throttle :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Throttle) */ {
 public:
  Throttle();
  virtual ~Throttle();

  Throttle(const Throttle& from);
  Throttle(Throttle&& from) noexcept
    : Throttle() {
    *this = ::std::move(from);
  }

  inline Throttle& operator=(const Throttle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Throttle& operator=(Throttle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Throttle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Throttle* internal_default_instance() {
    return reinterpret_cast<const Throttle*>(
               &_Throttle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Throttle& a, Throttle& b) {
    a.Swap(&b);
  }
  inline void Swap(Throttle* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Throttle* New() const final {
    return CreateMaybeMessage<Throttle>(nullptr);
  }

  Throttle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Throttle>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Throttle& from);
  void MergeFrom(const Throttle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Throttle* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Throttle";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReqNumFieldNumber = 1,
    kReqSizeFieldNumber = 2,
    kWriteNumFieldNumber = 3,
    kWriteSizeFieldNumber = 4,
    kReadNumFieldNumber = 5,
    kReadSizeFieldNumber = 6,
  };
  // optional .hbase.pb.TimedQuota req_num = 1;
  bool has_req_num() const;
  void clear_req_num();
  const ::hbase::pb::TimedQuota& req_num() const;
  ::hbase::pb::TimedQuota* release_req_num();
  ::hbase::pb::TimedQuota* mutable_req_num();
  void set_allocated_req_num(::hbase::pb::TimedQuota* req_num);

  // optional .hbase.pb.TimedQuota req_size = 2;
  bool has_req_size() const;
  void clear_req_size();
  const ::hbase::pb::TimedQuota& req_size() const;
  ::hbase::pb::TimedQuota* release_req_size();
  ::hbase::pb::TimedQuota* mutable_req_size();
  void set_allocated_req_size(::hbase::pb::TimedQuota* req_size);

  // optional .hbase.pb.TimedQuota write_num = 3;
  bool has_write_num() const;
  void clear_write_num();
  const ::hbase::pb::TimedQuota& write_num() const;
  ::hbase::pb::TimedQuota* release_write_num();
  ::hbase::pb::TimedQuota* mutable_write_num();
  void set_allocated_write_num(::hbase::pb::TimedQuota* write_num);

  // optional .hbase.pb.TimedQuota write_size = 4;
  bool has_write_size() const;
  void clear_write_size();
  const ::hbase::pb::TimedQuota& write_size() const;
  ::hbase::pb::TimedQuota* release_write_size();
  ::hbase::pb::TimedQuota* mutable_write_size();
  void set_allocated_write_size(::hbase::pb::TimedQuota* write_size);

  // optional .hbase.pb.TimedQuota read_num = 5;
  bool has_read_num() const;
  void clear_read_num();
  const ::hbase::pb::TimedQuota& read_num() const;
  ::hbase::pb::TimedQuota* release_read_num();
  ::hbase::pb::TimedQuota* mutable_read_num();
  void set_allocated_read_num(::hbase::pb::TimedQuota* read_num);

  // optional .hbase.pb.TimedQuota read_size = 6;
  bool has_read_size() const;
  void clear_read_size();
  const ::hbase::pb::TimedQuota& read_size() const;
  ::hbase::pb::TimedQuota* release_read_size();
  ::hbase::pb::TimedQuota* mutable_read_size();
  void set_allocated_read_size(::hbase::pb::TimedQuota* read_size);

  // @@protoc_insertion_point(class_scope:hbase.pb.Throttle)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::TimedQuota* req_num_;
  ::hbase::pb::TimedQuota* req_size_;
  ::hbase::pb::TimedQuota* write_num_;
  ::hbase::pb::TimedQuota* write_size_;
  ::hbase::pb::TimedQuota* read_num_;
  ::hbase::pb::TimedQuota* read_size_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class ThrottleRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ThrottleRequest) */ {
 public:
  ThrottleRequest();
  virtual ~ThrottleRequest();

  ThrottleRequest(const ThrottleRequest& from);
  ThrottleRequest(ThrottleRequest&& from) noexcept
    : ThrottleRequest() {
    *this = ::std::move(from);
  }

  inline ThrottleRequest& operator=(const ThrottleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ThrottleRequest& operator=(ThrottleRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ThrottleRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ThrottleRequest* internal_default_instance() {
    return reinterpret_cast<const ThrottleRequest*>(
               &_ThrottleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ThrottleRequest& a, ThrottleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ThrottleRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ThrottleRequest* New() const final {
    return CreateMaybeMessage<ThrottleRequest>(nullptr);
  }

  ThrottleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ThrottleRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ThrottleRequest& from);
  void MergeFrom(const ThrottleRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ThrottleRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ThrottleRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimedQuotaFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional .hbase.pb.TimedQuota timed_quota = 2;
  bool has_timed_quota() const;
  void clear_timed_quota();
  const ::hbase::pb::TimedQuota& timed_quota() const;
  ::hbase::pb::TimedQuota* release_timed_quota();
  ::hbase::pb::TimedQuota* mutable_timed_quota();
  void set_allocated_timed_quota(::hbase::pb::TimedQuota* timed_quota);

  // optional .hbase.pb.ThrottleType type = 1;
  bool has_type() const;
  void clear_type();
  ::hbase::pb::ThrottleType type() const;
  void set_type(::hbase::pb::ThrottleType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ThrottleRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::TimedQuota* timed_quota_;
  int type_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class Quotas :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Quotas) */ {
 public:
  Quotas();
  virtual ~Quotas();

  Quotas(const Quotas& from);
  Quotas(Quotas&& from) noexcept
    : Quotas() {
    *this = ::std::move(from);
  }

  inline Quotas& operator=(const Quotas& from) {
    CopyFrom(from);
    return *this;
  }
  inline Quotas& operator=(Quotas&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Quotas& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Quotas* internal_default_instance() {
    return reinterpret_cast<const Quotas*>(
               &_Quotas_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Quotas& a, Quotas& b) {
    a.Swap(&b);
  }
  inline void Swap(Quotas* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Quotas* New() const final {
    return CreateMaybeMessage<Quotas>(nullptr);
  }

  Quotas* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Quotas>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Quotas& from);
  void MergeFrom(const Quotas& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Quotas* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Quotas";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThrottleFieldNumber = 2,
    kSpaceFieldNumber = 3,
    kBypassGlobalsFieldNumber = 1,
  };
  // optional .hbase.pb.Throttle throttle = 2;
  bool has_throttle() const;
  void clear_throttle();
  const ::hbase::pb::Throttle& throttle() const;
  ::hbase::pb::Throttle* release_throttle();
  ::hbase::pb::Throttle* mutable_throttle();
  void set_allocated_throttle(::hbase::pb::Throttle* throttle);

  // optional .hbase.pb.SpaceQuota space = 3;
  bool has_space() const;
  void clear_space();
  const ::hbase::pb::SpaceQuota& space() const;
  ::hbase::pb::SpaceQuota* release_space();
  ::hbase::pb::SpaceQuota* mutable_space();
  void set_allocated_space(::hbase::pb::SpaceQuota* space);

  // optional bool bypass_globals = 1 [default = false];
  bool has_bypass_globals() const;
  void clear_bypass_globals();
  bool bypass_globals() const;
  void set_bypass_globals(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Quotas)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::Throttle* throttle_;
  ::hbase::pb::SpaceQuota* space_;
  bool bypass_globals_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class QuotaUsage :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.QuotaUsage) */ {
 public:
  QuotaUsage();
  virtual ~QuotaUsage();

  QuotaUsage(const QuotaUsage& from);
  QuotaUsage(QuotaUsage&& from) noexcept
    : QuotaUsage() {
    *this = ::std::move(from);
  }

  inline QuotaUsage& operator=(const QuotaUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuotaUsage& operator=(QuotaUsage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const QuotaUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const QuotaUsage* internal_default_instance() {
    return reinterpret_cast<const QuotaUsage*>(
               &_QuotaUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(QuotaUsage& a, QuotaUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(QuotaUsage* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline QuotaUsage* New() const final {
    return CreateMaybeMessage<QuotaUsage>(nullptr);
  }

  QuotaUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<QuotaUsage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const QuotaUsage& from);
  void MergeFrom(const QuotaUsage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuotaUsage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.QuotaUsage";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.QuotaUsage)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class SpaceQuota :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SpaceQuota) */ {
 public:
  SpaceQuota();
  virtual ~SpaceQuota();

  SpaceQuota(const SpaceQuota& from);
  SpaceQuota(SpaceQuota&& from) noexcept
    : SpaceQuota() {
    *this = ::std::move(from);
  }

  inline SpaceQuota& operator=(const SpaceQuota& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceQuota& operator=(SpaceQuota&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpaceQuota& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceQuota* internal_default_instance() {
    return reinterpret_cast<const SpaceQuota*>(
               &_SpaceQuota_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SpaceQuota& a, SpaceQuota& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceQuota* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpaceQuota* New() const final {
    return CreateMaybeMessage<SpaceQuota>(nullptr);
  }

  SpaceQuota* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpaceQuota>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpaceQuota& from);
  void MergeFrom(const SpaceQuota& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceQuota* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SpaceQuota";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSoftLimitFieldNumber = 1,
    kRemoveFieldNumber = 3,
    kViolationPolicyFieldNumber = 2,
  };
  // optional uint64 soft_limit = 1;
  bool has_soft_limit() const;
  void clear_soft_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 soft_limit() const;
  void set_soft_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional bool remove = 3 [default = false];
  bool has_remove() const;
  void clear_remove();
  bool remove() const;
  void set_remove(bool value);

  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
  bool has_violation_policy() const;
  void clear_violation_policy();
  ::hbase::pb::SpaceViolationPolicy violation_policy() const;
  void set_violation_policy(::hbase::pb::SpaceViolationPolicy value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SpaceQuota)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 soft_limit_;
  bool remove_;
  int violation_policy_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class SpaceLimitRequest :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SpaceLimitRequest) */ {
 public:
  SpaceLimitRequest();
  virtual ~SpaceLimitRequest();

  SpaceLimitRequest(const SpaceLimitRequest& from);
  SpaceLimitRequest(SpaceLimitRequest&& from) noexcept
    : SpaceLimitRequest() {
    *this = ::std::move(from);
  }

  inline SpaceLimitRequest& operator=(const SpaceLimitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceLimitRequest& operator=(SpaceLimitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpaceLimitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceLimitRequest* internal_default_instance() {
    return reinterpret_cast<const SpaceLimitRequest*>(
               &_SpaceLimitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SpaceLimitRequest& a, SpaceLimitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceLimitRequest* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpaceLimitRequest* New() const final {
    return CreateMaybeMessage<SpaceLimitRequest>(nullptr);
  }

  SpaceLimitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpaceLimitRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpaceLimitRequest& from);
  void MergeFrom(const SpaceLimitRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceLimitRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SpaceLimitRequest";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuotaFieldNumber = 1,
  };
  // optional .hbase.pb.SpaceQuota quota = 1;
  bool has_quota() const;
  void clear_quota();
  const ::hbase::pb::SpaceQuota& quota() const;
  ::hbase::pb::SpaceQuota* release_quota();
  ::hbase::pb::SpaceQuota* mutable_quota();
  void set_allocated_quota(::hbase::pb::SpaceQuota* quota);

  // @@protoc_insertion_point(class_scope:hbase.pb.SpaceLimitRequest)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::SpaceQuota* quota_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class SpaceQuotaStatus :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SpaceQuotaStatus) */ {
 public:
  SpaceQuotaStatus();
  virtual ~SpaceQuotaStatus();

  SpaceQuotaStatus(const SpaceQuotaStatus& from);
  SpaceQuotaStatus(SpaceQuotaStatus&& from) noexcept
    : SpaceQuotaStatus() {
    *this = ::std::move(from);
  }

  inline SpaceQuotaStatus& operator=(const SpaceQuotaStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceQuotaStatus& operator=(SpaceQuotaStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpaceQuotaStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceQuotaStatus* internal_default_instance() {
    return reinterpret_cast<const SpaceQuotaStatus*>(
               &_SpaceQuotaStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SpaceQuotaStatus& a, SpaceQuotaStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceQuotaStatus* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpaceQuotaStatus* New() const final {
    return CreateMaybeMessage<SpaceQuotaStatus>(nullptr);
  }

  SpaceQuotaStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpaceQuotaStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpaceQuotaStatus& from);
  void MergeFrom(const SpaceQuotaStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceQuotaStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SpaceQuotaStatus";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInViolationFieldNumber = 2,
    kViolationPolicyFieldNumber = 1,
  };
  // optional bool in_violation = 2;
  bool has_in_violation() const;
  void clear_in_violation();
  bool in_violation() const;
  void set_in_violation(bool value);

  // optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
  bool has_violation_policy() const;
  void clear_violation_policy();
  ::hbase::pb::SpaceViolationPolicy violation_policy() const;
  void set_violation_policy(::hbase::pb::SpaceViolationPolicy value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SpaceQuotaStatus)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool in_violation_;
  int violation_policy_;
  friend struct ::TableStruct_Quota_2eproto;
};
// -------------------------------------------------------------------

class SpaceQuotaSnapshot :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SpaceQuotaSnapshot) */ {
 public:
  SpaceQuotaSnapshot();
  virtual ~SpaceQuotaSnapshot();

  SpaceQuotaSnapshot(const SpaceQuotaSnapshot& from);
  SpaceQuotaSnapshot(SpaceQuotaSnapshot&& from) noexcept
    : SpaceQuotaSnapshot() {
    *this = ::std::move(from);
  }

  inline SpaceQuotaSnapshot& operator=(const SpaceQuotaSnapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpaceQuotaSnapshot& operator=(SpaceQuotaSnapshot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SpaceQuotaSnapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpaceQuotaSnapshot* internal_default_instance() {
    return reinterpret_cast<const SpaceQuotaSnapshot*>(
               &_SpaceQuotaSnapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SpaceQuotaSnapshot& a, SpaceQuotaSnapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(SpaceQuotaSnapshot* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SpaceQuotaSnapshot* New() const final {
    return CreateMaybeMessage<SpaceQuotaSnapshot>(nullptr);
  }

  SpaceQuotaSnapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SpaceQuotaSnapshot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SpaceQuotaSnapshot& from);
  void MergeFrom(const SpaceQuotaSnapshot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpaceQuotaSnapshot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SpaceQuotaSnapshot";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_Quota_2eproto);
    return ::descriptor_table_Quota_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kQuotaStatusFieldNumber = 1,
    kQuotaUsageFieldNumber = 2,
    kQuotaLimitFieldNumber = 3,
  };
  // optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
  bool has_quota_status() const;
  void clear_quota_status();
  const ::hbase::pb::SpaceQuotaStatus& quota_status() const;
  ::hbase::pb::SpaceQuotaStatus* release_quota_status();
  ::hbase::pb::SpaceQuotaStatus* mutable_quota_status();
  void set_allocated_quota_status(::hbase::pb::SpaceQuotaStatus* quota_status);

  // optional uint64 quota_usage = 2;
  bool has_quota_usage() const;
  void clear_quota_usage();
  ::PROTOBUF_NAMESPACE_ID::uint64 quota_usage() const;
  void set_quota_usage(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 quota_limit = 3;
  bool has_quota_limit() const;
  void clear_quota_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 quota_limit() const;
  void set_quota_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SpaceQuotaSnapshot)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::SpaceQuotaStatus* quota_status_;
  ::PROTOBUF_NAMESPACE_ID::uint64 quota_usage_;
  ::PROTOBUF_NAMESPACE_ID::uint64 quota_limit_;
  friend struct ::TableStruct_Quota_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TimedQuota

// required .hbase.pb.TimeUnit time_unit = 1;
inline bool TimedQuota::has_time_unit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimedQuota::clear_time_unit() {
  time_unit_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hbase::pb::TimeUnit TimedQuota::time_unit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimedQuota.time_unit)
  return static_cast< ::hbase::pb::TimeUnit >(time_unit_);
}
inline void TimedQuota::set_time_unit(::hbase::pb::TimeUnit value) {
  assert(::hbase::pb::TimeUnit_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  time_unit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimedQuota.time_unit)
}

// optional uint64 soft_limit = 2;
inline bool TimedQuota::has_soft_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimedQuota::clear_soft_limit() {
  soft_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TimedQuota::soft_limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimedQuota.soft_limit)
  return soft_limit_;
}
inline void TimedQuota::set_soft_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  soft_limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimedQuota.soft_limit)
}

// optional float share = 3;
inline bool TimedQuota::has_share() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimedQuota::clear_share() {
  share_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float TimedQuota::share() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimedQuota.share)
  return share_;
}
inline void TimedQuota::set_share(float value) {
  _has_bits_[0] |= 0x00000002u;
  share_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimedQuota.share)
}

// optional .hbase.pb.QuotaScope scope = 4 [default = MACHINE];
inline bool TimedQuota::has_scope() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimedQuota::clear_scope() {
  scope_ = 2;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::hbase::pb::QuotaScope TimedQuota::scope() const {
  // @@protoc_insertion_point(field_get:hbase.pb.TimedQuota.scope)
  return static_cast< ::hbase::pb::QuotaScope >(scope_);
}
inline void TimedQuota::set_scope(::hbase::pb::QuotaScope value) {
  assert(::hbase::pb::QuotaScope_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  scope_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.TimedQuota.scope)
}

// -------------------------------------------------------------------

// Throttle

// optional .hbase.pb.TimedQuota req_num = 1;
inline bool Throttle::has_req_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Throttle::clear_req_num() {
  if (req_num_ != nullptr) req_num_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::TimedQuota& Throttle::req_num() const {
  const ::hbase::pb::TimedQuota* p = req_num_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.req_num)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_req_num() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.req_num)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::TimedQuota* temp = req_num_;
  req_num_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_req_num() {
  _has_bits_[0] |= 0x00000001u;
  if (req_num_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    req_num_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.req_num)
  return req_num_;
}
inline void Throttle::set_allocated_req_num(::hbase::pb::TimedQuota* req_num) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete req_num_;
  }
  if (req_num) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      req_num = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req_num, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  req_num_ = req_num;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.req_num)
}

// optional .hbase.pb.TimedQuota req_size = 2;
inline bool Throttle::has_req_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Throttle::clear_req_size() {
  if (req_size_ != nullptr) req_size_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::TimedQuota& Throttle::req_size() const {
  const ::hbase::pb::TimedQuota* p = req_size_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.req_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_req_size() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.req_size)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::TimedQuota* temp = req_size_;
  req_size_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_req_size() {
  _has_bits_[0] |= 0x00000002u;
  if (req_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    req_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.req_size)
  return req_size_;
}
inline void Throttle::set_allocated_req_size(::hbase::pb::TimedQuota* req_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete req_size_;
  }
  if (req_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      req_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, req_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  req_size_ = req_size;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.req_size)
}

// optional .hbase.pb.TimedQuota write_num = 3;
inline bool Throttle::has_write_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Throttle::clear_write_num() {
  if (write_num_ != nullptr) write_num_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::hbase::pb::TimedQuota& Throttle::write_num() const {
  const ::hbase::pb::TimedQuota* p = write_num_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.write_num)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_write_num() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.write_num)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::TimedQuota* temp = write_num_;
  write_num_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_write_num() {
  _has_bits_[0] |= 0x00000004u;
  if (write_num_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    write_num_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.write_num)
  return write_num_;
}
inline void Throttle::set_allocated_write_num(::hbase::pb::TimedQuota* write_num) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete write_num_;
  }
  if (write_num) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      write_num = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, write_num, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  write_num_ = write_num;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.write_num)
}

// optional .hbase.pb.TimedQuota write_size = 4;
inline bool Throttle::has_write_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Throttle::clear_write_size() {
  if (write_size_ != nullptr) write_size_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::hbase::pb::TimedQuota& Throttle::write_size() const {
  const ::hbase::pb::TimedQuota* p = write_size_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.write_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_write_size() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.write_size)
  _has_bits_[0] &= ~0x00000008u;
  ::hbase::pb::TimedQuota* temp = write_size_;
  write_size_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_write_size() {
  _has_bits_[0] |= 0x00000008u;
  if (write_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    write_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.write_size)
  return write_size_;
}
inline void Throttle::set_allocated_write_size(::hbase::pb::TimedQuota* write_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete write_size_;
  }
  if (write_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      write_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, write_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  write_size_ = write_size;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.write_size)
}

// optional .hbase.pb.TimedQuota read_num = 5;
inline bool Throttle::has_read_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Throttle::clear_read_num() {
  if (read_num_ != nullptr) read_num_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::hbase::pb::TimedQuota& Throttle::read_num() const {
  const ::hbase::pb::TimedQuota* p = read_num_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.read_num)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_read_num() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.read_num)
  _has_bits_[0] &= ~0x00000010u;
  ::hbase::pb::TimedQuota* temp = read_num_;
  read_num_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_read_num() {
  _has_bits_[0] |= 0x00000010u;
  if (read_num_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    read_num_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.read_num)
  return read_num_;
}
inline void Throttle::set_allocated_read_num(::hbase::pb::TimedQuota* read_num) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete read_num_;
  }
  if (read_num) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      read_num = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_num, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  read_num_ = read_num;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.read_num)
}

// optional .hbase.pb.TimedQuota read_size = 6;
inline bool Throttle::has_read_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Throttle::clear_read_size() {
  if (read_size_ != nullptr) read_size_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::hbase::pb::TimedQuota& Throttle::read_size() const {
  const ::hbase::pb::TimedQuota* p = read_size_;
  // @@protoc_insertion_point(field_get:hbase.pb.Throttle.read_size)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* Throttle::release_read_size() {
  // @@protoc_insertion_point(field_release:hbase.pb.Throttle.read_size)
  _has_bits_[0] &= ~0x00000020u;
  ::hbase::pb::TimedQuota* temp = read_size_;
  read_size_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* Throttle::mutable_read_size() {
  _has_bits_[0] |= 0x00000020u;
  if (read_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    read_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Throttle.read_size)
  return read_size_;
}
inline void Throttle::set_allocated_read_size(::hbase::pb::TimedQuota* read_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete read_size_;
  }
  if (read_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      read_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  read_size_ = read_size;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Throttle.read_size)
}

// -------------------------------------------------------------------

// ThrottleRequest

// optional .hbase.pb.ThrottleType type = 1;
inline bool ThrottleRequest::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThrottleRequest::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::ThrottleType ThrottleRequest::type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ThrottleRequest.type)
  return static_cast< ::hbase::pb::ThrottleType >(type_);
}
inline void ThrottleRequest::set_type(::hbase::pb::ThrottleType value) {
  assert(::hbase::pb::ThrottleType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ThrottleRequest.type)
}

// optional .hbase.pb.TimedQuota timed_quota = 2;
inline bool ThrottleRequest::has_timed_quota() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThrottleRequest::clear_timed_quota() {
  if (timed_quota_ != nullptr) timed_quota_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::TimedQuota& ThrottleRequest::timed_quota() const {
  const ::hbase::pb::TimedQuota* p = timed_quota_;
  // @@protoc_insertion_point(field_get:hbase.pb.ThrottleRequest.timed_quota)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TimedQuota*>(
      &::hbase::pb::_TimedQuota_default_instance_);
}
inline ::hbase::pb::TimedQuota* ThrottleRequest::release_timed_quota() {
  // @@protoc_insertion_point(field_release:hbase.pb.ThrottleRequest.timed_quota)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::TimedQuota* temp = timed_quota_;
  timed_quota_ = nullptr;
  return temp;
}
inline ::hbase::pb::TimedQuota* ThrottleRequest::mutable_timed_quota() {
  _has_bits_[0] |= 0x00000001u;
  if (timed_quota_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TimedQuota>(GetArenaNoVirtual());
    timed_quota_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.ThrottleRequest.timed_quota)
  return timed_quota_;
}
inline void ThrottleRequest::set_allocated_timed_quota(::hbase::pb::TimedQuota* timed_quota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete timed_quota_;
  }
  if (timed_quota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      timed_quota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timed_quota, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  timed_quota_ = timed_quota;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ThrottleRequest.timed_quota)
}

// -------------------------------------------------------------------

// Quotas

// optional bool bypass_globals = 1 [default = false];
inline bool Quotas::has_bypass_globals() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Quotas::clear_bypass_globals() {
  bypass_globals_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Quotas::bypass_globals() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Quotas.bypass_globals)
  return bypass_globals_;
}
inline void Quotas::set_bypass_globals(bool value) {
  _has_bits_[0] |= 0x00000004u;
  bypass_globals_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Quotas.bypass_globals)
}

// optional .hbase.pb.Throttle throttle = 2;
inline bool Quotas::has_throttle() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Quotas::clear_throttle() {
  if (throttle_ != nullptr) throttle_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::Throttle& Quotas::throttle() const {
  const ::hbase::pb::Throttle* p = throttle_;
  // @@protoc_insertion_point(field_get:hbase.pb.Quotas.throttle)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::Throttle*>(
      &::hbase::pb::_Throttle_default_instance_);
}
inline ::hbase::pb::Throttle* Quotas::release_throttle() {
  // @@protoc_insertion_point(field_release:hbase.pb.Quotas.throttle)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::Throttle* temp = throttle_;
  throttle_ = nullptr;
  return temp;
}
inline ::hbase::pb::Throttle* Quotas::mutable_throttle() {
  _has_bits_[0] |= 0x00000001u;
  if (throttle_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::Throttle>(GetArenaNoVirtual());
    throttle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Quotas.throttle)
  return throttle_;
}
inline void Quotas::set_allocated_throttle(::hbase::pb::Throttle* throttle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete throttle_;
  }
  if (throttle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      throttle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, throttle, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  throttle_ = throttle;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Quotas.throttle)
}

// optional .hbase.pb.SpaceQuota space = 3;
inline bool Quotas::has_space() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Quotas::clear_space() {
  if (space_ != nullptr) space_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hbase::pb::SpaceQuota& Quotas::space() const {
  const ::hbase::pb::SpaceQuota* p = space_;
  // @@protoc_insertion_point(field_get:hbase.pb.Quotas.space)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::SpaceQuota*>(
      &::hbase::pb::_SpaceQuota_default_instance_);
}
inline ::hbase::pb::SpaceQuota* Quotas::release_space() {
  // @@protoc_insertion_point(field_release:hbase.pb.Quotas.space)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::SpaceQuota* temp = space_;
  space_ = nullptr;
  return temp;
}
inline ::hbase::pb::SpaceQuota* Quotas::mutable_space() {
  _has_bits_[0] |= 0x00000002u;
  if (space_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::SpaceQuota>(GetArenaNoVirtual());
    space_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Quotas.space)
  return space_;
}
inline void Quotas::set_allocated_space(::hbase::pb::SpaceQuota* space) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete space_;
  }
  if (space) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      space = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, space, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  space_ = space;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Quotas.space)
}

// -------------------------------------------------------------------

// QuotaUsage

// -------------------------------------------------------------------

// SpaceQuota

// optional uint64 soft_limit = 1;
inline bool SpaceQuota::has_soft_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpaceQuota::clear_soft_limit() {
  soft_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SpaceQuota::soft_limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuota.soft_limit)
  return soft_limit_;
}
inline void SpaceQuota::set_soft_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  soft_limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuota.soft_limit)
}

// optional .hbase.pb.SpaceViolationPolicy violation_policy = 2;
inline bool SpaceQuota::has_violation_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpaceQuota::clear_violation_policy() {
  violation_policy_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hbase::pb::SpaceViolationPolicy SpaceQuota::violation_policy() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuota.violation_policy)
  return static_cast< ::hbase::pb::SpaceViolationPolicy >(violation_policy_);
}
inline void SpaceQuota::set_violation_policy(::hbase::pb::SpaceViolationPolicy value) {
  assert(::hbase::pb::SpaceViolationPolicy_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  violation_policy_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuota.violation_policy)
}

// optional bool remove = 3 [default = false];
inline bool SpaceQuota::has_remove() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpaceQuota::clear_remove() {
  remove_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool SpaceQuota::remove() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuota.remove)
  return remove_;
}
inline void SpaceQuota::set_remove(bool value) {
  _has_bits_[0] |= 0x00000002u;
  remove_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuota.remove)
}

// -------------------------------------------------------------------

// SpaceLimitRequest

// optional .hbase.pb.SpaceQuota quota = 1;
inline bool SpaceLimitRequest::has_quota() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpaceLimitRequest::clear_quota() {
  if (quota_ != nullptr) quota_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::SpaceQuota& SpaceLimitRequest::quota() const {
  const ::hbase::pb::SpaceQuota* p = quota_;
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceLimitRequest.quota)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::SpaceQuota*>(
      &::hbase::pb::_SpaceQuota_default_instance_);
}
inline ::hbase::pb::SpaceQuota* SpaceLimitRequest::release_quota() {
  // @@protoc_insertion_point(field_release:hbase.pb.SpaceLimitRequest.quota)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::SpaceQuota* temp = quota_;
  quota_ = nullptr;
  return temp;
}
inline ::hbase::pb::SpaceQuota* SpaceLimitRequest::mutable_quota() {
  _has_bits_[0] |= 0x00000001u;
  if (quota_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::SpaceQuota>(GetArenaNoVirtual());
    quota_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SpaceLimitRequest.quota)
  return quota_;
}
inline void SpaceLimitRequest::set_allocated_quota(::hbase::pb::SpaceQuota* quota) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quota_;
  }
  if (quota) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quota = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quota, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  quota_ = quota;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SpaceLimitRequest.quota)
}

// -------------------------------------------------------------------

// SpaceQuotaStatus

// optional .hbase.pb.SpaceViolationPolicy violation_policy = 1;
inline bool SpaceQuotaStatus::has_violation_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpaceQuotaStatus::clear_violation_policy() {
  violation_policy_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::SpaceViolationPolicy SpaceQuotaStatus::violation_policy() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuotaStatus.violation_policy)
  return static_cast< ::hbase::pb::SpaceViolationPolicy >(violation_policy_);
}
inline void SpaceQuotaStatus::set_violation_policy(::hbase::pb::SpaceViolationPolicy value) {
  assert(::hbase::pb::SpaceViolationPolicy_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  violation_policy_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuotaStatus.violation_policy)
}

// optional bool in_violation = 2;
inline bool SpaceQuotaStatus::has_in_violation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpaceQuotaStatus::clear_in_violation() {
  in_violation_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SpaceQuotaStatus::in_violation() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuotaStatus.in_violation)
  return in_violation_;
}
inline void SpaceQuotaStatus::set_in_violation(bool value) {
  _has_bits_[0] |= 0x00000001u;
  in_violation_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuotaStatus.in_violation)
}

// -------------------------------------------------------------------

// SpaceQuotaSnapshot

// optional .hbase.pb.SpaceQuotaStatus quota_status = 1;
inline bool SpaceQuotaSnapshot::has_quota_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpaceQuotaSnapshot::clear_quota_status() {
  if (quota_status_ != nullptr) quota_status_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hbase::pb::SpaceQuotaStatus& SpaceQuotaSnapshot::quota_status() const {
  const ::hbase::pb::SpaceQuotaStatus* p = quota_status_;
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuotaSnapshot.quota_status)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::SpaceQuotaStatus*>(
      &::hbase::pb::_SpaceQuotaStatus_default_instance_);
}
inline ::hbase::pb::SpaceQuotaStatus* SpaceQuotaSnapshot::release_quota_status() {
  // @@protoc_insertion_point(field_release:hbase.pb.SpaceQuotaSnapshot.quota_status)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::SpaceQuotaStatus* temp = quota_status_;
  quota_status_ = nullptr;
  return temp;
}
inline ::hbase::pb::SpaceQuotaStatus* SpaceQuotaSnapshot::mutable_quota_status() {
  _has_bits_[0] |= 0x00000001u;
  if (quota_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::SpaceQuotaStatus>(GetArenaNoVirtual());
    quota_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SpaceQuotaSnapshot.quota_status)
  return quota_status_;
}
inline void SpaceQuotaSnapshot::set_allocated_quota_status(::hbase::pb::SpaceQuotaStatus* quota_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quota_status_;
  }
  if (quota_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quota_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quota_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  quota_status_ = quota_status;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SpaceQuotaSnapshot.quota_status)
}

// optional uint64 quota_usage = 2;
inline bool SpaceQuotaSnapshot::has_quota_usage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpaceQuotaSnapshot::clear_quota_usage() {
  quota_usage_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SpaceQuotaSnapshot::quota_usage() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuotaSnapshot.quota_usage)
  return quota_usage_;
}
inline void SpaceQuotaSnapshot::set_quota_usage(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  quota_usage_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuotaSnapshot.quota_usage)
}

// optional uint64 quota_limit = 3;
inline bool SpaceQuotaSnapshot::has_quota_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpaceQuotaSnapshot::clear_quota_limit() {
  quota_limit_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 SpaceQuotaSnapshot::quota_limit() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SpaceQuotaSnapshot.quota_limit)
  return quota_limit_;
}
inline void SpaceQuotaSnapshot::set_quota_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  quota_limit_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SpaceQuotaSnapshot.quota_limit)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::QuotaScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::QuotaScope>() {
  return ::hbase::pb::QuotaScope_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::ThrottleType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ThrottleType>() {
  return ::hbase::pb::ThrottleType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::QuotaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::QuotaType>() {
  return ::hbase::pb::QuotaType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::SpaceViolationPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SpaceViolationPolicy>() {
  return ::hbase::pb::SpaceViolationPolicy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Quota_2eproto
