// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WAL.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_WAL_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_WAL_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_WAL_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_WAL_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_WAL_2eproto;
namespace hbase {
namespace pb {
class BulkLoadDescriptor;
class BulkLoadDescriptorDefaultTypeInternal;
extern BulkLoadDescriptorDefaultTypeInternal _BulkLoadDescriptor_default_instance_;
class CompactionDescriptor;
class CompactionDescriptorDefaultTypeInternal;
extern CompactionDescriptorDefaultTypeInternal _CompactionDescriptor_default_instance_;
class FamilyScope;
class FamilyScopeDefaultTypeInternal;
extern FamilyScopeDefaultTypeInternal _FamilyScope_default_instance_;
class FlushDescriptor;
class FlushDescriptorDefaultTypeInternal;
extern FlushDescriptorDefaultTypeInternal _FlushDescriptor_default_instance_;
class FlushDescriptor_StoreFlushDescriptor;
class FlushDescriptor_StoreFlushDescriptorDefaultTypeInternal;
extern FlushDescriptor_StoreFlushDescriptorDefaultTypeInternal _FlushDescriptor_StoreFlushDescriptor_default_instance_;
class RegionEventDescriptor;
class RegionEventDescriptorDefaultTypeInternal;
extern RegionEventDescriptorDefaultTypeInternal _RegionEventDescriptor_default_instance_;
class StoreDescriptor;
class StoreDescriptorDefaultTypeInternal;
extern StoreDescriptorDefaultTypeInternal _StoreDescriptor_default_instance_;
class WALHeader;
class WALHeaderDefaultTypeInternal;
extern WALHeaderDefaultTypeInternal _WALHeader_default_instance_;
class WALKey;
class WALKeyDefaultTypeInternal;
extern WALKeyDefaultTypeInternal _WALKey_default_instance_;
class WALTrailer;
class WALTrailerDefaultTypeInternal;
extern WALTrailerDefaultTypeInternal _WALTrailer_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::BulkLoadDescriptor* Arena::CreateMaybeMessage<::hbase::pb::BulkLoadDescriptor>(Arena*);
template<> ::hbase::pb::CompactionDescriptor* Arena::CreateMaybeMessage<::hbase::pb::CompactionDescriptor>(Arena*);
template<> ::hbase::pb::FamilyScope* Arena::CreateMaybeMessage<::hbase::pb::FamilyScope>(Arena*);
template<> ::hbase::pb::FlushDescriptor* Arena::CreateMaybeMessage<::hbase::pb::FlushDescriptor>(Arena*);
template<> ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* Arena::CreateMaybeMessage<::hbase::pb::FlushDescriptor_StoreFlushDescriptor>(Arena*);
template<> ::hbase::pb::RegionEventDescriptor* Arena::CreateMaybeMessage<::hbase::pb::RegionEventDescriptor>(Arena*);
template<> ::hbase::pb::StoreDescriptor* Arena::CreateMaybeMessage<::hbase::pb::StoreDescriptor>(Arena*);
template<> ::hbase::pb::WALHeader* Arena::CreateMaybeMessage<::hbase::pb::WALHeader>(Arena*);
template<> ::hbase::pb::WALKey* Arena::CreateMaybeMessage<::hbase::pb::WALKey>(Arena*);
template<> ::hbase::pb::WALTrailer* Arena::CreateMaybeMessage<::hbase::pb::WALTrailer>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum FlushDescriptor_FlushAction : int {
  FlushDescriptor_FlushAction_START_FLUSH = 0,
  FlushDescriptor_FlushAction_COMMIT_FLUSH = 1,
  FlushDescriptor_FlushAction_ABORT_FLUSH = 2,
  FlushDescriptor_FlushAction_CANNOT_FLUSH = 3
};
bool FlushDescriptor_FlushAction_IsValid(int value);
constexpr FlushDescriptor_FlushAction FlushDescriptor_FlushAction_FlushAction_MIN = FlushDescriptor_FlushAction_START_FLUSH;
constexpr FlushDescriptor_FlushAction FlushDescriptor_FlushAction_FlushAction_MAX = FlushDescriptor_FlushAction_CANNOT_FLUSH;
constexpr int FlushDescriptor_FlushAction_FlushAction_ARRAYSIZE = FlushDescriptor_FlushAction_FlushAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FlushDescriptor_FlushAction_descriptor();
template<typename T>
inline const std::string& FlushDescriptor_FlushAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FlushDescriptor_FlushAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FlushDescriptor_FlushAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FlushDescriptor_FlushAction_descriptor(), enum_t_value);
}
inline bool FlushDescriptor_FlushAction_Parse(
    const std::string& name, FlushDescriptor_FlushAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FlushDescriptor_FlushAction>(
    FlushDescriptor_FlushAction_descriptor(), name, value);
}
enum RegionEventDescriptor_EventType : int {
  RegionEventDescriptor_EventType_REGION_OPEN = 0,
  RegionEventDescriptor_EventType_REGION_CLOSE = 1
};
bool RegionEventDescriptor_EventType_IsValid(int value);
constexpr RegionEventDescriptor_EventType RegionEventDescriptor_EventType_EventType_MIN = RegionEventDescriptor_EventType_REGION_OPEN;
constexpr RegionEventDescriptor_EventType RegionEventDescriptor_EventType_EventType_MAX = RegionEventDescriptor_EventType_REGION_CLOSE;
constexpr int RegionEventDescriptor_EventType_EventType_ARRAYSIZE = RegionEventDescriptor_EventType_EventType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RegionEventDescriptor_EventType_descriptor();
template<typename T>
inline const std::string& RegionEventDescriptor_EventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RegionEventDescriptor_EventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RegionEventDescriptor_EventType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RegionEventDescriptor_EventType_descriptor(), enum_t_value);
}
inline bool RegionEventDescriptor_EventType_Parse(
    const std::string& name, RegionEventDescriptor_EventType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RegionEventDescriptor_EventType>(
    RegionEventDescriptor_EventType_descriptor(), name, value);
}
enum ScopeType : int {
  REPLICATION_SCOPE_LOCAL = 0,
  REPLICATION_SCOPE_GLOBAL = 1
};
bool ScopeType_IsValid(int value);
constexpr ScopeType ScopeType_MIN = REPLICATION_SCOPE_LOCAL;
constexpr ScopeType ScopeType_MAX = REPLICATION_SCOPE_GLOBAL;
constexpr int ScopeType_ARRAYSIZE = ScopeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ScopeType_descriptor();
template<typename T>
inline const std::string& ScopeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ScopeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ScopeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ScopeType_descriptor(), enum_t_value);
}
inline bool ScopeType_Parse(
    const std::string& name, ScopeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ScopeType>(
    ScopeType_descriptor(), name, value);
}
// ===================================================================

class WALHeader :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.WALHeader) */ {
 public:
  WALHeader();
  virtual ~WALHeader();

  WALHeader(const WALHeader& from);
  WALHeader(WALHeader&& from) noexcept
    : WALHeader() {
    *this = ::std::move(from);
  }

  inline WALHeader& operator=(const WALHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline WALHeader& operator=(WALHeader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WALHeader& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WALHeader* internal_default_instance() {
    return reinterpret_cast<const WALHeader*>(
               &_WALHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(WALHeader& a, WALHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(WALHeader* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WALHeader* New() const final {
    return CreateMaybeMessage<WALHeader>(nullptr);
  }

  WALHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WALHeader>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WALHeader& from);
  void MergeFrom(const WALHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WALHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.WALHeader";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptionKeyFieldNumber = 2,
    kWriterClsNameFieldNumber = 4,
    kCellCodecClsNameFieldNumber = 5,
    kHasCompressionFieldNumber = 1,
    kHasTagCompressionFieldNumber = 3,
  };
  // optional bytes encryption_key = 2;
  bool has_encryption_key() const;
  void clear_encryption_key();
  const std::string& encryption_key() const;
  void set_encryption_key(const std::string& value);
  void set_encryption_key(std::string&& value);
  void set_encryption_key(const char* value);
  void set_encryption_key(const void* value, size_t size);
  std::string* mutable_encryption_key();
  std::string* release_encryption_key();
  void set_allocated_encryption_key(std::string* encryption_key);

  // optional string writer_cls_name = 4;
  bool has_writer_cls_name() const;
  void clear_writer_cls_name();
  const std::string& writer_cls_name() const;
  void set_writer_cls_name(const std::string& value);
  void set_writer_cls_name(std::string&& value);
  void set_writer_cls_name(const char* value);
  void set_writer_cls_name(const char* value, size_t size);
  std::string* mutable_writer_cls_name();
  std::string* release_writer_cls_name();
  void set_allocated_writer_cls_name(std::string* writer_cls_name);

  // optional string cell_codec_cls_name = 5;
  bool has_cell_codec_cls_name() const;
  void clear_cell_codec_cls_name();
  const std::string& cell_codec_cls_name() const;
  void set_cell_codec_cls_name(const std::string& value);
  void set_cell_codec_cls_name(std::string&& value);
  void set_cell_codec_cls_name(const char* value);
  void set_cell_codec_cls_name(const char* value, size_t size);
  std::string* mutable_cell_codec_cls_name();
  std::string* release_cell_codec_cls_name();
  void set_allocated_cell_codec_cls_name(std::string* cell_codec_cls_name);

  // optional bool has_compression = 1;
  bool has_has_compression() const;
  void clear_has_compression();
  bool has_compression() const;
  void set_has_compression(bool value);

  // optional bool has_tag_compression = 3;
  bool has_has_tag_compression() const;
  void clear_has_tag_compression();
  bool has_tag_compression() const;
  void set_has_tag_compression(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.WALHeader)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encryption_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr writer_cls_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cell_codec_cls_name_;
  bool has_compression_;
  bool has_tag_compression_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class WALKey :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.WALKey) */ {
 public:
  WALKey();
  virtual ~WALKey();

  WALKey(const WALKey& from);
  WALKey(WALKey&& from) noexcept
    : WALKey() {
    *this = ::std::move(from);
  }

  inline WALKey& operator=(const WALKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline WALKey& operator=(WALKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WALKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WALKey* internal_default_instance() {
    return reinterpret_cast<const WALKey*>(
               &_WALKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(WALKey& a, WALKey& b) {
    a.Swap(&b);
  }
  inline void Swap(WALKey* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WALKey* New() const final {
    return CreateMaybeMessage<WALKey>(nullptr);
  }

  WALKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WALKey>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WALKey& from);
  void MergeFrom(const WALKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WALKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.WALKey";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScopesFieldNumber = 6,
    kClusterIdsFieldNumber = 8,
    kEncodedRegionNameFieldNumber = 1,
    kTableNameFieldNumber = 2,
    kClusterIdFieldNumber = 5,
    kLogSequenceNumberFieldNumber = 3,
    kWriteTimeFieldNumber = 4,
    kNonceGroupFieldNumber = 9,
    kNonceFieldNumber = 10,
    kOrigSequenceNumberFieldNumber = 11,
    kFollowingKvCountFieldNumber = 7,
  };
  // repeated .hbase.pb.FamilyScope scopes = 6;
  int scopes_size() const;
  void clear_scopes();
  ::hbase::pb::FamilyScope* mutable_scopes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FamilyScope >*
      mutable_scopes();
  const ::hbase::pb::FamilyScope& scopes(int index) const;
  ::hbase::pb::FamilyScope* add_scopes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FamilyScope >&
      scopes() const;

  // repeated .hbase.pb.UUID cluster_ids = 8;
  int cluster_ids_size() const;
  void clear_cluster_ids();
  ::hbase::pb::UUID* mutable_cluster_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UUID >*
      mutable_cluster_ids();
  const ::hbase::pb::UUID& cluster_ids(int index) const;
  ::hbase::pb::UUID* add_cluster_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UUID >&
      cluster_ids() const;

  // required bytes encoded_region_name = 1;
  bool has_encoded_region_name() const;
  void clear_encoded_region_name();
  const std::string& encoded_region_name() const;
  void set_encoded_region_name(const std::string& value);
  void set_encoded_region_name(std::string&& value);
  void set_encoded_region_name(const char* value);
  void set_encoded_region_name(const void* value, size_t size);
  std::string* mutable_encoded_region_name();
  std::string* release_encoded_region_name();
  void set_allocated_encoded_region_name(std::string* encoded_region_name);

  // required bytes table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const void* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // optional .hbase.pb.UUID cluster_id = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_cluster_id() const;
  PROTOBUF_DEPRECATED void clear_cluster_id();
  PROTOBUF_DEPRECATED const ::hbase::pb::UUID& cluster_id() const;
  PROTOBUF_DEPRECATED ::hbase::pb::UUID* release_cluster_id();
  PROTOBUF_DEPRECATED ::hbase::pb::UUID* mutable_cluster_id();
  PROTOBUF_DEPRECATED void set_allocated_cluster_id(::hbase::pb::UUID* cluster_id);

  // required uint64 log_sequence_number = 3;
  bool has_log_sequence_number() const;
  void clear_log_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_sequence_number() const;
  void set_log_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 write_time = 4;
  bool has_write_time() const;
  void clear_write_time();
  ::PROTOBUF_NAMESPACE_ID::uint64 write_time() const;
  void set_write_time(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 nonceGroup = 9;
  bool has_noncegroup() const;
  void clear_noncegroup();
  ::PROTOBUF_NAMESPACE_ID::uint64 noncegroup() const;
  void set_noncegroup(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 nonce = 10;
  bool has_nonce() const;
  void clear_nonce();
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce() const;
  void set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint64 orig_sequence_number = 11;
  bool has_orig_sequence_number() const;
  void clear_orig_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 orig_sequence_number() const;
  void set_orig_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 following_kv_count = 7;
  bool has_following_kv_count() const;
  void clear_following_kv_count();
  ::PROTOBUF_NAMESPACE_ID::uint32 following_kv_count() const;
  void set_following_kv_count(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.WALKey)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FamilyScope > scopes_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UUID > cluster_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_region_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::hbase::pb::UUID* cluster_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_sequence_number_;
  ::PROTOBUF_NAMESPACE_ID::uint64 write_time_;
  ::PROTOBUF_NAMESPACE_ID::uint64 noncegroup_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nonce_;
  ::PROTOBUF_NAMESPACE_ID::uint64 orig_sequence_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 following_kv_count_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class FamilyScope :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FamilyScope) */ {
 public:
  FamilyScope();
  virtual ~FamilyScope();

  FamilyScope(const FamilyScope& from);
  FamilyScope(FamilyScope&& from) noexcept
    : FamilyScope() {
    *this = ::std::move(from);
  }

  inline FamilyScope& operator=(const FamilyScope& from) {
    CopyFrom(from);
    return *this;
  }
  inline FamilyScope& operator=(FamilyScope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FamilyScope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FamilyScope* internal_default_instance() {
    return reinterpret_cast<const FamilyScope*>(
               &_FamilyScope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FamilyScope& a, FamilyScope& b) {
    a.Swap(&b);
  }
  inline void Swap(FamilyScope* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FamilyScope* New() const final {
    return CreateMaybeMessage<FamilyScope>(nullptr);
  }

  FamilyScope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FamilyScope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FamilyScope& from);
  void MergeFrom(const FamilyScope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FamilyScope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FamilyScope";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamilyFieldNumber = 1,
    kScopeTypeFieldNumber = 2,
  };
  // required bytes family = 1;
  bool has_family() const;
  void clear_family();
  const std::string& family() const;
  void set_family(const std::string& value);
  void set_family(std::string&& value);
  void set_family(const char* value);
  void set_family(const void* value, size_t size);
  std::string* mutable_family();
  std::string* release_family();
  void set_allocated_family(std::string* family);

  // required .hbase.pb.ScopeType scope_type = 2;
  bool has_scope_type() const;
  void clear_scope_type();
  ::hbase::pb::ScopeType scope_type() const;
  void set_scope_type(::hbase::pb::ScopeType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.FamilyScope)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_;
  int scope_type_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class CompactionDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.CompactionDescriptor) */ {
 public:
  CompactionDescriptor();
  virtual ~CompactionDescriptor();

  CompactionDescriptor(const CompactionDescriptor& from);
  CompactionDescriptor(CompactionDescriptor&& from) noexcept
    : CompactionDescriptor() {
    *this = ::std::move(from);
  }

  inline CompactionDescriptor& operator=(const CompactionDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompactionDescriptor& operator=(CompactionDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CompactionDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CompactionDescriptor* internal_default_instance() {
    return reinterpret_cast<const CompactionDescriptor*>(
               &_CompactionDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CompactionDescriptor& a, CompactionDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(CompactionDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CompactionDescriptor* New() const final {
    return CreateMaybeMessage<CompactionDescriptor>(nullptr);
  }

  CompactionDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CompactionDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CompactionDescriptor& from);
  void MergeFrom(const CompactionDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompactionDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.CompactionDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompactionInputFieldNumber = 4,
    kCompactionOutputFieldNumber = 5,
    kTableNameFieldNumber = 1,
    kEncodedRegionNameFieldNumber = 2,
    kFamilyNameFieldNumber = 3,
    kStoreHomeDirFieldNumber = 6,
    kRegionNameFieldNumber = 7,
  };
  // repeated string compaction_input = 4;
  int compaction_input_size() const;
  void clear_compaction_input();
  const std::string& compaction_input(int index) const;
  std::string* mutable_compaction_input(int index);
  void set_compaction_input(int index, const std::string& value);
  void set_compaction_input(int index, std::string&& value);
  void set_compaction_input(int index, const char* value);
  void set_compaction_input(int index, const char* value, size_t size);
  std::string* add_compaction_input();
  void add_compaction_input(const std::string& value);
  void add_compaction_input(std::string&& value);
  void add_compaction_input(const char* value);
  void add_compaction_input(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& compaction_input() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_compaction_input();

  // repeated string compaction_output = 5;
  int compaction_output_size() const;
  void clear_compaction_output();
  const std::string& compaction_output(int index) const;
  std::string* mutable_compaction_output(int index);
  void set_compaction_output(int index, const std::string& value);
  void set_compaction_output(int index, std::string&& value);
  void set_compaction_output(int index, const char* value);
  void set_compaction_output(int index, const char* value, size_t size);
  std::string* add_compaction_output();
  void add_compaction_output(const std::string& value);
  void add_compaction_output(std::string&& value);
  void add_compaction_output(const char* value);
  void add_compaction_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& compaction_output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_compaction_output();

  // required bytes table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const void* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // required bytes encoded_region_name = 2;
  bool has_encoded_region_name() const;
  void clear_encoded_region_name();
  const std::string& encoded_region_name() const;
  void set_encoded_region_name(const std::string& value);
  void set_encoded_region_name(std::string&& value);
  void set_encoded_region_name(const char* value);
  void set_encoded_region_name(const void* value, size_t size);
  std::string* mutable_encoded_region_name();
  std::string* release_encoded_region_name();
  void set_allocated_encoded_region_name(std::string* encoded_region_name);

  // required bytes family_name = 3;
  bool has_family_name() const;
  void clear_family_name();
  const std::string& family_name() const;
  void set_family_name(const std::string& value);
  void set_family_name(std::string&& value);
  void set_family_name(const char* value);
  void set_family_name(const void* value, size_t size);
  std::string* mutable_family_name();
  std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);

  // required string store_home_dir = 6;
  bool has_store_home_dir() const;
  void clear_store_home_dir();
  const std::string& store_home_dir() const;
  void set_store_home_dir(const std::string& value);
  void set_store_home_dir(std::string&& value);
  void set_store_home_dir(const char* value);
  void set_store_home_dir(const char* value, size_t size);
  std::string* mutable_store_home_dir();
  std::string* release_store_home_dir();
  void set_allocated_store_home_dir(std::string* store_home_dir);

  // optional bytes region_name = 7;
  bool has_region_name() const;
  void clear_region_name();
  const std::string& region_name() const;
  void set_region_name(const std::string& value);
  void set_region_name(std::string&& value);
  void set_region_name(const char* value);
  void set_region_name(const void* value, size_t size);
  std::string* mutable_region_name();
  std::string* release_region_name();
  void set_allocated_region_name(std::string* region_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.CompactionDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> compaction_input_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> compaction_output_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_region_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_home_dir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_name_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class FlushDescriptor_StoreFlushDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FlushDescriptor.StoreFlushDescriptor) */ {
 public:
  FlushDescriptor_StoreFlushDescriptor();
  virtual ~FlushDescriptor_StoreFlushDescriptor();

  FlushDescriptor_StoreFlushDescriptor(const FlushDescriptor_StoreFlushDescriptor& from);
  FlushDescriptor_StoreFlushDescriptor(FlushDescriptor_StoreFlushDescriptor&& from) noexcept
    : FlushDescriptor_StoreFlushDescriptor() {
    *this = ::std::move(from);
  }

  inline FlushDescriptor_StoreFlushDescriptor& operator=(const FlushDescriptor_StoreFlushDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushDescriptor_StoreFlushDescriptor& operator=(FlushDescriptor_StoreFlushDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushDescriptor_StoreFlushDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushDescriptor_StoreFlushDescriptor* internal_default_instance() {
    return reinterpret_cast<const FlushDescriptor_StoreFlushDescriptor*>(
               &_FlushDescriptor_StoreFlushDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FlushDescriptor_StoreFlushDescriptor& a, FlushDescriptor_StoreFlushDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushDescriptor_StoreFlushDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushDescriptor_StoreFlushDescriptor* New() const final {
    return CreateMaybeMessage<FlushDescriptor_StoreFlushDescriptor>(nullptr);
  }

  FlushDescriptor_StoreFlushDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushDescriptor_StoreFlushDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushDescriptor_StoreFlushDescriptor& from);
  void MergeFrom(const FlushDescriptor_StoreFlushDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushDescriptor_StoreFlushDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FlushDescriptor.StoreFlushDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlushOutputFieldNumber = 3,
    kFamilyNameFieldNumber = 1,
    kStoreHomeDirFieldNumber = 2,
  };
  // repeated string flush_output = 3;
  int flush_output_size() const;
  void clear_flush_output();
  const std::string& flush_output(int index) const;
  std::string* mutable_flush_output(int index);
  void set_flush_output(int index, const std::string& value);
  void set_flush_output(int index, std::string&& value);
  void set_flush_output(int index, const char* value);
  void set_flush_output(int index, const char* value, size_t size);
  std::string* add_flush_output();
  void add_flush_output(const std::string& value);
  void add_flush_output(std::string&& value);
  void add_flush_output(const char* value);
  void add_flush_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& flush_output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_flush_output();

  // required bytes family_name = 1;
  bool has_family_name() const;
  void clear_family_name();
  const std::string& family_name() const;
  void set_family_name(const std::string& value);
  void set_family_name(std::string&& value);
  void set_family_name(const char* value);
  void set_family_name(const void* value, size_t size);
  std::string* mutable_family_name();
  std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);

  // required string store_home_dir = 2;
  bool has_store_home_dir() const;
  void clear_store_home_dir();
  const std::string& store_home_dir() const;
  void set_store_home_dir(const std::string& value);
  void set_store_home_dir(std::string&& value);
  void set_store_home_dir(const char* value);
  void set_store_home_dir(const char* value, size_t size);
  std::string* mutable_store_home_dir();
  std::string* release_store_home_dir();
  void set_allocated_store_home_dir(std::string* store_home_dir);

  // @@protoc_insertion_point(class_scope:hbase.pb.FlushDescriptor.StoreFlushDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> flush_output_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_home_dir_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class FlushDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.FlushDescriptor) */ {
 public:
  FlushDescriptor();
  virtual ~FlushDescriptor();

  FlushDescriptor(const FlushDescriptor& from);
  FlushDescriptor(FlushDescriptor&& from) noexcept
    : FlushDescriptor() {
    *this = ::std::move(from);
  }

  inline FlushDescriptor& operator=(const FlushDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlushDescriptor& operator=(FlushDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const FlushDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FlushDescriptor* internal_default_instance() {
    return reinterpret_cast<const FlushDescriptor*>(
               &_FlushDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FlushDescriptor& a, FlushDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(FlushDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FlushDescriptor* New() const final {
    return CreateMaybeMessage<FlushDescriptor>(nullptr);
  }

  FlushDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FlushDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const FlushDescriptor& from);
  void MergeFrom(const FlushDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlushDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.FlushDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef FlushDescriptor_StoreFlushDescriptor StoreFlushDescriptor;

  typedef FlushDescriptor_FlushAction FlushAction;
  static constexpr FlushAction START_FLUSH =
    FlushDescriptor_FlushAction_START_FLUSH;
  static constexpr FlushAction COMMIT_FLUSH =
    FlushDescriptor_FlushAction_COMMIT_FLUSH;
  static constexpr FlushAction ABORT_FLUSH =
    FlushDescriptor_FlushAction_ABORT_FLUSH;
  static constexpr FlushAction CANNOT_FLUSH =
    FlushDescriptor_FlushAction_CANNOT_FLUSH;
  static inline bool FlushAction_IsValid(int value) {
    return FlushDescriptor_FlushAction_IsValid(value);
  }
  static constexpr FlushAction FlushAction_MIN =
    FlushDescriptor_FlushAction_FlushAction_MIN;
  static constexpr FlushAction FlushAction_MAX =
    FlushDescriptor_FlushAction_FlushAction_MAX;
  static constexpr int FlushAction_ARRAYSIZE =
    FlushDescriptor_FlushAction_FlushAction_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FlushAction_descriptor() {
    return FlushDescriptor_FlushAction_descriptor();
  }
  template<typename T>
  static inline const std::string& FlushAction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FlushAction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FlushAction_Name.");
    return FlushDescriptor_FlushAction_Name(enum_t_value);
  }
  static inline bool FlushAction_Parse(const std::string& name,
      FlushAction* value) {
    return FlushDescriptor_FlushAction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStoreFlushesFieldNumber = 5,
    kTableNameFieldNumber = 2,
    kEncodedRegionNameFieldNumber = 3,
    kRegionNameFieldNumber = 6,
    kFlushSequenceNumberFieldNumber = 4,
    kActionFieldNumber = 1,
  };
  // repeated .hbase.pb.FlushDescriptor.StoreFlushDescriptor store_flushes = 5;
  int store_flushes_size() const;
  void clear_store_flushes();
  ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* mutable_store_flushes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >*
      mutable_store_flushes();
  const ::hbase::pb::FlushDescriptor_StoreFlushDescriptor& store_flushes(int index) const;
  ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* add_store_flushes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >&
      store_flushes() const;

  // required bytes table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const void* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // required bytes encoded_region_name = 3;
  bool has_encoded_region_name() const;
  void clear_encoded_region_name();
  const std::string& encoded_region_name() const;
  void set_encoded_region_name(const std::string& value);
  void set_encoded_region_name(std::string&& value);
  void set_encoded_region_name(const char* value);
  void set_encoded_region_name(const void* value, size_t size);
  std::string* mutable_encoded_region_name();
  std::string* release_encoded_region_name();
  void set_allocated_encoded_region_name(std::string* encoded_region_name);

  // optional bytes region_name = 6;
  bool has_region_name() const;
  void clear_region_name();
  const std::string& region_name() const;
  void set_region_name(const std::string& value);
  void set_region_name(std::string&& value);
  void set_region_name(const char* value);
  void set_region_name(const void* value, size_t size);
  std::string* mutable_region_name();
  std::string* release_region_name();
  void set_allocated_region_name(std::string* region_name);

  // optional uint64 flush_sequence_number = 4;
  bool has_flush_sequence_number() const;
  void clear_flush_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_sequence_number() const;
  void set_flush_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required .hbase.pb.FlushDescriptor.FlushAction action = 1;
  bool has_action() const;
  void clear_action();
  ::hbase::pb::FlushDescriptor_FlushAction action() const;
  void set_action(::hbase::pb::FlushDescriptor_FlushAction value);

  // @@protoc_insertion_point(class_scope:hbase.pb.FlushDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor > store_flushes_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_region_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flush_sequence_number_;
  int action_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class StoreDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.StoreDescriptor) */ {
 public:
  StoreDescriptor();
  virtual ~StoreDescriptor();

  StoreDescriptor(const StoreDescriptor& from);
  StoreDescriptor(StoreDescriptor&& from) noexcept
    : StoreDescriptor() {
    *this = ::std::move(from);
  }

  inline StoreDescriptor& operator=(const StoreDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreDescriptor& operator=(StoreDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const StoreDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StoreDescriptor* internal_default_instance() {
    return reinterpret_cast<const StoreDescriptor*>(
               &_StoreDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StoreDescriptor& a, StoreDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StoreDescriptor* New() const final {
    return CreateMaybeMessage<StoreDescriptor>(nullptr);
  }

  StoreDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StoreDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const StoreDescriptor& from);
  void MergeFrom(const StoreDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.StoreDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreFileFieldNumber = 3,
    kFamilyNameFieldNumber = 1,
    kStoreHomeDirFieldNumber = 2,
    kStoreFileSizeBytesFieldNumber = 4,
  };
  // repeated string store_file = 3;
  int store_file_size() const;
  void clear_store_file();
  const std::string& store_file(int index) const;
  std::string* mutable_store_file(int index);
  void set_store_file(int index, const std::string& value);
  void set_store_file(int index, std::string&& value);
  void set_store_file(int index, const char* value);
  void set_store_file(int index, const char* value, size_t size);
  std::string* add_store_file();
  void add_store_file(const std::string& value);
  void add_store_file(std::string&& value);
  void add_store_file(const char* value);
  void add_store_file(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& store_file() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_store_file();

  // required bytes family_name = 1;
  bool has_family_name() const;
  void clear_family_name();
  const std::string& family_name() const;
  void set_family_name(const std::string& value);
  void set_family_name(std::string&& value);
  void set_family_name(const char* value);
  void set_family_name(const void* value, size_t size);
  std::string* mutable_family_name();
  std::string* release_family_name();
  void set_allocated_family_name(std::string* family_name);

  // required string store_home_dir = 2;
  bool has_store_home_dir() const;
  void clear_store_home_dir();
  const std::string& store_home_dir() const;
  void set_store_home_dir(const std::string& value);
  void set_store_home_dir(std::string&& value);
  void set_store_home_dir(const char* value);
  void set_store_home_dir(const char* value, size_t size);
  std::string* mutable_store_home_dir();
  std::string* release_store_home_dir();
  void set_allocated_store_home_dir(std::string* store_home_dir);

  // optional uint64 store_file_size_bytes = 4;
  bool has_store_file_size_bytes() const;
  void clear_store_file_size_bytes();
  ::PROTOBUF_NAMESPACE_ID::uint64 store_file_size_bytes() const;
  void set_store_file_size_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.StoreDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> store_file_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr family_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_home_dir_;
  ::PROTOBUF_NAMESPACE_ID::uint64 store_file_size_bytes_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class BulkLoadDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.BulkLoadDescriptor) */ {
 public:
  BulkLoadDescriptor();
  virtual ~BulkLoadDescriptor();

  BulkLoadDescriptor(const BulkLoadDescriptor& from);
  BulkLoadDescriptor(BulkLoadDescriptor&& from) noexcept
    : BulkLoadDescriptor() {
    *this = ::std::move(from);
  }

  inline BulkLoadDescriptor& operator=(const BulkLoadDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline BulkLoadDescriptor& operator=(BulkLoadDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BulkLoadDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BulkLoadDescriptor* internal_default_instance() {
    return reinterpret_cast<const BulkLoadDescriptor*>(
               &_BulkLoadDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BulkLoadDescriptor& a, BulkLoadDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(BulkLoadDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BulkLoadDescriptor* New() const final {
    return CreateMaybeMessage<BulkLoadDescriptor>(nullptr);
  }

  BulkLoadDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BulkLoadDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BulkLoadDescriptor& from);
  void MergeFrom(const BulkLoadDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BulkLoadDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.BulkLoadDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoresFieldNumber = 3,
    kEncodedRegionNameFieldNumber = 2,
    kTableNameFieldNumber = 1,
    kBulkloadSeqNumFieldNumber = 4,
  };
  // repeated .hbase.pb.StoreDescriptor stores = 3;
  int stores_size() const;
  void clear_stores();
  ::hbase::pb::StoreDescriptor* mutable_stores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
      mutable_stores();
  const ::hbase::pb::StoreDescriptor& stores(int index) const;
  ::hbase::pb::StoreDescriptor* add_stores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
      stores() const;

  // required bytes encoded_region_name = 2;
  bool has_encoded_region_name() const;
  void clear_encoded_region_name();
  const std::string& encoded_region_name() const;
  void set_encoded_region_name(const std::string& value);
  void set_encoded_region_name(std::string&& value);
  void set_encoded_region_name(const char* value);
  void set_encoded_region_name(const void* value, size_t size);
  std::string* mutable_encoded_region_name();
  std::string* release_encoded_region_name();
  void set_allocated_encoded_region_name(std::string* encoded_region_name);

  // required .hbase.pb.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // required int64 bulkload_seq_num = 4;
  bool has_bulkload_seq_num() const;
  void clear_bulkload_seq_num();
  ::PROTOBUF_NAMESPACE_ID::int64 bulkload_seq_num() const;
  void set_bulkload_seq_num(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.BulkLoadDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor > stores_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_region_name_;
  ::hbase::pb::TableName* table_name_;
  ::PROTOBUF_NAMESPACE_ID::int64 bulkload_seq_num_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class RegionEventDescriptor :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.RegionEventDescriptor) */ {
 public:
  RegionEventDescriptor();
  virtual ~RegionEventDescriptor();

  RegionEventDescriptor(const RegionEventDescriptor& from);
  RegionEventDescriptor(RegionEventDescriptor&& from) noexcept
    : RegionEventDescriptor() {
    *this = ::std::move(from);
  }

  inline RegionEventDescriptor& operator=(const RegionEventDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegionEventDescriptor& operator=(RegionEventDescriptor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RegionEventDescriptor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionEventDescriptor* internal_default_instance() {
    return reinterpret_cast<const RegionEventDescriptor*>(
               &_RegionEventDescriptor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegionEventDescriptor& a, RegionEventDescriptor& b) {
    a.Swap(&b);
  }
  inline void Swap(RegionEventDescriptor* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegionEventDescriptor* New() const final {
    return CreateMaybeMessage<RegionEventDescriptor>(nullptr);
  }

  RegionEventDescriptor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegionEventDescriptor>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RegionEventDescriptor& from);
  void MergeFrom(const RegionEventDescriptor& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionEventDescriptor* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.RegionEventDescriptor";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef RegionEventDescriptor_EventType EventType;
  static constexpr EventType REGION_OPEN =
    RegionEventDescriptor_EventType_REGION_OPEN;
  static constexpr EventType REGION_CLOSE =
    RegionEventDescriptor_EventType_REGION_CLOSE;
  static inline bool EventType_IsValid(int value) {
    return RegionEventDescriptor_EventType_IsValid(value);
  }
  static constexpr EventType EventType_MIN =
    RegionEventDescriptor_EventType_EventType_MIN;
  static constexpr EventType EventType_MAX =
    RegionEventDescriptor_EventType_EventType_MAX;
  static constexpr int EventType_ARRAYSIZE =
    RegionEventDescriptor_EventType_EventType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EventType_descriptor() {
    return RegionEventDescriptor_EventType_descriptor();
  }
  template<typename T>
  static inline const std::string& EventType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EventType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EventType_Name.");
    return RegionEventDescriptor_EventType_Name(enum_t_value);
  }
  static inline bool EventType_Parse(const std::string& name,
      EventType* value) {
    return RegionEventDescriptor_EventType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStoresFieldNumber = 5,
    kTableNameFieldNumber = 2,
    kEncodedRegionNameFieldNumber = 3,
    kRegionNameFieldNumber = 7,
    kServerFieldNumber = 6,
    kLogSequenceNumberFieldNumber = 4,
    kEventTypeFieldNumber = 1,
  };
  // repeated .hbase.pb.StoreDescriptor stores = 5;
  int stores_size() const;
  void clear_stores();
  ::hbase::pb::StoreDescriptor* mutable_stores(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
      mutable_stores();
  const ::hbase::pb::StoreDescriptor& stores(int index) const;
  ::hbase::pb::StoreDescriptor* add_stores();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
      stores() const;

  // required bytes table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  const std::string& table_name() const;
  void set_table_name(const std::string& value);
  void set_table_name(std::string&& value);
  void set_table_name(const char* value);
  void set_table_name(const void* value, size_t size);
  std::string* mutable_table_name();
  std::string* release_table_name();
  void set_allocated_table_name(std::string* table_name);

  // required bytes encoded_region_name = 3;
  bool has_encoded_region_name() const;
  void clear_encoded_region_name();
  const std::string& encoded_region_name() const;
  void set_encoded_region_name(const std::string& value);
  void set_encoded_region_name(std::string&& value);
  void set_encoded_region_name(const char* value);
  void set_encoded_region_name(const void* value, size_t size);
  std::string* mutable_encoded_region_name();
  std::string* release_encoded_region_name();
  void set_allocated_encoded_region_name(std::string* encoded_region_name);

  // optional bytes region_name = 7;
  bool has_region_name() const;
  void clear_region_name();
  const std::string& region_name() const;
  void set_region_name(const std::string& value);
  void set_region_name(std::string&& value);
  void set_region_name(const char* value);
  void set_region_name(const void* value, size_t size);
  std::string* mutable_region_name();
  std::string* release_region_name();
  void set_allocated_region_name(std::string* region_name);

  // optional .hbase.pb.ServerName server = 6;
  bool has_server() const;
  void clear_server();
  const ::hbase::pb::ServerName& server() const;
  ::hbase::pb::ServerName* release_server();
  ::hbase::pb::ServerName* mutable_server();
  void set_allocated_server(::hbase::pb::ServerName* server);

  // optional uint64 log_sequence_number = 4;
  bool has_log_sequence_number() const;
  void clear_log_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 log_sequence_number() const;
  void set_log_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required .hbase.pb.RegionEventDescriptor.EventType event_type = 1;
  bool has_event_type() const;
  void clear_event_type();
  ::hbase::pb::RegionEventDescriptor_EventType event_type() const;
  void set_event_type(::hbase::pb::RegionEventDescriptor_EventType value);

  // @@protoc_insertion_point(class_scope:hbase.pb.RegionEventDescriptor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor > stores_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr table_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encoded_region_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_name_;
  ::hbase::pb::ServerName* server_;
  ::PROTOBUF_NAMESPACE_ID::uint64 log_sequence_number_;
  int event_type_;
  friend struct ::TableStruct_WAL_2eproto;
};
// -------------------------------------------------------------------

class WALTrailer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.WALTrailer) */ {
 public:
  WALTrailer();
  virtual ~WALTrailer();

  WALTrailer(const WALTrailer& from);
  WALTrailer(WALTrailer&& from) noexcept
    : WALTrailer() {
    *this = ::std::move(from);
  }

  inline WALTrailer& operator=(const WALTrailer& from) {
    CopyFrom(from);
    return *this;
  }
  inline WALTrailer& operator=(WALTrailer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const WALTrailer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WALTrailer* internal_default_instance() {
    return reinterpret_cast<const WALTrailer*>(
               &_WALTrailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(WALTrailer& a, WALTrailer& b) {
    a.Swap(&b);
  }
  inline void Swap(WALTrailer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline WALTrailer* New() const final {
    return CreateMaybeMessage<WALTrailer>(nullptr);
  }

  WALTrailer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<WALTrailer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const WALTrailer& from);
  void MergeFrom(const WALTrailer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WALTrailer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.WALTrailer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_WAL_2eproto);
    return ::descriptor_table_WAL_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hbase.pb.WALTrailer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_WAL_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// WALHeader

// optional bool has_compression = 1;
inline bool WALHeader::has_has_compression() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WALHeader::clear_has_compression() {
  has_compression_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool WALHeader::has_compression() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALHeader.has_compression)
  return has_compression_;
}
inline void WALHeader::set_has_compression(bool value) {
  _has_bits_[0] |= 0x00000008u;
  has_compression_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALHeader.has_compression)
}

// optional bytes encryption_key = 2;
inline bool WALHeader::has_encryption_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WALHeader::clear_encryption_key() {
  encryption_key_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WALHeader::encryption_key() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALHeader.encryption_key)
  return encryption_key_.GetNoArena();
}
inline void WALHeader::set_encryption_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.WALHeader.encryption_key)
}
inline void WALHeader::set_encryption_key(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encryption_key_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.WALHeader.encryption_key)
}
inline void WALHeader::set_encryption_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encryption_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.WALHeader.encryption_key)
}
inline void WALHeader::set_encryption_key(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encryption_key_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.WALHeader.encryption_key)
}
inline std::string* WALHeader::mutable_encryption_key() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALHeader.encryption_key)
  return encryption_key_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WALHeader::release_encryption_key() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALHeader.encryption_key)
  if (!has_encryption_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encryption_key_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WALHeader::set_allocated_encryption_key(std::string* encryption_key) {
  if (encryption_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encryption_key_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encryption_key);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALHeader.encryption_key)
}

// optional bool has_tag_compression = 3;
inline bool WALHeader::has_has_tag_compression() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WALHeader::clear_has_tag_compression() {
  has_tag_compression_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool WALHeader::has_tag_compression() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALHeader.has_tag_compression)
  return has_tag_compression_;
}
inline void WALHeader::set_has_tag_compression(bool value) {
  _has_bits_[0] |= 0x00000010u;
  has_tag_compression_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALHeader.has_tag_compression)
}

// optional string writer_cls_name = 4;
inline bool WALHeader::has_writer_cls_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WALHeader::clear_writer_cls_name() {
  writer_cls_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WALHeader::writer_cls_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALHeader.writer_cls_name)
  return writer_cls_name_.GetNoArena();
}
inline void WALHeader::set_writer_cls_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  writer_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.WALHeader.writer_cls_name)
}
inline void WALHeader::set_writer_cls_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  writer_cls_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.WALHeader.writer_cls_name)
}
inline void WALHeader::set_writer_cls_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  writer_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.WALHeader.writer_cls_name)
}
inline void WALHeader::set_writer_cls_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  writer_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.WALHeader.writer_cls_name)
}
inline std::string* WALHeader::mutable_writer_cls_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALHeader.writer_cls_name)
  return writer_cls_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WALHeader::release_writer_cls_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALHeader.writer_cls_name)
  if (!has_writer_cls_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return writer_cls_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WALHeader::set_allocated_writer_cls_name(std::string* writer_cls_name) {
  if (writer_cls_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  writer_cls_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), writer_cls_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALHeader.writer_cls_name)
}

// optional string cell_codec_cls_name = 5;
inline bool WALHeader::has_cell_codec_cls_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WALHeader::clear_cell_codec_cls_name() {
  cell_codec_cls_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& WALHeader::cell_codec_cls_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALHeader.cell_codec_cls_name)
  return cell_codec_cls_name_.GetNoArena();
}
inline void WALHeader::set_cell_codec_cls_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cell_codec_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.WALHeader.cell_codec_cls_name)
}
inline void WALHeader::set_cell_codec_cls_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  cell_codec_cls_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.WALHeader.cell_codec_cls_name)
}
inline void WALHeader::set_cell_codec_cls_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  cell_codec_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.WALHeader.cell_codec_cls_name)
}
inline void WALHeader::set_cell_codec_cls_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  cell_codec_cls_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.WALHeader.cell_codec_cls_name)
}
inline std::string* WALHeader::mutable_cell_codec_cls_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALHeader.cell_codec_cls_name)
  return cell_codec_cls_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WALHeader::release_cell_codec_cls_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALHeader.cell_codec_cls_name)
  if (!has_cell_codec_cls_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return cell_codec_cls_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WALHeader::set_allocated_cell_codec_cls_name(std::string* cell_codec_cls_name) {
  if (cell_codec_cls_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cell_codec_cls_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cell_codec_cls_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALHeader.cell_codec_cls_name)
}

// -------------------------------------------------------------------

// WALKey

// required bytes encoded_region_name = 1;
inline bool WALKey::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WALKey::clear_encoded_region_name() {
  encoded_region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& WALKey::encoded_region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.encoded_region_name)
  return encoded_region_name_.GetNoArena();
}
inline void WALKey::set_encoded_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.encoded_region_name)
}
inline void WALKey::set_encoded_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.WALKey.encoded_region_name)
}
inline void WALKey::set_encoded_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.WALKey.encoded_region_name)
}
inline void WALKey::set_encoded_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.WALKey.encoded_region_name)
}
inline std::string* WALKey::mutable_encoded_region_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALKey.encoded_region_name)
  return encoded_region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WALKey::release_encoded_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALKey.encoded_region_name)
  if (!has_encoded_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encoded_region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WALKey::set_allocated_encoded_region_name(std::string* encoded_region_name) {
  if (encoded_region_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALKey.encoded_region_name)
}

// required bytes table_name = 2;
inline bool WALKey::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WALKey::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& WALKey::table_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.table_name)
  return table_name_.GetNoArena();
}
inline void WALKey::set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.table_name)
}
inline void WALKey::set_table_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.WALKey.table_name)
}
inline void WALKey::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.WALKey.table_name)
}
inline void WALKey::set_table_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.WALKey.table_name)
}
inline std::string* WALKey::mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALKey.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* WALKey::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALKey.table_name)
  if (!has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return table_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void WALKey::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALKey.table_name)
}

// required uint64 log_sequence_number = 3;
inline bool WALKey::has_log_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WALKey::clear_log_sequence_number() {
  log_sequence_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WALKey::log_sequence_number() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.log_sequence_number)
  return log_sequence_number_;
}
inline void WALKey::set_log_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  log_sequence_number_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.log_sequence_number)
}

// required uint64 write_time = 4;
inline bool WALKey::has_write_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WALKey::clear_write_time() {
  write_time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WALKey::write_time() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.write_time)
  return write_time_;
}
inline void WALKey::set_write_time(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  write_time_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.write_time)
}

// optional .hbase.pb.UUID cluster_id = 5 [deprecated = true];
inline bool WALKey::has_cluster_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::hbase::pb::UUID& WALKey::cluster_id() const {
  const ::hbase::pb::UUID* p = cluster_id_;
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.cluster_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::UUID*>(
      &::hbase::pb::_UUID_default_instance_);
}
inline ::hbase::pb::UUID* WALKey::release_cluster_id() {
  // @@protoc_insertion_point(field_release:hbase.pb.WALKey.cluster_id)
  _has_bits_[0] &= ~0x00000004u;
  ::hbase::pb::UUID* temp = cluster_id_;
  cluster_id_ = nullptr;
  return temp;
}
inline ::hbase::pb::UUID* WALKey::mutable_cluster_id() {
  _has_bits_[0] |= 0x00000004u;
  if (cluster_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::UUID>(GetArenaNoVirtual());
    cluster_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALKey.cluster_id)
  return cluster_id_;
}
inline void WALKey::set_allocated_cluster_id(::hbase::pb::UUID* cluster_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cluster_id_);
  }
  if (cluster_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cluster_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cluster_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cluster_id_ = cluster_id;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.WALKey.cluster_id)
}

// repeated .hbase.pb.FamilyScope scopes = 6;
inline int WALKey::scopes_size() const {
  return scopes_.size();
}
inline void WALKey::clear_scopes() {
  scopes_.Clear();
}
inline ::hbase::pb::FamilyScope* WALKey::mutable_scopes(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALKey.scopes)
  return scopes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FamilyScope >*
WALKey::mutable_scopes() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.WALKey.scopes)
  return &scopes_;
}
inline const ::hbase::pb::FamilyScope& WALKey::scopes(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.scopes)
  return scopes_.Get(index);
}
inline ::hbase::pb::FamilyScope* WALKey::add_scopes() {
  // @@protoc_insertion_point(field_add:hbase.pb.WALKey.scopes)
  return scopes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FamilyScope >&
WALKey::scopes() const {
  // @@protoc_insertion_point(field_list:hbase.pb.WALKey.scopes)
  return scopes_;
}

// optional uint32 following_kv_count = 7;
inline bool WALKey::has_following_kv_count() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WALKey::clear_following_kv_count() {
  following_kv_count_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 WALKey::following_kv_count() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.following_kv_count)
  return following_kv_count_;
}
inline void WALKey::set_following_kv_count(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000100u;
  following_kv_count_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.following_kv_count)
}

// repeated .hbase.pb.UUID cluster_ids = 8;
inline int WALKey::cluster_ids_size() const {
  return cluster_ids_.size();
}
inline ::hbase::pb::UUID* WALKey::mutable_cluster_ids(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.WALKey.cluster_ids)
  return cluster_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UUID >*
WALKey::mutable_cluster_ids() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.WALKey.cluster_ids)
  return &cluster_ids_;
}
inline const ::hbase::pb::UUID& WALKey::cluster_ids(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.cluster_ids)
  return cluster_ids_.Get(index);
}
inline ::hbase::pb::UUID* WALKey::add_cluster_ids() {
  // @@protoc_insertion_point(field_add:hbase.pb.WALKey.cluster_ids)
  return cluster_ids_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::UUID >&
WALKey::cluster_ids() const {
  // @@protoc_insertion_point(field_list:hbase.pb.WALKey.cluster_ids)
  return cluster_ids_;
}

// optional uint64 nonceGroup = 9;
inline bool WALKey::has_noncegroup() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WALKey::clear_noncegroup() {
  noncegroup_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WALKey::noncegroup() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.nonceGroup)
  return noncegroup_;
}
inline void WALKey::set_noncegroup(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  noncegroup_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.nonceGroup)
}

// optional uint64 nonce = 10;
inline bool WALKey::has_nonce() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WALKey::clear_nonce() {
  nonce_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WALKey::nonce() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.nonce)
  return nonce_;
}
inline void WALKey::set_nonce(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  nonce_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.nonce)
}

// optional uint64 orig_sequence_number = 11;
inline bool WALKey::has_orig_sequence_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WALKey::clear_orig_sequence_number() {
  orig_sequence_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 WALKey::orig_sequence_number() const {
  // @@protoc_insertion_point(field_get:hbase.pb.WALKey.orig_sequence_number)
  return orig_sequence_number_;
}
inline void WALKey::set_orig_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000080u;
  orig_sequence_number_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.WALKey.orig_sequence_number)
}

// -------------------------------------------------------------------

// FamilyScope

// required bytes family = 1;
inline bool FamilyScope::has_family() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FamilyScope::clear_family() {
  family_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FamilyScope::family() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FamilyScope.family)
  return family_.GetNoArena();
}
inline void FamilyScope::set_family(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FamilyScope.family)
}
inline void FamilyScope::set_family(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FamilyScope.family)
}
inline void FamilyScope::set_family(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FamilyScope.family)
}
inline void FamilyScope::set_family(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FamilyScope.family)
}
inline std::string* FamilyScope::mutable_family() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FamilyScope.family)
  return family_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FamilyScope::release_family() {
  // @@protoc_insertion_point(field_release:hbase.pb.FamilyScope.family)
  if (!has_family()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FamilyScope::set_allocated_family(std::string* family) {
  if (family != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FamilyScope.family)
}

// required .hbase.pb.ScopeType scope_type = 2;
inline bool FamilyScope::has_scope_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FamilyScope::clear_scope_type() {
  scope_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::ScopeType FamilyScope::scope_type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FamilyScope.scope_type)
  return static_cast< ::hbase::pb::ScopeType >(scope_type_);
}
inline void FamilyScope::set_scope_type(::hbase::pb::ScopeType value) {
  assert(::hbase::pb::ScopeType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  scope_type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.FamilyScope.scope_type)
}

// -------------------------------------------------------------------

// CompactionDescriptor

// required bytes table_name = 1;
inline bool CompactionDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CompactionDescriptor::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CompactionDescriptor::table_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.table_name)
  return table_name_.GetNoArena();
}
inline void CompactionDescriptor::set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.table_name)
}
inline void CompactionDescriptor::set_table_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CompactionDescriptor.table_name)
}
inline void CompactionDescriptor::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.table_name)
}
inline void CompactionDescriptor::set_table_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.table_name)
}
inline std::string* CompactionDescriptor::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompactionDescriptor::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompactionDescriptor.table_name)
  if (!has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompactionDescriptor::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompactionDescriptor.table_name)
}

// required bytes encoded_region_name = 2;
inline bool CompactionDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CompactionDescriptor::clear_encoded_region_name() {
  encoded_region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CompactionDescriptor::encoded_region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.encoded_region_name)
  return encoded_region_name_.GetNoArena();
}
inline void CompactionDescriptor::set_encoded_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.encoded_region_name)
}
inline void CompactionDescriptor::set_encoded_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CompactionDescriptor.encoded_region_name)
}
inline void CompactionDescriptor::set_encoded_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.encoded_region_name)
}
inline void CompactionDescriptor::set_encoded_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.encoded_region_name)
}
inline std::string* CompactionDescriptor::mutable_encoded_region_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.encoded_region_name)
  return encoded_region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompactionDescriptor::release_encoded_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompactionDescriptor.encoded_region_name)
  if (!has_encoded_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return encoded_region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompactionDescriptor::set_allocated_encoded_region_name(std::string* encoded_region_name) {
  if (encoded_region_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encoded_region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompactionDescriptor.encoded_region_name)
}

// required bytes family_name = 3;
inline bool CompactionDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CompactionDescriptor::clear_family_name() {
  family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CompactionDescriptor::family_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.family_name)
  return family_name_.GetNoArena();
}
inline void CompactionDescriptor::set_family_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.family_name)
}
inline void CompactionDescriptor::set_family_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CompactionDescriptor.family_name)
}
inline void CompactionDescriptor::set_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.family_name)
}
inline void CompactionDescriptor::set_family_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.family_name)
}
inline std::string* CompactionDescriptor::mutable_family_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.family_name)
  return family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompactionDescriptor::release_family_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompactionDescriptor.family_name)
  if (!has_family_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return family_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompactionDescriptor::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompactionDescriptor.family_name)
}

// repeated string compaction_input = 4;
inline int CompactionDescriptor::compaction_input_size() const {
  return compaction_input_.size();
}
inline void CompactionDescriptor::clear_compaction_input() {
  compaction_input_.Clear();
}
inline const std::string& CompactionDescriptor::compaction_input(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.compaction_input)
  return compaction_input_.Get(index);
}
inline std::string* CompactionDescriptor::mutable_compaction_input(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.compaction_input)
  return compaction_input_.Mutable(index);
}
inline void CompactionDescriptor::set_compaction_input(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.compaction_input)
  compaction_input_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_input(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.compaction_input)
  compaction_input_.Mutable(index)->assign(std::move(value));
}
inline void CompactionDescriptor::set_compaction_input(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  compaction_input_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.compaction_input)
}
inline void CompactionDescriptor::set_compaction_input(int index, const char* value, size_t size) {
  compaction_input_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.compaction_input)
}
inline std::string* CompactionDescriptor::add_compaction_input() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.CompactionDescriptor.compaction_input)
  return compaction_input_.Add();
}
inline void CompactionDescriptor::add_compaction_input(const std::string& value) {
  compaction_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.CompactionDescriptor.compaction_input)
}
inline void CompactionDescriptor::add_compaction_input(std::string&& value) {
  compaction_input_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.CompactionDescriptor.compaction_input)
}
inline void CompactionDescriptor::add_compaction_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  compaction_input_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.CompactionDescriptor.compaction_input)
}
inline void CompactionDescriptor::add_compaction_input(const char* value, size_t size) {
  compaction_input_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.CompactionDescriptor.compaction_input)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompactionDescriptor::compaction_input() const {
  // @@protoc_insertion_point(field_list:hbase.pb.CompactionDescriptor.compaction_input)
  return compaction_input_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompactionDescriptor::mutable_compaction_input() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.CompactionDescriptor.compaction_input)
  return &compaction_input_;
}

// repeated string compaction_output = 5;
inline int CompactionDescriptor::compaction_output_size() const {
  return compaction_output_.size();
}
inline void CompactionDescriptor::clear_compaction_output() {
  compaction_output_.Clear();
}
inline const std::string& CompactionDescriptor::compaction_output(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.compaction_output)
  return compaction_output_.Get(index);
}
inline std::string* CompactionDescriptor::mutable_compaction_output(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.compaction_output)
  return compaction_output_.Mutable(index);
}
inline void CompactionDescriptor::set_compaction_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.compaction_output)
  compaction_output_.Mutable(index)->assign(value);
}
inline void CompactionDescriptor::set_compaction_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.compaction_output)
  compaction_output_.Mutable(index)->assign(std::move(value));
}
inline void CompactionDescriptor::set_compaction_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  compaction_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.compaction_output)
}
inline void CompactionDescriptor::set_compaction_output(int index, const char* value, size_t size) {
  compaction_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.compaction_output)
}
inline std::string* CompactionDescriptor::add_compaction_output() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.CompactionDescriptor.compaction_output)
  return compaction_output_.Add();
}
inline void CompactionDescriptor::add_compaction_output(const std::string& value) {
  compaction_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.CompactionDescriptor.compaction_output)
}
inline void CompactionDescriptor::add_compaction_output(std::string&& value) {
  compaction_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.CompactionDescriptor.compaction_output)
}
inline void CompactionDescriptor::add_compaction_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  compaction_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.CompactionDescriptor.compaction_output)
}
inline void CompactionDescriptor::add_compaction_output(const char* value, size_t size) {
  compaction_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.CompactionDescriptor.compaction_output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CompactionDescriptor::compaction_output() const {
  // @@protoc_insertion_point(field_list:hbase.pb.CompactionDescriptor.compaction_output)
  return compaction_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CompactionDescriptor::mutable_compaction_output() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.CompactionDescriptor.compaction_output)
  return &compaction_output_;
}

// required string store_home_dir = 6;
inline bool CompactionDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CompactionDescriptor::clear_store_home_dir() {
  store_home_dir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CompactionDescriptor::store_home_dir() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.store_home_dir)
  return store_home_dir_.GetNoArena();
}
inline void CompactionDescriptor::set_store_home_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.store_home_dir)
}
inline void CompactionDescriptor::set_store_home_dir(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  store_home_dir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CompactionDescriptor.store_home_dir)
}
inline void CompactionDescriptor::set_store_home_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.store_home_dir)
}
inline void CompactionDescriptor::set_store_home_dir(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.store_home_dir)
}
inline std::string* CompactionDescriptor::mutable_store_home_dir() {
  _has_bits_[0] |= 0x00000008u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.store_home_dir)
  return store_home_dir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompactionDescriptor::release_store_home_dir() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompactionDescriptor.store_home_dir)
  if (!has_store_home_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return store_home_dir_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompactionDescriptor::set_allocated_store_home_dir(std::string* store_home_dir) {
  if (store_home_dir != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  store_home_dir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_home_dir);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompactionDescriptor.store_home_dir)
}

// optional bytes region_name = 7;
inline bool CompactionDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CompactionDescriptor::clear_region_name() {
  region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CompactionDescriptor::region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.CompactionDescriptor.region_name)
  return region_name_.GetNoArena();
}
inline void CompactionDescriptor::set_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.CompactionDescriptor.region_name)
}
inline void CompactionDescriptor::set_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.CompactionDescriptor.region_name)
}
inline void CompactionDescriptor::set_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.CompactionDescriptor.region_name)
}
inline void CompactionDescriptor::set_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.CompactionDescriptor.region_name)
}
inline std::string* CompactionDescriptor::mutable_region_name() {
  _has_bits_[0] |= 0x00000010u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.CompactionDescriptor.region_name)
  return region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* CompactionDescriptor::release_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.CompactionDescriptor.region_name)
  if (!has_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void CompactionDescriptor::set_allocated_region_name(std::string* region_name) {
  if (region_name != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.CompactionDescriptor.region_name)
}

// -------------------------------------------------------------------

// FlushDescriptor_StoreFlushDescriptor

// required bytes family_name = 1;
inline bool FlushDescriptor_StoreFlushDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_family_name() {
  family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlushDescriptor_StoreFlushDescriptor::family_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
  return family_name_.GetNoArena();
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_family_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::mutable_family_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
  return family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::release_family_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
  if (!has_family_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FlushDescriptor_StoreFlushDescriptor::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FlushDescriptor.StoreFlushDescriptor.family_name)
}

// required string store_home_dir = 2;
inline bool FlushDescriptor_StoreFlushDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_store_home_dir() {
  store_home_dir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlushDescriptor_StoreFlushDescriptor::store_home_dir() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
  return store_home_dir_.GetNoArena();
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_store_home_dir(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::mutable_store_home_dir() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
  return store_home_dir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::release_store_home_dir() {
  // @@protoc_insertion_point(field_release:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
  if (!has_store_home_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return store_home_dir_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FlushDescriptor_StoreFlushDescriptor::set_allocated_store_home_dir(std::string* store_home_dir) {
  if (store_home_dir != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_home_dir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_home_dir);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FlushDescriptor.StoreFlushDescriptor.store_home_dir)
}

// repeated string flush_output = 3;
inline int FlushDescriptor_StoreFlushDescriptor::flush_output_size() const {
  return flush_output_.size();
}
inline void FlushDescriptor_StoreFlushDescriptor::clear_flush_output() {
  flush_output_.Clear();
}
inline const std::string& FlushDescriptor_StoreFlushDescriptor::flush_output(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  return flush_output_.Get(index);
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::mutable_flush_output(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  return flush_output_.Mutable(index);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  flush_output_.Mutable(index)->assign(value);
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  flush_output_.Mutable(index)->assign(std::move(value));
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  flush_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline void FlushDescriptor_StoreFlushDescriptor::set_flush_output(int index, const char* value, size_t size) {
  flush_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline std::string* FlushDescriptor_StoreFlushDescriptor::add_flush_output() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  return flush_output_.Add();
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const std::string& value) {
  flush_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(std::string&& value) {
  flush_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  flush_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline void FlushDescriptor_StoreFlushDescriptor::add_flush_output(const char* value, size_t size) {
  flush_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FlushDescriptor_StoreFlushDescriptor::flush_output() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  return flush_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FlushDescriptor_StoreFlushDescriptor::mutable_flush_output() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FlushDescriptor.StoreFlushDescriptor.flush_output)
  return &flush_output_;
}

// -------------------------------------------------------------------

// FlushDescriptor

// required .hbase.pb.FlushDescriptor.FlushAction action = 1;
inline bool FlushDescriptor::has_action() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FlushDescriptor::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::hbase::pb::FlushDescriptor_FlushAction FlushDescriptor::action() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.action)
  return static_cast< ::hbase::pb::FlushDescriptor_FlushAction >(action_);
}
inline void FlushDescriptor::set_action(::hbase::pb::FlushDescriptor_FlushAction value) {
  assert(::hbase::pb::FlushDescriptor_FlushAction_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  action_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.action)
}

// required bytes table_name = 2;
inline bool FlushDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FlushDescriptor::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& FlushDescriptor::table_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.table_name)
  return table_name_.GetNoArena();
}
inline void FlushDescriptor::set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.table_name)
}
inline void FlushDescriptor::set_table_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FlushDescriptor.table_name)
}
inline void FlushDescriptor::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.table_name)
}
inline void FlushDescriptor::set_table_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.table_name)
}
inline std::string* FlushDescriptor::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FlushDescriptor::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.FlushDescriptor.table_name)
  if (!has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FlushDescriptor::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FlushDescriptor.table_name)
}

// required bytes encoded_region_name = 3;
inline bool FlushDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FlushDescriptor::clear_encoded_region_name() {
  encoded_region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& FlushDescriptor::encoded_region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.encoded_region_name)
  return encoded_region_name_.GetNoArena();
}
inline void FlushDescriptor::set_encoded_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.encoded_region_name)
}
inline void FlushDescriptor::set_encoded_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FlushDescriptor.encoded_region_name)
}
inline void FlushDescriptor::set_encoded_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.encoded_region_name)
}
inline void FlushDescriptor::set_encoded_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.encoded_region_name)
}
inline std::string* FlushDescriptor::mutable_encoded_region_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.encoded_region_name)
  return encoded_region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FlushDescriptor::release_encoded_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.FlushDescriptor.encoded_region_name)
  if (!has_encoded_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return encoded_region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FlushDescriptor::set_allocated_encoded_region_name(std::string* encoded_region_name) {
  if (encoded_region_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encoded_region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FlushDescriptor.encoded_region_name)
}

// optional uint64 flush_sequence_number = 4;
inline bool FlushDescriptor::has_flush_sequence_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FlushDescriptor::clear_flush_sequence_number() {
  flush_sequence_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 FlushDescriptor::flush_sequence_number() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.flush_sequence_number)
  return flush_sequence_number_;
}
inline void FlushDescriptor::set_flush_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  flush_sequence_number_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.flush_sequence_number)
}

// repeated .hbase.pb.FlushDescriptor.StoreFlushDescriptor store_flushes = 5;
inline int FlushDescriptor::store_flushes_size() const {
  return store_flushes_.size();
}
inline void FlushDescriptor::clear_store_flushes() {
  store_flushes_.Clear();
}
inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* FlushDescriptor::mutable_store_flushes(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.store_flushes)
  return store_flushes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >*
FlushDescriptor::mutable_store_flushes() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.FlushDescriptor.store_flushes)
  return &store_flushes_;
}
inline const ::hbase::pb::FlushDescriptor_StoreFlushDescriptor& FlushDescriptor::store_flushes(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.store_flushes)
  return store_flushes_.Get(index);
}
inline ::hbase::pb::FlushDescriptor_StoreFlushDescriptor* FlushDescriptor::add_store_flushes() {
  // @@protoc_insertion_point(field_add:hbase.pb.FlushDescriptor.store_flushes)
  return store_flushes_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::FlushDescriptor_StoreFlushDescriptor >&
FlushDescriptor::store_flushes() const {
  // @@protoc_insertion_point(field_list:hbase.pb.FlushDescriptor.store_flushes)
  return store_flushes_;
}

// optional bytes region_name = 6;
inline bool FlushDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FlushDescriptor::clear_region_name() {
  region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& FlushDescriptor::region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.FlushDescriptor.region_name)
  return region_name_.GetNoArena();
}
inline void FlushDescriptor::set_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.FlushDescriptor.region_name)
}
inline void FlushDescriptor::set_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.FlushDescriptor.region_name)
}
inline void FlushDescriptor::set_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.FlushDescriptor.region_name)
}
inline void FlushDescriptor::set_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.FlushDescriptor.region_name)
}
inline std::string* FlushDescriptor::mutable_region_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.FlushDescriptor.region_name)
  return region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* FlushDescriptor::release_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.FlushDescriptor.region_name)
  if (!has_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void FlushDescriptor::set_allocated_region_name(std::string* region_name) {
  if (region_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.FlushDescriptor.region_name)
}

// -------------------------------------------------------------------

// StoreDescriptor

// required bytes family_name = 1;
inline bool StoreDescriptor::has_family_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StoreDescriptor::clear_family_name() {
  family_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreDescriptor::family_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreDescriptor.family_name)
  return family_name_.GetNoArena();
}
inline void StoreDescriptor::set_family_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.StoreDescriptor.family_name)
}
inline void StoreDescriptor::set_family_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.StoreDescriptor.family_name)
}
inline void StoreDescriptor::set_family_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.StoreDescriptor.family_name)
}
inline void StoreDescriptor::set_family_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  family_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.StoreDescriptor.family_name)
}
inline std::string* StoreDescriptor::mutable_family_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.StoreDescriptor.family_name)
  return family_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StoreDescriptor::release_family_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.StoreDescriptor.family_name)
  if (!has_family_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return family_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StoreDescriptor::set_allocated_family_name(std::string* family_name) {
  if (family_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  family_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), family_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.StoreDescriptor.family_name)
}

// required string store_home_dir = 2;
inline bool StoreDescriptor::has_store_home_dir() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StoreDescriptor::clear_store_home_dir() {
  store_home_dir_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreDescriptor::store_home_dir() const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreDescriptor.store_home_dir)
  return store_home_dir_.GetNoArena();
}
inline void StoreDescriptor::set_store_home_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.StoreDescriptor.store_home_dir)
}
inline void StoreDescriptor::set_store_home_dir(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.StoreDescriptor.store_home_dir)
}
inline void StoreDescriptor::set_store_home_dir(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.StoreDescriptor.store_home_dir)
}
inline void StoreDescriptor::set_store_home_dir(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  store_home_dir_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.StoreDescriptor.store_home_dir)
}
inline std::string* StoreDescriptor::mutable_store_home_dir() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.StoreDescriptor.store_home_dir)
  return store_home_dir_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* StoreDescriptor::release_store_home_dir() {
  // @@protoc_insertion_point(field_release:hbase.pb.StoreDescriptor.store_home_dir)
  if (!has_store_home_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return store_home_dir_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void StoreDescriptor::set_allocated_store_home_dir(std::string* store_home_dir) {
  if (store_home_dir != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_home_dir_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_home_dir);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.StoreDescriptor.store_home_dir)
}

// repeated string store_file = 3;
inline int StoreDescriptor::store_file_size() const {
  return store_file_.size();
}
inline void StoreDescriptor::clear_store_file() {
  store_file_.Clear();
}
inline const std::string& StoreDescriptor::store_file(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreDescriptor.store_file)
  return store_file_.Get(index);
}
inline std::string* StoreDescriptor::mutable_store_file(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.StoreDescriptor.store_file)
  return store_file_.Mutable(index);
}
inline void StoreDescriptor::set_store_file(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.StoreDescriptor.store_file)
  store_file_.Mutable(index)->assign(value);
}
inline void StoreDescriptor::set_store_file(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.StoreDescriptor.store_file)
  store_file_.Mutable(index)->assign(std::move(value));
}
inline void StoreDescriptor::set_store_file(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  store_file_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.StoreDescriptor.store_file)
}
inline void StoreDescriptor::set_store_file(int index, const char* value, size_t size) {
  store_file_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.StoreDescriptor.store_file)
}
inline std::string* StoreDescriptor::add_store_file() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.StoreDescriptor.store_file)
  return store_file_.Add();
}
inline void StoreDescriptor::add_store_file(const std::string& value) {
  store_file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.StoreDescriptor.store_file)
}
inline void StoreDescriptor::add_store_file(std::string&& value) {
  store_file_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.StoreDescriptor.store_file)
}
inline void StoreDescriptor::add_store_file(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  store_file_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.StoreDescriptor.store_file)
}
inline void StoreDescriptor::add_store_file(const char* value, size_t size) {
  store_file_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.StoreDescriptor.store_file)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StoreDescriptor::store_file() const {
  // @@protoc_insertion_point(field_list:hbase.pb.StoreDescriptor.store_file)
  return store_file_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StoreDescriptor::mutable_store_file() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.StoreDescriptor.store_file)
  return &store_file_;
}

// optional uint64 store_file_size_bytes = 4;
inline bool StoreDescriptor::has_store_file_size_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StoreDescriptor::clear_store_file_size_bytes() {
  store_file_size_bytes_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 StoreDescriptor::store_file_size_bytes() const {
  // @@protoc_insertion_point(field_get:hbase.pb.StoreDescriptor.store_file_size_bytes)
  return store_file_size_bytes_;
}
inline void StoreDescriptor::set_store_file_size_bytes(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  store_file_size_bytes_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.StoreDescriptor.store_file_size_bytes)
}

// -------------------------------------------------------------------

// BulkLoadDescriptor

// required .hbase.pb.TableName table_name = 1;
inline bool BulkLoadDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::hbase::pb::TableName& BulkLoadDescriptor::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadDescriptor.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* BulkLoadDescriptor::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadDescriptor.table_name)
  _has_bits_[0] &= ~0x00000002u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* BulkLoadDescriptor::mutable_table_name() {
  _has_bits_[0] |= 0x00000002u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadDescriptor.table_name)
  return table_name_;
}
inline void BulkLoadDescriptor::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadDescriptor.table_name)
}

// required bytes encoded_region_name = 2;
inline bool BulkLoadDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BulkLoadDescriptor::clear_encoded_region_name() {
  encoded_region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BulkLoadDescriptor::encoded_region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadDescriptor.encoded_region_name)
  return encoded_region_name_.GetNoArena();
}
inline void BulkLoadDescriptor::set_encoded_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadDescriptor.encoded_region_name)
}
inline void BulkLoadDescriptor::set_encoded_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.BulkLoadDescriptor.encoded_region_name)
}
inline void BulkLoadDescriptor::set_encoded_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.BulkLoadDescriptor.encoded_region_name)
}
inline void BulkLoadDescriptor::set_encoded_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.BulkLoadDescriptor.encoded_region_name)
}
inline std::string* BulkLoadDescriptor::mutable_encoded_region_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadDescriptor.encoded_region_name)
  return encoded_region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* BulkLoadDescriptor::release_encoded_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.BulkLoadDescriptor.encoded_region_name)
  if (!has_encoded_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return encoded_region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void BulkLoadDescriptor::set_allocated_encoded_region_name(std::string* encoded_region_name) {
  if (encoded_region_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encoded_region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.BulkLoadDescriptor.encoded_region_name)
}

// repeated .hbase.pb.StoreDescriptor stores = 3;
inline int BulkLoadDescriptor::stores_size() const {
  return stores_.size();
}
inline void BulkLoadDescriptor::clear_stores() {
  stores_.Clear();
}
inline ::hbase::pb::StoreDescriptor* BulkLoadDescriptor::mutable_stores(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.BulkLoadDescriptor.stores)
  return stores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
BulkLoadDescriptor::mutable_stores() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.BulkLoadDescriptor.stores)
  return &stores_;
}
inline const ::hbase::pb::StoreDescriptor& BulkLoadDescriptor::stores(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadDescriptor.stores)
  return stores_.Get(index);
}
inline ::hbase::pb::StoreDescriptor* BulkLoadDescriptor::add_stores() {
  // @@protoc_insertion_point(field_add:hbase.pb.BulkLoadDescriptor.stores)
  return stores_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
BulkLoadDescriptor::stores() const {
  // @@protoc_insertion_point(field_list:hbase.pb.BulkLoadDescriptor.stores)
  return stores_;
}

// required int64 bulkload_seq_num = 4;
inline bool BulkLoadDescriptor::has_bulkload_seq_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BulkLoadDescriptor::clear_bulkload_seq_num() {
  bulkload_seq_num_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 BulkLoadDescriptor::bulkload_seq_num() const {
  // @@protoc_insertion_point(field_get:hbase.pb.BulkLoadDescriptor.bulkload_seq_num)
  return bulkload_seq_num_;
}
inline void BulkLoadDescriptor::set_bulkload_seq_num(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  bulkload_seq_num_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.BulkLoadDescriptor.bulkload_seq_num)
}

// -------------------------------------------------------------------

// RegionEventDescriptor

// required .hbase.pb.RegionEventDescriptor.EventType event_type = 1;
inline bool RegionEventDescriptor::has_event_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RegionEventDescriptor::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::hbase::pb::RegionEventDescriptor_EventType RegionEventDescriptor::event_type() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.event_type)
  return static_cast< ::hbase::pb::RegionEventDescriptor_EventType >(event_type_);
}
inline void RegionEventDescriptor::set_event_type(::hbase::pb::RegionEventDescriptor_EventType value) {
  assert(::hbase::pb::RegionEventDescriptor_EventType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  event_type_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionEventDescriptor.event_type)
}

// required bytes table_name = 2;
inline bool RegionEventDescriptor::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionEventDescriptor::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& RegionEventDescriptor::table_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.table_name)
  return table_name_.GetNoArena();
}
inline void RegionEventDescriptor::set_table_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionEventDescriptor.table_name)
}
inline void RegionEventDescriptor::set_table_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionEventDescriptor.table_name)
}
inline void RegionEventDescriptor::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionEventDescriptor.table_name)
}
inline void RegionEventDescriptor::set_table_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  table_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionEventDescriptor.table_name)
}
inline std::string* RegionEventDescriptor::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionEventDescriptor.table_name)
  return table_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionEventDescriptor::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionEventDescriptor.table_name)
  if (!has_table_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return table_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionEventDescriptor::set_allocated_table_name(std::string* table_name) {
  if (table_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionEventDescriptor.table_name)
}

// required bytes encoded_region_name = 3;
inline bool RegionEventDescriptor::has_encoded_region_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegionEventDescriptor::clear_encoded_region_name() {
  encoded_region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& RegionEventDescriptor::encoded_region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.encoded_region_name)
  return encoded_region_name_.GetNoArena();
}
inline void RegionEventDescriptor::set_encoded_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionEventDescriptor.encoded_region_name)
}
inline void RegionEventDescriptor::set_encoded_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionEventDescriptor.encoded_region_name)
}
inline void RegionEventDescriptor::set_encoded_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionEventDescriptor.encoded_region_name)
}
inline void RegionEventDescriptor::set_encoded_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  encoded_region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionEventDescriptor.encoded_region_name)
}
inline std::string* RegionEventDescriptor::mutable_encoded_region_name() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionEventDescriptor.encoded_region_name)
  return encoded_region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionEventDescriptor::release_encoded_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionEventDescriptor.encoded_region_name)
  if (!has_encoded_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return encoded_region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionEventDescriptor::set_allocated_encoded_region_name(std::string* encoded_region_name) {
  if (encoded_region_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  encoded_region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encoded_region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionEventDescriptor.encoded_region_name)
}

// optional uint64 log_sequence_number = 4;
inline bool RegionEventDescriptor::has_log_sequence_number() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RegionEventDescriptor::clear_log_sequence_number() {
  log_sequence_number_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 RegionEventDescriptor::log_sequence_number() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.log_sequence_number)
  return log_sequence_number_;
}
inline void RegionEventDescriptor::set_log_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  log_sequence_number_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.RegionEventDescriptor.log_sequence_number)
}

// repeated .hbase.pb.StoreDescriptor stores = 5;
inline int RegionEventDescriptor::stores_size() const {
  return stores_.size();
}
inline void RegionEventDescriptor::clear_stores() {
  stores_.Clear();
}
inline ::hbase::pb::StoreDescriptor* RegionEventDescriptor::mutable_stores(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionEventDescriptor.stores)
  return stores_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >*
RegionEventDescriptor::mutable_stores() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.RegionEventDescriptor.stores)
  return &stores_;
}
inline const ::hbase::pb::StoreDescriptor& RegionEventDescriptor::stores(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.stores)
  return stores_.Get(index);
}
inline ::hbase::pb::StoreDescriptor* RegionEventDescriptor::add_stores() {
  // @@protoc_insertion_point(field_add:hbase.pb.RegionEventDescriptor.stores)
  return stores_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::StoreDescriptor >&
RegionEventDescriptor::stores() const {
  // @@protoc_insertion_point(field_list:hbase.pb.RegionEventDescriptor.stores)
  return stores_;
}

// optional .hbase.pb.ServerName server = 6;
inline bool RegionEventDescriptor::has_server() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::hbase::pb::ServerName& RegionEventDescriptor::server() const {
  const ::hbase::pb::ServerName* p = server_;
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.server)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* RegionEventDescriptor::release_server() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionEventDescriptor.server)
  _has_bits_[0] &= ~0x00000008u;
  ::hbase::pb::ServerName* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* RegionEventDescriptor::mutable_server() {
  _has_bits_[0] |= 0x00000008u;
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionEventDescriptor.server)
  return server_;
}
inline void RegionEventDescriptor::set_allocated_server(::hbase::pb::ServerName* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionEventDescriptor.server)
}

// optional bytes region_name = 7;
inline bool RegionEventDescriptor::has_region_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegionEventDescriptor::clear_region_name() {
  region_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& RegionEventDescriptor::region_name() const {
  // @@protoc_insertion_point(field_get:hbase.pb.RegionEventDescriptor.region_name)
  return region_name_.GetNoArena();
}
inline void RegionEventDescriptor::set_region_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.RegionEventDescriptor.region_name)
}
inline void RegionEventDescriptor::set_region_name(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.RegionEventDescriptor.region_name)
}
inline void RegionEventDescriptor::set_region_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.RegionEventDescriptor.region_name)
}
inline void RegionEventDescriptor::set_region_name(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  region_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.RegionEventDescriptor.region_name)
}
inline std::string* RegionEventDescriptor::mutable_region_name() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.RegionEventDescriptor.region_name)
  return region_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* RegionEventDescriptor::release_region_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.RegionEventDescriptor.region_name)
  if (!has_region_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return region_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void RegionEventDescriptor::set_allocated_region_name(std::string* region_name) {
  if (region_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region_name);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.RegionEventDescriptor.region_name)
}

// -------------------------------------------------------------------

// WALTrailer

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::FlushDescriptor_FlushAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::FlushDescriptor_FlushAction>() {
  return ::hbase::pb::FlushDescriptor_FlushAction_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::RegionEventDescriptor_EventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::RegionEventDescriptor_EventType>() {
  return ::hbase::pb::RegionEventDescriptor_EventType_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::ScopeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ScopeType>() {
  return ::hbase::pb::ScopeType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_WAL_2eproto
