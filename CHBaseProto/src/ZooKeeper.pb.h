// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ZooKeeper.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ZooKeeper_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ZooKeeper_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "HBase.pb.h"
#include "ClusterStatus.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ZooKeeper_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ZooKeeper_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ZooKeeper_2eproto;
namespace hbase {
namespace pb {
class ClusterUp;
class ClusterUpDefaultTypeInternal;
extern ClusterUpDefaultTypeInternal _ClusterUp_default_instance_;
class DeprecatedTableState;
class DeprecatedTableStateDefaultTypeInternal;
extern DeprecatedTableStateDefaultTypeInternal _DeprecatedTableState_default_instance_;
class Master;
class MasterDefaultTypeInternal;
extern MasterDefaultTypeInternal _Master_default_instance_;
class MetaRegionServer;
class MetaRegionServerDefaultTypeInternal;
extern MetaRegionServerDefaultTypeInternal _MetaRegionServer_default_instance_;
class ReplicationHLogPosition;
class ReplicationHLogPositionDefaultTypeInternal;
extern ReplicationHLogPositionDefaultTypeInternal _ReplicationHLogPosition_default_instance_;
class ReplicationPeer;
class ReplicationPeerDefaultTypeInternal;
extern ReplicationPeerDefaultTypeInternal _ReplicationPeer_default_instance_;
class ReplicationState;
class ReplicationStateDefaultTypeInternal;
extern ReplicationStateDefaultTypeInternal _ReplicationState_default_instance_;
class SplitLogTask;
class SplitLogTaskDefaultTypeInternal;
extern SplitLogTaskDefaultTypeInternal _SplitLogTask_default_instance_;
class SwitchState;
class SwitchStateDefaultTypeInternal;
extern SwitchStateDefaultTypeInternal _SwitchState_default_instance_;
class TableCF;
class TableCFDefaultTypeInternal;
extern TableCFDefaultTypeInternal _TableCF_default_instance_;
}  // namespace pb
}  // namespace hbase
PROTOBUF_NAMESPACE_OPEN
template<> ::hbase::pb::ClusterUp* Arena::CreateMaybeMessage<::hbase::pb::ClusterUp>(Arena*);
template<> ::hbase::pb::DeprecatedTableState* Arena::CreateMaybeMessage<::hbase::pb::DeprecatedTableState>(Arena*);
template<> ::hbase::pb::Master* Arena::CreateMaybeMessage<::hbase::pb::Master>(Arena*);
template<> ::hbase::pb::MetaRegionServer* Arena::CreateMaybeMessage<::hbase::pb::MetaRegionServer>(Arena*);
template<> ::hbase::pb::ReplicationHLogPosition* Arena::CreateMaybeMessage<::hbase::pb::ReplicationHLogPosition>(Arena*);
template<> ::hbase::pb::ReplicationPeer* Arena::CreateMaybeMessage<::hbase::pb::ReplicationPeer>(Arena*);
template<> ::hbase::pb::ReplicationState* Arena::CreateMaybeMessage<::hbase::pb::ReplicationState>(Arena*);
template<> ::hbase::pb::SplitLogTask* Arena::CreateMaybeMessage<::hbase::pb::SplitLogTask>(Arena*);
template<> ::hbase::pb::SwitchState* Arena::CreateMaybeMessage<::hbase::pb::SwitchState>(Arena*);
template<> ::hbase::pb::TableCF* Arena::CreateMaybeMessage<::hbase::pb::TableCF>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace hbase {
namespace pb {

enum SplitLogTask_State : int {
  SplitLogTask_State_UNASSIGNED = 0,
  SplitLogTask_State_OWNED = 1,
  SplitLogTask_State_RESIGNED = 2,
  SplitLogTask_State_DONE = 3,
  SplitLogTask_State_ERR = 4
};
bool SplitLogTask_State_IsValid(int value);
constexpr SplitLogTask_State SplitLogTask_State_State_MIN = SplitLogTask_State_UNASSIGNED;
constexpr SplitLogTask_State SplitLogTask_State_State_MAX = SplitLogTask_State_ERR;
constexpr int SplitLogTask_State_State_ARRAYSIZE = SplitLogTask_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SplitLogTask_State_descriptor();
template<typename T>
inline const std::string& SplitLogTask_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SplitLogTask_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SplitLogTask_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SplitLogTask_State_descriptor(), enum_t_value);
}
inline bool SplitLogTask_State_Parse(
    const std::string& name, SplitLogTask_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SplitLogTask_State>(
    SplitLogTask_State_descriptor(), name, value);
}
enum DeprecatedTableState_State : int {
  DeprecatedTableState_State_ENABLED = 0,
  DeprecatedTableState_State_DISABLED = 1,
  DeprecatedTableState_State_DISABLING = 2,
  DeprecatedTableState_State_ENABLING = 3
};
bool DeprecatedTableState_State_IsValid(int value);
constexpr DeprecatedTableState_State DeprecatedTableState_State_State_MIN = DeprecatedTableState_State_ENABLED;
constexpr DeprecatedTableState_State DeprecatedTableState_State_State_MAX = DeprecatedTableState_State_ENABLING;
constexpr int DeprecatedTableState_State_State_ARRAYSIZE = DeprecatedTableState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DeprecatedTableState_State_descriptor();
template<typename T>
inline const std::string& DeprecatedTableState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DeprecatedTableState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DeprecatedTableState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DeprecatedTableState_State_descriptor(), enum_t_value);
}
inline bool DeprecatedTableState_State_Parse(
    const std::string& name, DeprecatedTableState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DeprecatedTableState_State>(
    DeprecatedTableState_State_descriptor(), name, value);
}
enum ReplicationState_State : int {
  ReplicationState_State_ENABLED = 0,
  ReplicationState_State_DISABLED = 1
};
bool ReplicationState_State_IsValid(int value);
constexpr ReplicationState_State ReplicationState_State_State_MIN = ReplicationState_State_ENABLED;
constexpr ReplicationState_State ReplicationState_State_State_MAX = ReplicationState_State_DISABLED;
constexpr int ReplicationState_State_State_ARRAYSIZE = ReplicationState_State_State_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplicationState_State_descriptor();
template<typename T>
inline const std::string& ReplicationState_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ReplicationState_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ReplicationState_State_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ReplicationState_State_descriptor(), enum_t_value);
}
inline bool ReplicationState_State_Parse(
    const std::string& name, ReplicationState_State* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ReplicationState_State>(
    ReplicationState_State_descriptor(), name, value);
}
// ===================================================================

class MetaRegionServer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.MetaRegionServer) */ {
 public:
  MetaRegionServer();
  virtual ~MetaRegionServer();

  MetaRegionServer(const MetaRegionServer& from);
  MetaRegionServer(MetaRegionServer&& from) noexcept
    : MetaRegionServer() {
    *this = ::std::move(from);
  }

  inline MetaRegionServer& operator=(const MetaRegionServer& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetaRegionServer& operator=(MetaRegionServer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const MetaRegionServer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetaRegionServer* internal_default_instance() {
    return reinterpret_cast<const MetaRegionServer*>(
               &_MetaRegionServer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(MetaRegionServer& a, MetaRegionServer& b) {
    a.Swap(&b);
  }
  inline void Swap(MetaRegionServer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline MetaRegionServer* New() const final {
    return CreateMaybeMessage<MetaRegionServer>(nullptr);
  }

  MetaRegionServer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<MetaRegionServer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const MetaRegionServer& from);
  void MergeFrom(const MetaRegionServer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetaRegionServer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.MetaRegionServer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerFieldNumber = 1,
    kRpcVersionFieldNumber = 2,
    kStateFieldNumber = 3,
  };
  // required .hbase.pb.ServerName server = 1;
  bool has_server() const;
  void clear_server();
  const ::hbase::pb::ServerName& server() const;
  ::hbase::pb::ServerName* release_server();
  ::hbase::pb::ServerName* mutable_server();
  void set_allocated_server(::hbase::pb::ServerName* server);

  // optional uint32 rpc_version = 2;
  bool has_rpc_version() const;
  void clear_rpc_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 rpc_version() const;
  void set_rpc_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional .hbase.pb.RegionState.State state = 3;
  bool has_state() const;
  void clear_state();
  ::hbase::pb::RegionState_State state() const;
  void set_state(::hbase::pb::RegionState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.MetaRegionServer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::ServerName* server_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rpc_version_;
  int state_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class Master :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.Master) */ {
 public:
  Master();
  virtual ~Master();

  Master(const Master& from);
  Master(Master&& from) noexcept
    : Master() {
    *this = ::std::move(from);
  }

  inline Master& operator=(const Master& from) {
    CopyFrom(from);
    return *this;
  }
  inline Master& operator=(Master&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Master& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Master* internal_default_instance() {
    return reinterpret_cast<const Master*>(
               &_Master_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Master& a, Master& b) {
    a.Swap(&b);
  }
  inline void Swap(Master* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Master* New() const final {
    return CreateMaybeMessage<Master>(nullptr);
  }

  Master* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Master>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Master& from);
  void MergeFrom(const Master& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Master* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.Master";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMasterFieldNumber = 1,
    kRpcVersionFieldNumber = 2,
    kInfoPortFieldNumber = 3,
  };
  // required .hbase.pb.ServerName master = 1;
  bool has_master() const;
  void clear_master();
  const ::hbase::pb::ServerName& master() const;
  ::hbase::pb::ServerName* release_master();
  ::hbase::pb::ServerName* mutable_master();
  void set_allocated_master(::hbase::pb::ServerName* master);

  // optional uint32 rpc_version = 2;
  bool has_rpc_version() const;
  void clear_rpc_version();
  ::PROTOBUF_NAMESPACE_ID::uint32 rpc_version() const;
  void set_rpc_version(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 info_port = 3;
  bool has_info_port() const;
  void clear_info_port();
  ::PROTOBUF_NAMESPACE_ID::uint32 info_port() const;
  void set_info_port(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.Master)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::ServerName* master_;
  ::PROTOBUF_NAMESPACE_ID::uint32 rpc_version_;
  ::PROTOBUF_NAMESPACE_ID::uint32 info_port_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class ClusterUp :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ClusterUp) */ {
 public:
  ClusterUp();
  virtual ~ClusterUp();

  ClusterUp(const ClusterUp& from);
  ClusterUp(ClusterUp&& from) noexcept
    : ClusterUp() {
    *this = ::std::move(from);
  }

  inline ClusterUp& operator=(const ClusterUp& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClusterUp& operator=(ClusterUp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClusterUp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClusterUp* internal_default_instance() {
    return reinterpret_cast<const ClusterUp*>(
               &_ClusterUp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(ClusterUp& a, ClusterUp& b) {
    a.Swap(&b);
  }
  inline void Swap(ClusterUp* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClusterUp* New() const final {
    return CreateMaybeMessage<ClusterUp>(nullptr);
  }

  ClusterUp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClusterUp>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClusterUp& from);
  void MergeFrom(const ClusterUp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClusterUp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ClusterUp";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartDateFieldNumber = 1,
  };
  // required string start_date = 1;
  bool has_start_date() const;
  void clear_start_date();
  const std::string& start_date() const;
  void set_start_date(const std::string& value);
  void set_start_date(std::string&& value);
  void set_start_date(const char* value);
  void set_start_date(const char* value, size_t size);
  std::string* mutable_start_date();
  std::string* release_start_date();
  void set_allocated_start_date(std::string* start_date);

  // @@protoc_insertion_point(class_scope:hbase.pb.ClusterUp)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_date_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class SplitLogTask :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SplitLogTask) */ {
 public:
  SplitLogTask();
  virtual ~SplitLogTask();

  SplitLogTask(const SplitLogTask& from);
  SplitLogTask(SplitLogTask&& from) noexcept
    : SplitLogTask() {
    *this = ::std::move(from);
  }

  inline SplitLogTask& operator=(const SplitLogTask& from) {
    CopyFrom(from);
    return *this;
  }
  inline SplitLogTask& operator=(SplitLogTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SplitLogTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SplitLogTask* internal_default_instance() {
    return reinterpret_cast<const SplitLogTask*>(
               &_SplitLogTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SplitLogTask& a, SplitLogTask& b) {
    a.Swap(&b);
  }
  inline void Swap(SplitLogTask* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SplitLogTask* New() const final {
    return CreateMaybeMessage<SplitLogTask>(nullptr);
  }

  SplitLogTask* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SplitLogTask>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SplitLogTask& from);
  void MergeFrom(const SplitLogTask& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SplitLogTask* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SplitLogTask";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef SplitLogTask_State State;
  static constexpr State UNASSIGNED =
    SplitLogTask_State_UNASSIGNED;
  static constexpr State OWNED =
    SplitLogTask_State_OWNED;
  static constexpr State RESIGNED =
    SplitLogTask_State_RESIGNED;
  static constexpr State DONE =
    SplitLogTask_State_DONE;
  static constexpr State ERR =
    SplitLogTask_State_ERR;
  static inline bool State_IsValid(int value) {
    return SplitLogTask_State_IsValid(value);
  }
  static constexpr State State_MIN =
    SplitLogTask_State_State_MIN;
  static constexpr State State_MAX =
    SplitLogTask_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    SplitLogTask_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return SplitLogTask_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return SplitLogTask_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return SplitLogTask_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServerNameFieldNumber = 2,
    kStateFieldNumber = 1,
  };
  // required .hbase.pb.ServerName server_name = 2;
  bool has_server_name() const;
  void clear_server_name();
  const ::hbase::pb::ServerName& server_name() const;
  ::hbase::pb::ServerName* release_server_name();
  ::hbase::pb::ServerName* mutable_server_name();
  void set_allocated_server_name(::hbase::pb::ServerName* server_name);

  // required .hbase.pb.SplitLogTask.State state = 1;
  bool has_state() const;
  void clear_state();
  ::hbase::pb::SplitLogTask_State state() const;
  void set_state(::hbase::pb::SplitLogTask_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SplitLogTask)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::hbase::pb::ServerName* server_name_;
  int state_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class DeprecatedTableState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.DeprecatedTableState) */ {
 public:
  DeprecatedTableState();
  virtual ~DeprecatedTableState();

  DeprecatedTableState(const DeprecatedTableState& from);
  DeprecatedTableState(DeprecatedTableState&& from) noexcept
    : DeprecatedTableState() {
    *this = ::std::move(from);
  }

  inline DeprecatedTableState& operator=(const DeprecatedTableState& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeprecatedTableState& operator=(DeprecatedTableState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeprecatedTableState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeprecatedTableState* internal_default_instance() {
    return reinterpret_cast<const DeprecatedTableState*>(
               &_DeprecatedTableState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DeprecatedTableState& a, DeprecatedTableState& b) {
    a.Swap(&b);
  }
  inline void Swap(DeprecatedTableState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeprecatedTableState* New() const final {
    return CreateMaybeMessage<DeprecatedTableState>(nullptr);
  }

  DeprecatedTableState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeprecatedTableState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeprecatedTableState& from);
  void MergeFrom(const DeprecatedTableState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeprecatedTableState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.DeprecatedTableState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef DeprecatedTableState_State State;
  static constexpr State ENABLED =
    DeprecatedTableState_State_ENABLED;
  static constexpr State DISABLED =
    DeprecatedTableState_State_DISABLED;
  static constexpr State DISABLING =
    DeprecatedTableState_State_DISABLING;
  static constexpr State ENABLING =
    DeprecatedTableState_State_ENABLING;
  static inline bool State_IsValid(int value) {
    return DeprecatedTableState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    DeprecatedTableState_State_State_MIN;
  static constexpr State State_MAX =
    DeprecatedTableState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    DeprecatedTableState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return DeprecatedTableState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return DeprecatedTableState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return DeprecatedTableState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
  bool has_state() const;
  void clear_state();
  ::hbase::pb::DeprecatedTableState_State state() const;
  void set_state(::hbase::pb::DeprecatedTableState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.DeprecatedTableState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class TableCF :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.TableCF) */ {
 public:
  TableCF();
  virtual ~TableCF();

  TableCF(const TableCF& from);
  TableCF(TableCF&& from) noexcept
    : TableCF() {
    *this = ::std::move(from);
  }

  inline TableCF& operator=(const TableCF& from) {
    CopyFrom(from);
    return *this;
  }
  inline TableCF& operator=(TableCF&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TableCF& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableCF* internal_default_instance() {
    return reinterpret_cast<const TableCF*>(
               &_TableCF_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TableCF& a, TableCF& b) {
    a.Swap(&b);
  }
  inline void Swap(TableCF* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TableCF* New() const final {
    return CreateMaybeMessage<TableCF>(nullptr);
  }

  TableCF* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TableCF>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TableCF& from);
  void MergeFrom(const TableCF& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableCF* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.TableCF";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFamiliesFieldNumber = 2,
    kTableNameFieldNumber = 1,
  };
  // repeated bytes families = 2;
  int families_size() const;
  void clear_families();
  const std::string& families(int index) const;
  std::string* mutable_families(int index);
  void set_families(int index, const std::string& value);
  void set_families(int index, std::string&& value);
  void set_families(int index, const char* value);
  void set_families(int index, const void* value, size_t size);
  std::string* add_families();
  void add_families(const std::string& value);
  void add_families(std::string&& value);
  void add_families(const char* value);
  void add_families(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& families() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_families();

  // optional .hbase.pb.TableName table_name = 1;
  bool has_table_name() const;
  void clear_table_name();
  const ::hbase::pb::TableName& table_name() const;
  ::hbase::pb::TableName* release_table_name();
  ::hbase::pb::TableName* mutable_table_name();
  void set_allocated_table_name(::hbase::pb::TableName* table_name);

  // @@protoc_insertion_point(class_scope:hbase.pb.TableCF)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> families_;
  ::hbase::pb::TableName* table_name_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class ReplicationPeer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ReplicationPeer) */ {
 public:
  ReplicationPeer();
  virtual ~ReplicationPeer();

  ReplicationPeer(const ReplicationPeer& from);
  ReplicationPeer(ReplicationPeer&& from) noexcept
    : ReplicationPeer() {
    *this = ::std::move(from);
  }

  inline ReplicationPeer& operator=(const ReplicationPeer& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationPeer& operator=(ReplicationPeer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplicationPeer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplicationPeer* internal_default_instance() {
    return reinterpret_cast<const ReplicationPeer*>(
               &_ReplicationPeer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReplicationPeer& a, ReplicationPeer& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationPeer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationPeer* New() const final {
    return CreateMaybeMessage<ReplicationPeer>(nullptr);
  }

  ReplicationPeer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationPeer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplicationPeer& from);
  void MergeFrom(const ReplicationPeer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationPeer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ReplicationPeer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kConfigurationFieldNumber = 4,
    kTableCfsFieldNumber = 5,
    kNamespacesFieldNumber = 6,
    kClusterkeyFieldNumber = 1,
    kReplicationEndpointImplFieldNumber = 2,
    kBandwidthFieldNumber = 7,
  };
  // repeated .hbase.pb.BytesBytesPair data = 3;
  int data_size() const;
  void clear_data();
  ::hbase::pb::BytesBytesPair* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
      mutable_data();
  const ::hbase::pb::BytesBytesPair& data(int index) const;
  ::hbase::pb::BytesBytesPair* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
      data() const;

  // repeated .hbase.pb.NameStringPair configuration = 4;
  int configuration_size() const;
  void clear_configuration();
  ::hbase::pb::NameStringPair* mutable_configuration(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
      mutable_configuration();
  const ::hbase::pb::NameStringPair& configuration(int index) const;
  ::hbase::pb::NameStringPair* add_configuration();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
      configuration() const;

  // repeated .hbase.pb.TableCF table_cfs = 5;
  int table_cfs_size() const;
  void clear_table_cfs();
  ::hbase::pb::TableCF* mutable_table_cfs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::TableCF >*
      mutable_table_cfs();
  const ::hbase::pb::TableCF& table_cfs(int index) const;
  ::hbase::pb::TableCF* add_table_cfs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::TableCF >&
      table_cfs() const;

  // repeated bytes namespaces = 6;
  int namespaces_size() const;
  void clear_namespaces();
  const std::string& namespaces(int index) const;
  std::string* mutable_namespaces(int index);
  void set_namespaces(int index, const std::string& value);
  void set_namespaces(int index, std::string&& value);
  void set_namespaces(int index, const char* value);
  void set_namespaces(int index, const void* value, size_t size);
  std::string* add_namespaces();
  void add_namespaces(const std::string& value);
  void add_namespaces(std::string&& value);
  void add_namespaces(const char* value);
  void add_namespaces(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& namespaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_namespaces();

  // required string clusterkey = 1;
  bool has_clusterkey() const;
  void clear_clusterkey();
  const std::string& clusterkey() const;
  void set_clusterkey(const std::string& value);
  void set_clusterkey(std::string&& value);
  void set_clusterkey(const char* value);
  void set_clusterkey(const char* value, size_t size);
  std::string* mutable_clusterkey();
  std::string* release_clusterkey();
  void set_allocated_clusterkey(std::string* clusterkey);

  // optional string replicationEndpointImpl = 2;
  bool has_replicationendpointimpl() const;
  void clear_replicationendpointimpl();
  const std::string& replicationendpointimpl() const;
  void set_replicationendpointimpl(const std::string& value);
  void set_replicationendpointimpl(std::string&& value);
  void set_replicationendpointimpl(const char* value);
  void set_replicationendpointimpl(const char* value, size_t size);
  std::string* mutable_replicationendpointimpl();
  std::string* release_replicationendpointimpl();
  void set_allocated_replicationendpointimpl(std::string* replicationendpointimpl);

  // optional int64 bandwidth = 7;
  bool has_bandwidth() const;
  void clear_bandwidth();
  ::PROTOBUF_NAMESPACE_ID::int64 bandwidth() const;
  void set_bandwidth(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationPeer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair > data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair > configuration_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::TableCF > table_cfs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> namespaces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clusterkey_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replicationendpointimpl_;
  ::PROTOBUF_NAMESPACE_ID::int64 bandwidth_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class ReplicationState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ReplicationState) */ {
 public:
  ReplicationState();
  virtual ~ReplicationState();

  ReplicationState(const ReplicationState& from);
  ReplicationState(ReplicationState&& from) noexcept
    : ReplicationState() {
    *this = ::std::move(from);
  }

  inline ReplicationState& operator=(const ReplicationState& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationState& operator=(ReplicationState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplicationState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplicationState* internal_default_instance() {
    return reinterpret_cast<const ReplicationState*>(
               &_ReplicationState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ReplicationState& a, ReplicationState& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationState* New() const final {
    return CreateMaybeMessage<ReplicationState>(nullptr);
  }

  ReplicationState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplicationState& from);
  void MergeFrom(const ReplicationState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ReplicationState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ReplicationState_State State;
  static constexpr State ENABLED =
    ReplicationState_State_ENABLED;
  static constexpr State DISABLED =
    ReplicationState_State_DISABLED;
  static inline bool State_IsValid(int value) {
    return ReplicationState_State_IsValid(value);
  }
  static constexpr State State_MIN =
    ReplicationState_State_State_MIN;
  static constexpr State State_MAX =
    ReplicationState_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    ReplicationState_State_State_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  State_descriptor() {
    return ReplicationState_State_descriptor();
  }
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return ReplicationState_State_Name(enum_t_value);
  }
  static inline bool State_Parse(const std::string& name,
      State* value) {
    return ReplicationState_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // required .hbase.pb.ReplicationState.State state = 1;
  bool has_state() const;
  void clear_state();
  ::hbase::pb::ReplicationState_State state() const;
  void set_state(::hbase::pb::ReplicationState_State value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class ReplicationHLogPosition :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.ReplicationHLogPosition) */ {
 public:
  ReplicationHLogPosition();
  virtual ~ReplicationHLogPosition();

  ReplicationHLogPosition(const ReplicationHLogPosition& from);
  ReplicationHLogPosition(ReplicationHLogPosition&& from) noexcept
    : ReplicationHLogPosition() {
    *this = ::std::move(from);
  }

  inline ReplicationHLogPosition& operator=(const ReplicationHLogPosition& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicationHLogPosition& operator=(ReplicationHLogPosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ReplicationHLogPosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplicationHLogPosition* internal_default_instance() {
    return reinterpret_cast<const ReplicationHLogPosition*>(
               &_ReplicationHLogPosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ReplicationHLogPosition& a, ReplicationHLogPosition& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicationHLogPosition* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ReplicationHLogPosition* New() const final {
    return CreateMaybeMessage<ReplicationHLogPosition>(nullptr);
  }

  ReplicationHLogPosition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ReplicationHLogPosition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ReplicationHLogPosition& from);
  void MergeFrom(const ReplicationHLogPosition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicationHLogPosition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.ReplicationHLogPosition";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
  };
  // required int64 position = 1;
  bool has_position() const;
  void clear_position();
  ::PROTOBUF_NAMESPACE_ID::int64 position() const;
  void set_position(::PROTOBUF_NAMESPACE_ID::int64 value);

  // @@protoc_insertion_point(class_scope:hbase.pb.ReplicationHLogPosition)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 position_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// -------------------------------------------------------------------

class SwitchState :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:hbase.pb.SwitchState) */ {
 public:
  SwitchState();
  virtual ~SwitchState();

  SwitchState(const SwitchState& from);
  SwitchState(SwitchState&& from) noexcept
    : SwitchState() {
    *this = ::std::move(from);
  }

  inline SwitchState& operator=(const SwitchState& from) {
    CopyFrom(from);
    return *this;
  }
  inline SwitchState& operator=(SwitchState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SwitchState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SwitchState* internal_default_instance() {
    return reinterpret_cast<const SwitchState*>(
               &_SwitchState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SwitchState& a, SwitchState& b) {
    a.Swap(&b);
  }
  inline void Swap(SwitchState* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SwitchState* New() const final {
    return CreateMaybeMessage<SwitchState>(nullptr);
  }

  SwitchState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SwitchState>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SwitchState& from);
  void MergeFrom(const SwitchState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SwitchState* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "hbase.pb.SwitchState";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_ZooKeeper_2eproto);
    return ::descriptor_table_ZooKeeper_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:hbase.pb.SwitchState)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  friend struct ::TableStruct_ZooKeeper_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MetaRegionServer

// required .hbase.pb.ServerName server = 1;
inline bool MetaRegionServer::has_server() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::ServerName& MetaRegionServer::server() const {
  const ::hbase::pb::ServerName* p = server_;
  // @@protoc_insertion_point(field_get:hbase.pb.MetaRegionServer.server)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* MetaRegionServer::release_server() {
  // @@protoc_insertion_point(field_release:hbase.pb.MetaRegionServer.server)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ServerName* temp = server_;
  server_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* MetaRegionServer::mutable_server() {
  _has_bits_[0] |= 0x00000001u;
  if (server_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    server_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.MetaRegionServer.server)
  return server_;
}
inline void MetaRegionServer::set_allocated_server(::hbase::pb::ServerName* server) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_);
  }
  if (server) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_ = server;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.MetaRegionServer.server)
}

// optional uint32 rpc_version = 2;
inline bool MetaRegionServer::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MetaRegionServer::clear_rpc_version() {
  rpc_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 MetaRegionServer::rpc_version() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MetaRegionServer.rpc_version)
  return rpc_version_;
}
inline void MetaRegionServer::set_rpc_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rpc_version_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MetaRegionServer.rpc_version)
}

// optional .hbase.pb.RegionState.State state = 3;
inline bool MetaRegionServer::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MetaRegionServer::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::hbase::pb::RegionState_State MetaRegionServer::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.MetaRegionServer.state)
  return static_cast< ::hbase::pb::RegionState_State >(state_);
}
inline void MetaRegionServer::set_state(::hbase::pb::RegionState_State value) {
  assert(::hbase::pb::RegionState_State_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.MetaRegionServer.state)
}

// -------------------------------------------------------------------

// Master

// required .hbase.pb.ServerName master = 1;
inline bool Master::has_master() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::ServerName& Master::master() const {
  const ::hbase::pb::ServerName* p = master_;
  // @@protoc_insertion_point(field_get:hbase.pb.Master.master)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* Master::release_master() {
  // @@protoc_insertion_point(field_release:hbase.pb.Master.master)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ServerName* temp = master_;
  master_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* Master::mutable_master() {
  _has_bits_[0] |= 0x00000001u;
  if (master_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    master_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.Master.master)
  return master_;
}
inline void Master::set_allocated_master(::hbase::pb::ServerName* master) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(master_);
  }
  if (master) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      master = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, master, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  master_ = master;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.Master.master)
}

// optional uint32 rpc_version = 2;
inline bool Master::has_rpc_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Master::clear_rpc_version() {
  rpc_version_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Master::rpc_version() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Master.rpc_version)
  return rpc_version_;
}
inline void Master::set_rpc_version(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  rpc_version_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Master.rpc_version)
}

// optional uint32 info_port = 3;
inline bool Master::has_info_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Master::clear_info_port() {
  info_port_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Master::info_port() const {
  // @@protoc_insertion_point(field_get:hbase.pb.Master.info_port)
  return info_port_;
}
inline void Master::set_info_port(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  info_port_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.Master.info_port)
}

// -------------------------------------------------------------------

// ClusterUp

// required string start_date = 1;
inline bool ClusterUp::has_start_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClusterUp::clear_start_date() {
  start_date_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClusterUp::start_date() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ClusterUp.start_date)
  return start_date_.GetNoArena();
}
inline void ClusterUp::set_start_date(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  start_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ClusterUp.start_date)
}
inline void ClusterUp::set_start_date(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  start_date_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ClusterUp.start_date)
}
inline void ClusterUp::set_start_date(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  start_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ClusterUp.start_date)
}
inline void ClusterUp::set_start_date(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  start_date_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ClusterUp.start_date)
}
inline std::string* ClusterUp::mutable_start_date() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ClusterUp.start_date)
  return start_date_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ClusterUp::release_start_date() {
  // @@protoc_insertion_point(field_release:hbase.pb.ClusterUp.start_date)
  if (!has_start_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return start_date_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ClusterUp::set_allocated_start_date(std::string* start_date) {
  if (start_date != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  start_date_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_date);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ClusterUp.start_date)
}

// -------------------------------------------------------------------

// SplitLogTask

// required .hbase.pb.SplitLogTask.State state = 1;
inline bool SplitLogTask::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SplitLogTask::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::hbase::pb::SplitLogTask_State SplitLogTask::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SplitLogTask.state)
  return static_cast< ::hbase::pb::SplitLogTask_State >(state_);
}
inline void SplitLogTask::set_state(::hbase::pb::SplitLogTask_State value) {
  assert(::hbase::pb::SplitLogTask_State_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SplitLogTask.state)
}

// required .hbase.pb.ServerName server_name = 2;
inline bool SplitLogTask::has_server_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::ServerName& SplitLogTask::server_name() const {
  const ::hbase::pb::ServerName* p = server_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.SplitLogTask.server_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::ServerName*>(
      &::hbase::pb::_ServerName_default_instance_);
}
inline ::hbase::pb::ServerName* SplitLogTask::release_server_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.SplitLogTask.server_name)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::ServerName* temp = server_name_;
  server_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::ServerName* SplitLogTask::mutable_server_name() {
  _has_bits_[0] |= 0x00000001u;
  if (server_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::ServerName>(GetArenaNoVirtual());
    server_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.SplitLogTask.server_name)
  return server_name_;
}
inline void SplitLogTask::set_allocated_server_name(::hbase::pb::ServerName* server_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_name_);
  }
  if (server_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      server_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_name_ = server_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.SplitLogTask.server_name)
}

// -------------------------------------------------------------------

// DeprecatedTableState

// required .hbase.pb.DeprecatedTableState.State state = 1 [default = ENABLED];
inline bool DeprecatedTableState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeprecatedTableState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::hbase::pb::DeprecatedTableState_State DeprecatedTableState::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.DeprecatedTableState.state)
  return static_cast< ::hbase::pb::DeprecatedTableState_State >(state_);
}
inline void DeprecatedTableState::set_state(::hbase::pb::DeprecatedTableState_State value) {
  assert(::hbase::pb::DeprecatedTableState_State_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.DeprecatedTableState.state)
}

// -------------------------------------------------------------------

// TableCF

// optional .hbase.pb.TableName table_name = 1;
inline bool TableCF::has_table_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::hbase::pb::TableName& TableCF::table_name() const {
  const ::hbase::pb::TableName* p = table_name_;
  // @@protoc_insertion_point(field_get:hbase.pb.TableCF.table_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::hbase::pb::TableName*>(
      &::hbase::pb::_TableName_default_instance_);
}
inline ::hbase::pb::TableName* TableCF::release_table_name() {
  // @@protoc_insertion_point(field_release:hbase.pb.TableCF.table_name)
  _has_bits_[0] &= ~0x00000001u;
  ::hbase::pb::TableName* temp = table_name_;
  table_name_ = nullptr;
  return temp;
}
inline ::hbase::pb::TableName* TableCF::mutable_table_name() {
  _has_bits_[0] |= 0x00000001u;
  if (table_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::hbase::pb::TableName>(GetArenaNoVirtual());
    table_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableCF.table_name)
  return table_name_;
}
inline void TableCF::set_allocated_table_name(::hbase::pb::TableName* table_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_name_);
  }
  if (table_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_name_ = table_name;
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.TableCF.table_name)
}

// repeated bytes families = 2;
inline int TableCF::families_size() const {
  return families_.size();
}
inline void TableCF::clear_families() {
  families_.Clear();
}
inline const std::string& TableCF::families(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.TableCF.families)
  return families_.Get(index);
}
inline std::string* TableCF::mutable_families(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.TableCF.families)
  return families_.Mutable(index);
}
inline void TableCF::set_families(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.TableCF.families)
  families_.Mutable(index)->assign(value);
}
inline void TableCF::set_families(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.TableCF.families)
  families_.Mutable(index)->assign(std::move(value));
}
inline void TableCF::set_families(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  families_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.TableCF.families)
}
inline void TableCF::set_families(int index, const void* value, size_t size) {
  families_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.TableCF.families)
}
inline std::string* TableCF::add_families() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.TableCF.families)
  return families_.Add();
}
inline void TableCF::add_families(const std::string& value) {
  families_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.TableCF.families)
}
inline void TableCF::add_families(std::string&& value) {
  families_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.TableCF.families)
}
inline void TableCF::add_families(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  families_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.TableCF.families)
}
inline void TableCF::add_families(const void* value, size_t size) {
  families_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.TableCF.families)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TableCF::families() const {
  // @@protoc_insertion_point(field_list:hbase.pb.TableCF.families)
  return families_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TableCF::mutable_families() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.TableCF.families)
  return &families_;
}

// -------------------------------------------------------------------

// ReplicationPeer

// required string clusterkey = 1;
inline bool ReplicationPeer::has_clusterkey() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationPeer::clear_clusterkey() {
  clusterkey_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplicationPeer::clusterkey() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.clusterkey)
  return clusterkey_.GetNoArena();
}
inline void ReplicationPeer::set_clusterkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  clusterkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationPeer.clusterkey)
}
inline void ReplicationPeer::set_clusterkey(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  clusterkey_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ReplicationPeer.clusterkey)
}
inline void ReplicationPeer::set_clusterkey(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  clusterkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ReplicationPeer.clusterkey)
}
inline void ReplicationPeer::set_clusterkey(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  clusterkey_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ReplicationPeer.clusterkey)
}
inline std::string* ReplicationPeer::mutable_clusterkey() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.clusterkey)
  return clusterkey_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ReplicationPeer::release_clusterkey() {
  // @@protoc_insertion_point(field_release:hbase.pb.ReplicationPeer.clusterkey)
  if (!has_clusterkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return clusterkey_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ReplicationPeer::set_allocated_clusterkey(std::string* clusterkey) {
  if (clusterkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  clusterkey_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clusterkey);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ReplicationPeer.clusterkey)
}

// optional string replicationEndpointImpl = 2;
inline bool ReplicationPeer::has_replicationendpointimpl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplicationPeer::clear_replicationendpointimpl() {
  replicationendpointimpl_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ReplicationPeer::replicationendpointimpl() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.replicationEndpointImpl)
  return replicationendpointimpl_.GetNoArena();
}
inline void ReplicationPeer::set_replicationendpointimpl(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  replicationendpointimpl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationPeer.replicationEndpointImpl)
}
inline void ReplicationPeer::set_replicationendpointimpl(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  replicationendpointimpl_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hbase.pb.ReplicationPeer.replicationEndpointImpl)
}
inline void ReplicationPeer::set_replicationendpointimpl(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  replicationendpointimpl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hbase.pb.ReplicationPeer.replicationEndpointImpl)
}
inline void ReplicationPeer::set_replicationendpointimpl(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  replicationendpointimpl_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ReplicationPeer.replicationEndpointImpl)
}
inline std::string* ReplicationPeer::mutable_replicationendpointimpl() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.replicationEndpointImpl)
  return replicationendpointimpl_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* ReplicationPeer::release_replicationendpointimpl() {
  // @@protoc_insertion_point(field_release:hbase.pb.ReplicationPeer.replicationEndpointImpl)
  if (!has_replicationendpointimpl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return replicationendpointimpl_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void ReplicationPeer::set_allocated_replicationendpointimpl(std::string* replicationendpointimpl) {
  if (replicationendpointimpl != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  replicationendpointimpl_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), replicationendpointimpl);
  // @@protoc_insertion_point(field_set_allocated:hbase.pb.ReplicationPeer.replicationEndpointImpl)
}

// repeated .hbase.pb.BytesBytesPair data = 3;
inline int ReplicationPeer::data_size() const {
  return data_.size();
}
inline ::hbase::pb::BytesBytesPair* ReplicationPeer::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.data)
  return data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >*
ReplicationPeer::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ReplicationPeer.data)
  return &data_;
}
inline const ::hbase::pb::BytesBytesPair& ReplicationPeer::data(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.data)
  return data_.Get(index);
}
inline ::hbase::pb::BytesBytesPair* ReplicationPeer::add_data() {
  // @@protoc_insertion_point(field_add:hbase.pb.ReplicationPeer.data)
  return data_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::BytesBytesPair >&
ReplicationPeer::data() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ReplicationPeer.data)
  return data_;
}

// repeated .hbase.pb.NameStringPair configuration = 4;
inline int ReplicationPeer::configuration_size() const {
  return configuration_.size();
}
inline ::hbase::pb::NameStringPair* ReplicationPeer::mutable_configuration(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.configuration)
  return configuration_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >*
ReplicationPeer::mutable_configuration() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ReplicationPeer.configuration)
  return &configuration_;
}
inline const ::hbase::pb::NameStringPair& ReplicationPeer::configuration(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.configuration)
  return configuration_.Get(index);
}
inline ::hbase::pb::NameStringPair* ReplicationPeer::add_configuration() {
  // @@protoc_insertion_point(field_add:hbase.pb.ReplicationPeer.configuration)
  return configuration_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::NameStringPair >&
ReplicationPeer::configuration() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ReplicationPeer.configuration)
  return configuration_;
}

// repeated .hbase.pb.TableCF table_cfs = 5;
inline int ReplicationPeer::table_cfs_size() const {
  return table_cfs_.size();
}
inline void ReplicationPeer::clear_table_cfs() {
  table_cfs_.Clear();
}
inline ::hbase::pb::TableCF* ReplicationPeer::mutable_table_cfs(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.table_cfs)
  return table_cfs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::TableCF >*
ReplicationPeer::mutable_table_cfs() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ReplicationPeer.table_cfs)
  return &table_cfs_;
}
inline const ::hbase::pb::TableCF& ReplicationPeer::table_cfs(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.table_cfs)
  return table_cfs_.Get(index);
}
inline ::hbase::pb::TableCF* ReplicationPeer::add_table_cfs() {
  // @@protoc_insertion_point(field_add:hbase.pb.ReplicationPeer.table_cfs)
  return table_cfs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::hbase::pb::TableCF >&
ReplicationPeer::table_cfs() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ReplicationPeer.table_cfs)
  return table_cfs_;
}

// repeated bytes namespaces = 6;
inline int ReplicationPeer::namespaces_size() const {
  return namespaces_.size();
}
inline void ReplicationPeer::clear_namespaces() {
  namespaces_.Clear();
}
inline const std::string& ReplicationPeer::namespaces(int index) const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.namespaces)
  return namespaces_.Get(index);
}
inline std::string* ReplicationPeer::mutable_namespaces(int index) {
  // @@protoc_insertion_point(field_mutable:hbase.pb.ReplicationPeer.namespaces)
  return namespaces_.Mutable(index);
}
inline void ReplicationPeer::set_namespaces(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationPeer.namespaces)
  namespaces_.Mutable(index)->assign(value);
}
inline void ReplicationPeer::set_namespaces(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationPeer.namespaces)
  namespaces_.Mutable(index)->assign(std::move(value));
}
inline void ReplicationPeer::set_namespaces(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hbase.pb.ReplicationPeer.namespaces)
}
inline void ReplicationPeer::set_namespaces(int index, const void* value, size_t size) {
  namespaces_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hbase.pb.ReplicationPeer.namespaces)
}
inline std::string* ReplicationPeer::add_namespaces() {
  // @@protoc_insertion_point(field_add_mutable:hbase.pb.ReplicationPeer.namespaces)
  return namespaces_.Add();
}
inline void ReplicationPeer::add_namespaces(const std::string& value) {
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hbase.pb.ReplicationPeer.namespaces)
}
inline void ReplicationPeer::add_namespaces(std::string&& value) {
  namespaces_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hbase.pb.ReplicationPeer.namespaces)
}
inline void ReplicationPeer::add_namespaces(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  namespaces_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hbase.pb.ReplicationPeer.namespaces)
}
inline void ReplicationPeer::add_namespaces(const void* value, size_t size) {
  namespaces_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hbase.pb.ReplicationPeer.namespaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ReplicationPeer::namespaces() const {
  // @@protoc_insertion_point(field_list:hbase.pb.ReplicationPeer.namespaces)
  return namespaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ReplicationPeer::mutable_namespaces() {
  // @@protoc_insertion_point(field_mutable_list:hbase.pb.ReplicationPeer.namespaces)
  return &namespaces_;
}

// optional int64 bandwidth = 7;
inline bool ReplicationPeer::has_bandwidth() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplicationPeer::clear_bandwidth() {
  bandwidth_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationPeer::bandwidth() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationPeer.bandwidth)
  return bandwidth_;
}
inline void ReplicationPeer::set_bandwidth(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000004u;
  bandwidth_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationPeer.bandwidth)
}

// -------------------------------------------------------------------

// ReplicationState

// required .hbase.pb.ReplicationState.State state = 1;
inline bool ReplicationState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationState::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::hbase::pb::ReplicationState_State ReplicationState::state() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationState.state)
  return static_cast< ::hbase::pb::ReplicationState_State >(state_);
}
inline void ReplicationState::set_state(::hbase::pb::ReplicationState_State value) {
  assert(::hbase::pb::ReplicationState_State_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationState.state)
}

// -------------------------------------------------------------------

// ReplicationHLogPosition

// required int64 position = 1;
inline bool ReplicationHLogPosition::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicationHLogPosition::clear_position() {
  position_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ReplicationHLogPosition::position() const {
  // @@protoc_insertion_point(field_get:hbase.pb.ReplicationHLogPosition.position)
  return position_;
}
inline void ReplicationHLogPosition::set_position(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  position_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.ReplicationHLogPosition.position)
}

// -------------------------------------------------------------------

// SwitchState

// optional bool enabled = 1;
inline bool SwitchState::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SwitchState::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool SwitchState::enabled() const {
  // @@protoc_insertion_point(field_get:hbase.pb.SwitchState.enabled)
  return enabled_;
}
inline void SwitchState::set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
  // @@protoc_insertion_point(field_set:hbase.pb.SwitchState.enabled)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb
}  // namespace hbase

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::hbase::pb::SplitLogTask_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::SplitLogTask_State>() {
  return ::hbase::pb::SplitLogTask_State_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::DeprecatedTableState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::DeprecatedTableState_State>() {
  return ::hbase::pb::DeprecatedTableState_State_descriptor();
}
template <> struct is_proto_enum< ::hbase::pb::ReplicationState_State> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hbase::pb::ReplicationState_State>() {
  return ::hbase::pb::ReplicationState_State_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ZooKeeper_2eproto
